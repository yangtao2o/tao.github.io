{"meta":{"title":"大涛子","subtitle":"简单、极致、不失风趣","description":"大涛子写博客的地方，记录日常前端开发中遇到的问题，以及学习到的知识。","author":"杨涛","url":"https://www.yangtao.site"},"pages":[{"title":"欢迎来到「大涛子客栈」","date":"2019-12-02T11:54:54.382Z","updated":"2019-12-02T11:54:54.382Z","comments":true,"path":"about/index.html","permalink":"https://www.yangtao.site/about/index.html","excerpt":"","text":"这里，你可以说一些话… 等我想好了，再认认真真地介绍下自己吧，hahaha… 如果要联系我，记得留下联系方式，或者最下边有我的联系方式噢… 😺😺😺😺😺😺😺😺😺😺😺😺😺"},{"title":"天涯若比邻 | 胡天侃地","date":"2020-04-05T03:34:10.820Z","updated":"2020-04-05T03:34:10.820Z","comments":true,"path":"friends/index.html","permalink":"https://www.yangtao.site/friends/index.html","excerpt":"","text":"各位走过路过的朋友想交换友链的话，可以在下方留言，要有名称、头像链接、和至少一个标签哦～ 名称： 大涛子峡谷头像： https://ae01.alicdn.com/kf/H77cd89dcc6ad420297a555d36891af53B.jpg网址： https://www.yangtao.site标签： 前端开发 摄影 分组和标签不合适的话可以留言或者发邮件私聊我进行更改。头像尺寸是 64px，3 倍精细度就足够了，也就是 192px，如果文件体积太大可以压缩一下。"},{"title":"所有标签","date":"2019-03-13T14:13:17.374Z","updated":"2019-03-13T14:13:17.374Z","comments":true,"path":"tags/index.html","permalink":"https://www.yangtao.site/tags/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2019-03-13T13:46:54.784Z","updated":"2019-03-13T13:46:54.784Z","comments":true,"path":"categories/index.html","permalink":"https://www.yangtao.site/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Hi，很高兴见到你~","slug":"hello-world","date":"2048-10-24T05:14:15.000Z","updated":"2020-03-18T04:09:39.746Z","comments":true,"path":"2048/10/24/hello-world/","link":"","permalink":"https://www.yangtao.site/2048/10/24/hello-world/","excerpt":"","text":"欢迎在此留言，或者去友链看看大家 ~","categories":[],"tags":[]},{"title":"在 Nginx 服务器上配置 HTTPS 证书","slug":"http-https","date":"2020-04-04T13:56:50.000Z","updated":"2020-04-05T03:26:01.512Z","comments":true,"path":"2020/04/04/http-https/","link":"","permalink":"https://www.yangtao.site/2020/04/04/http-https/","excerpt":"安装 https 证书的一些过程","text":"安装 https 证书的一些过程 下载证书我使用的阿里云免费个人版，有效期一年。 1234567891011~/Downloads ❯❯❯ cd 3713633_www.yangtao.site_nginx/~/D/3713633_www.yangtao.site_nginx ❯❯❯ ls3713633_www.yangtao.site.key 3713633_www.yangtao.site.pem~/D/3713633_www.yangtao.site_nginx ❯❯❯scp 3713633_www.yangtao.site.key 3713633_www.yangtao.site.pem root@47.101.33.81:/usr/local/nginx/cert/root@47.101.33.81's password:Permission denied, please try again.root@47.101.33.81's password:3713633_www.yangtao.site.key 100% 1675 88.9KB/s 00:003713633_www.yangtao.site.pem 100% 3675 274.2KB/s 00:00~/D/3713633_www.yangtao.site_nginx ❯❯❯ 12root@istaotao:/usr/local/nginx/cert# ls3713633_www.yangtao.site.key 3713633_www.yangtao.site.pem 修改配置按照下文中注释内容修改 nginx.conf 文件： 12345678910111213141516server &#123; listen 443 ssl; #SSL协议访问端口号为443。此处如未添加ssl，可能会造成Nginx无法启动。 server_name localhost; #将localhost修改为您证书绑定的域名，例如：www.example.com。 root html; index index.html index.htm; ssl_certificate cert/domain name.pem; #将domain name.pem替换成您证书的文件名。 ssl_certificate_key cert/domain name.key; #将domain name.key替换成您证书的密钥文件名。 ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #使用此加密套件。 ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #使用该协议进行配置。 ssl_prefer_server_ciphers on; location / &#123; root html; #站点目录。 index index.html index.htm; &#125;&#125; 强制 http 跳转使用 curl 命令： 123456789101112131415161718192021222324252627~ ❯❯❯ curl baidu.com -v* Trying 220.181.38.148...* TCP_NODELAY set* Connected to baidu.com (220.181.38.148) port 80 (#0)&gt; GET / HTTP/1.1&gt; Host: baidu.com&gt; User-Agent: curl/7.64.1&gt; Accept: */*&gt;&lt; HTTP/1.1 200 OK&lt; Date: Sat, 04 Apr 2020 16:33:35 GMT&lt; Server: Apache&lt; Last-Modified: Tue, 12 Jan 2010 13:48:00 GMT&lt; ETag: \"51-47cf7e6ee8400\"&lt; Accept-Ranges: bytes&lt; Content-Length: 81&lt; Cache-Control: max-age=86400&lt; Expires: Sun, 05 Apr 2020 16:33:35 GMT&lt; Connection: Keep-Alive&lt; Content-Type: text/html&lt;&lt;html&gt;&lt;meta http-equiv=\"refresh\" content=\"0;url=http://www.baidu.com/\"&gt;&lt;/html&gt;* Connection #0 to host baidu.com left intact* Closing connection 0~ ❯❯❯ 可以看到百度很巧妙的利用 meta 的刷新作用，将 baidu.com 跳转到 www.baidu.com同理, 我们也可以用这个特性来实现 http 向 https 的跳转 1234# index.html&lt;html&gt; &lt;meta http-equiv=\"refresh\" content=\"0;url=https://www.yangtao.site/\" /&gt;&lt;/html&gt; 12345678server &#123; listen 80; server_name yangtao.site; location / &#123; root /var/www/html/refresh/; &#125;&#125; 测试 yangtao.site： 123456789101112131415161718192021222324~ ❯❯❯ curl yangtao.site -v* Trying 47.101.33.81...* TCP_NODELAY set* Connected to yangtao.site (47.101.33.81) port 80 (#0)&gt; GET / HTTP/1.1&gt; Host: yangtao.site&gt; User-Agent: curl/7.64.1&gt; Accept: */*&gt;&lt; HTTP/1.1 200 OK&lt; Server: nginx/1.14.0 (Ubuntu)&lt; Date: Sat, 04 Apr 2020 16:34:16 GMT&lt; Content-Type: text/html&lt; Content-Length: 91&lt; Last-Modified: Sat, 04 Apr 2020 16:04:03 GMT&lt; Connection: keep-alive&lt; ETag: \"5e88aff3-5b\"&lt; Accept-Ranges: bytes&lt;&lt;html&gt; &lt;meta http-equiv=\"refresh\" content=\"0;url=https://www.yangtao.site/\"&gt;&lt;/html&gt;* Connection #0 to host yangtao.site left intact* Closing connection 0 参考资料 在 Nginx/Tengine 服务器上安装证书 Nginx 配置 https 证书 nginx 配置 http 强制跳转 https","categories":[{"name":"服务端","slug":"服务端","permalink":"https://www.yangtao.site/categories/服务端/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.yangtao.site/tags/Hexo/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://www.yangtao.site/tags/Ubuntu/"}]},{"title":"JavaScript 深浅拷贝","slug":"code-copy","date":"2020-04-03T03:04:25.000Z","updated":"2020-04-03T03:46:22.371Z","comments":true,"path":"2020/04/03/code-copy/","link":"","permalink":"https://www.yangtao.site/2020/04/03/code-copy/","excerpt":"浅拷贝技巧：数组concat slice，对象Object.assign()等；深拷贝技巧：JSON.parse(JSON.stringify(arr1))。","text":"浅拷贝技巧：数组concat slice，对象Object.assign()等；深拷贝技巧：JSON.parse(JSON.stringify(arr1))。 数组的浅拷贝如果数组元素是基本类型，就会拷贝一份，互不影响，而如果是对象或者数组，就会只拷贝对象和数组的引用，这样我们无论在新旧数组进行了修改，两者都会发生变化。 我们把这种复制引用的拷贝方法称之为浅拷贝，与之对应的就是深拷贝，深拷贝就是指完全的拷贝一个对象，即使嵌套了对象，两者也相互分离，修改一个对象的属性，也不会影响另一个。 比如，数组的一些方法：concat、slice： 123456789var arr = [\"old\", 1, true, null, undefined];var newArr = arr.concat();newArr.shift();console.log(arr); // [ 'old', 1, true, null, undefined ]console.log(newArr); // [ 1, true, null, undefined ]var newArr2 = arr.slice();console.log(newArr2); // [ 'old', 1, true, null, undefined ] 但是如果数组嵌套了对象或者数组的话，就会都受影响，比如： 123456var arrObj = [&#123; a: 1 &#125;, &#123; b: 2 &#125;];var newArrObj = arrObj.concat();newArrObj[0].a = \"aaa\";console.log(newArrObj); // [ &#123; a: 'aaa' &#125;, &#123; b: 2 &#125; ]console.log(arrObj); // [ &#123; a: 'aaa' &#125;, &#123; b: 2 &#125; ] 数组的深拷贝使用 JSON.stringify()和JSON.parse()，不管是数组还是对象，都可以实现深拷贝，但是不能拷贝函数，会返回一个 null： 12345var arr1 = [\"old\", 1, true, [\"old1\", \"old2\"], &#123; old: 1 &#125;, function() &#123;&#125;];var newArr1 = JSON.parse(JSON.stringify(arr1));newArr1.shift();console.log(arr1); // [ 'old', 1, true, [ 'old1', 'old2' ], &#123; old: 1 &#125;, [Function] ]console.log(newArr1); // [ 1, true, [ 'old1', 'old2' ], &#123; old: 1 &#125;, null ] Object.assignObject.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。 12// target 目标对象，sources 源对象Object.assign(target, ...sources); Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的[[Get]]和目标对象的[[Set]]，所以它会调用相关 getter 和 setter。 String 类型和 Symbol 类型的属性都会被拷贝。 1234// 赋值一个对象const obj = &#123; a: 1 &#125;;const copy = Object.assign(&#123;&#125;, obj);console.log(copy); // &#123; a: 1 &#125; 针对深拷贝，需要使用其他办法，如借助 JSON，因为 Object.assign()拷贝的是属性值。假如源对象的属性值是一个对象的引用，那么它也只指向那个引用。 12345obj1 = &#123; a: 0, b: &#123; c: 0 &#125; &#125;;let obj3 = JSON.parse(JSON.stringify(obj1));obj1.a = 4;obj1.b.c = 4;console.log(JSON.stringify(obj3)); // &#123;\"a\":0,\"b\":&#123;\"c\":0&#125;&#125; 浅拷贝的实现技巧型的拷贝，如上边使用的 concat、slice、JSON.stringify等，如果要实现一个对象或者数组的浅拷贝，该怎么实现呢？ 思路：既然是浅拷贝，那就只需要遍历，把对应的属性及属性值添加到新的对象，并返回。 代码实现： 1234567891011121314151617181920var shallowCopy = function(obj) &#123; if (typeof obj !== \"object\") return; // 判断新建的是数组还是对象 var newObj = obj instanceof Array ? [] : &#123;&#125;; // 遍历obj，并且判断是obj的属性才拷贝 for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; newObj[key] = obj[key]; &#125; &#125; return newObj;&#125;;var arr20 = [\"old\", 1, true, [\"old1\", \"old2\"], &#123; old: 1 &#125;, function() &#123;&#125;];var newArr20 = shallowCopy(arr20);console.log(&#123; newArr20 &#125;);// [ 'old', 1, true, [ 'old1', 'old2' ], &#123; old: 1 &#125;, [Function] ] 深拷贝的实现思路：如果是对象，通过递归调用拷贝函数 代码实现： 12345678910111213141516171819202122232425262728var deepCopy = function(obj) &#123; if (typeof obj !== \"object\") return; var newObj = obj instanceof Array ? [] : &#123;&#125;; for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; newObj[key] = typeof obj[key] !== \"object\" ? obj[key] : deepCopy(obj[key]); &#125; &#125; return newObj;&#125;;var obj = &#123; a: function() &#123;&#125;, b: &#123; name: \"Tony\", age: 10 &#125;, c: [1, 2, 3]&#125;;var newObj = deepCopy(obj);console.log(newObj);// &#123; a: [Function: a],// b: &#123; name: 'Tony', age: 10 &#125;,// c: [ 1, 2, 3 ] &#125; 模拟 jQuery 的 extendextend 的用法：合并两个或者更多的对象的内容到第一个对象中。 1jQuery.extend( [deep], target, object1 [, objectN ] ) deep，布尔值，如果为 true，进行深拷贝；false 做浅拷贝，target 就往后移动到第二个参数 target，表示要拓展的目标，我们就称它为目标对象吧。 后面的参数，都传入对象，内容都会复制到目标对象中，我们就称它们为待复制对象吧。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980var toString = class2type.toString;var hasOwn = class2type.hasOwnProperty;function isPlainObject(obj) &#123; var proto, Ctor; if (!obj || toString.call(obj) !== \"[object Object]\") &#123; return false; &#125; proto = Object.getPrototypeOf(obj); if (!proto) &#123; return true; &#125; Ctor = hasOwn.call(proto, \"constructor\") &amp;&amp; proto.constructor; return ( typeof Ctor === \"function\" &amp;&amp; hasOwn.toString.call(Ctor) === hasOwn.toString.call(Object) );&#125;function extend() &#123; // 默认不进行深拷贝 var deep = false; var name, options, src, copy, clone, copyIsArray; var length = arguments.length; // 记录要复制的对象的下标 var i = 1; // 第一个参数不传布尔值的情况下，target 默认是第一个参数 var target = arguments[0] || &#123;&#125;; // 如果第一个参数是布尔值，第二个参数是 target if (typeof target == \"boolean\") &#123; deep = target; target = arguments[i] || &#123;&#125;; i++; &#125; // 如果target不是对象，我们是无法进行复制的，所以设为 &#123;&#125; if (typeof target !== \"object\" &amp;&amp; !isFunction(target)) &#123; target = &#123;&#125;; &#125; // 循环遍历要复制的对象们 for (; i &lt; length; i++) &#123; // 获取当前对象 options = arguments[i]; // 要求不能为空 避免 extend(a,,b) 这种情况 if (options != null) &#123; for (name in options) &#123; // 目标属性值 src = target[name]; // 要复制的对象的属性值 copy = options[name]; // 解决循环引用 if (target === copy) &#123; continue; &#125; // 要递归的对象必须是 plainObject 或者数组 if ( deep &amp;&amp; copy &amp;&amp; (isPlainObject(copy) || (copyIsArray = Array.isArray(copy))) ) &#123; // 要复制的对象属性值类型需要与目标属性值相同 if (copyIsArray) &#123; copyIsArray = false; clone = src &amp;&amp; Array.isArray(src) ? src : []; &#125; else &#123; clone = src &amp;&amp; isPlainObject(src) ? src : &#123;&#125;; &#125; target[name] = extend(deep, clone, copy); &#125; else if (copy !== undefined) &#123; target[name] = copy; &#125; &#125; &#125; &#125; return target;&#125; 学习资料 JavaScript 专题之深浅拷贝 JavaScript 专题之从零实现 jQuery 的 extend","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/categories/JavaScript/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://www.yangtao.site/tags/面试/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/tags/JavaScript/"}]},{"title":"JavaScript 防抖、节流","slug":"code-debounce-throttle","date":"2020-04-03T02:19:34.000Z","updated":"2020-04-03T02:29:34.877Z","comments":true,"path":"2020/04/03/code-debounce-throttle/","link":"","permalink":"https://www.yangtao.site/2020/04/03/code-debounce-throttle/","excerpt":"性能优化中对于频繁触发事件，常用的两种解决方式：debounce 和 throttle。","text":"性能优化中对于频繁触发事件，常用的两种解决方式：debounce 和 throttle。 在前端开发中会遇到一些频繁的事件触发，比如： window 的 resize、scroll mousedown、mousemove keyup、keydown 防抖防抖的原理就是： 你尽管触发事件，但是我一定在事件触发 n 秒后才执行，如果你在一个事件触发的 n 秒内又触发了这个事件，那我就以新的事件的时间为准，n 秒后才执行。 总之，就是要等你触发完事件 n 秒内不再触发事件，我才执行! 起步1234567function debounce(func, wait) &#123; var timer; return function() &#123; clearTimeout(timer); timer = setTimeout(func, wait); &#125;;&#125; this、arguments、返回值1234567891011121314function debounce(func, wait) &#123; var timer; return function() &#123; var _this = this; var args = arguments; clearTimeout(timer); timer = setTimeout(function() &#123; var result = func.apply(_this, args); &#125;, wait); return result; &#125;;&#125; 立刻执行这个需求就是： 我不希望非要等到事件停止触发后才执行，我希望立刻执行函数，然后等到停止触发 n 秒后，才可以重新触发执行。 123456789101112131415161718192021222324252627282930function debounce(func, wait, immediate) &#123; var timerId, result; return function() &#123; var _this = this; var _args = arguments; if (timerId) clearTimeout(timerId); if (immediate) &#123; // 触发 func 从队尾提到队前。记住：func同步执行，timer异步执行 // 1. callNow 初始值是 true, 同步立即执行；随后 timer 才开始执行 // 2. wait 期间，timer 是一个 ID 数字，所以 callNow 为 false，func 在此期间永远不会执行 // 3. wait 之后，timer 赋值 null，callNow 为 true，func 又开始立即执行。 // 依次循环 var callNow = !timerId; timerId = setTimeout(function() &#123; timerId = null; &#125;, wait); if (callNow) &#123; result = func.apply(_this, _args); &#125; &#125; else &#123; timerId = setTimeout(function() &#123; result = func.apply(_this, _args); &#125;, wait); &#125; return result; &#125;;&#125; 需要理解： timeId 是闭包变量，初始化时是 undefined setTimeout 返回的是定时器的 id ，一个 &gt; 0 的数字 clearTimeout 不会改变 timeId 的值 若 timeId 经历过赋值，即执行过 setTimeout ，则 !timeId 为假 取消防抖比如说我 debounce 的时间间隔是 10 秒钟，immediate 为 true，这样的话，我只有等 10 秒后才能重新触发事件，现在我希望有一个按钮，点击后，取消防抖，这样我再去触发，就可以又立刻执行啦。 123456789101112131415161718192021222324252627282930function debounce(func, wait, immediate) &#123; var timerId, result; var debounced = function() &#123; var _this = this; var _args = arguments; if (timerId) clearTimeout(timerId); if (immediate) &#123; var callNow = !timerId; timerId = setTimeout(function() &#123; timerId = null; &#125;, wait); if (callNow) &#123; result = func.apply(_this, _args); &#125; &#125; else &#123; timerId = setTimeout(function() &#123; result = func.apply(_this, _args); &#125;, wait); &#125; return result; &#125;; debounced.cancel = function() &#123; clearTimeout(timerId); timerId = null; &#125;; return debounced;&#125; 用法： 12345var setUseAction = debounce(getUserAction, 10000, true);container.onmousemove = setUseAction;button.addEventListener(\"click\", function() &#123; setUseAction.cancel();&#125;); 节流节流的原理很简单：如果你持续触发事件，每隔一段时间，只执行一次事件。 根据首次是否执行以及结束后是否执行，效果有所不同，实现的方式也有所不同。我们用 leading 代表首次是否执行，trailing 代表结束后是否再执行一次。 关于节流的实现，有两种主流的实现方式，一种是使用时间戳，一种是设置定时器。 时间戳当触发事件的时候，我们取出当前的时间戳，然后减去之前的时间戳(最一开始值设为 0 )，如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，如果小于，就不执行。 12345678910111213function throttle(func, wait) &#123; var context, args; var previous = 0; return function() &#123; var now = +new Date(); context = this; args = arguments; if (now - previous &gt; wait) &#123; func.apply(context, args); previous = now; &#125; &#125;;&#125; 定时器当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，直到定时器执行，然后执行函数，清空定时器，这样就可以设置下个定时器。 12345678910111213function throttle(func, wait) &#123; var context, args, timeout; return function() &#123; context = this; args = arguments; if (!timeout) &#123; timeout = setTimeout(function() &#123; timeout = null; func.apply(context, args); &#125;, wait); &#125; &#125;;&#125; 所以比较两个方法： 第一种事件会立刻执行，第二种事件会在 n 秒后第一次执行 第一种事件停止触发后没有办法再执行事件，第二种事件停止触发后依然会再执行一次事件 双剑合璧鼠标移入能立刻执行，停止触发的时候还能再执行一次！ 12345678910111213141516171819202122232425262728293031function throttle(func, wait) &#123; var context, args, timeout, result; var previous = 0; var later = function() &#123; previous = +new Date(); timeout = null; result = func.apply(context, args); &#125;; var throttled = function() &#123; var now = +new Date(); var remaining = wait - (now - previous); context = this; args = arguments; if (remaining &lt;= 0 || remaining &gt; wait) &#123; if (timeout) &#123; clearTimeout(timeout); timeout = null; &#125; result = func.apply(context, args); previous = now; &#125; else if (!timeout) &#123; timeout = setTimeout(later, remaining); &#125; return result; &#125;; return throttled;&#125; 优化设置个 options 作为第三个参数，然后根据传的值判断到底哪种效果，我们约定: leading：false 表示禁用第一次执行 trailing: false 表示禁用停止触发的回调 123456789101112131415161718192021222324252627282930313233343536373839404142434445function throttle(func, wait, options) &#123; var context, args, timeout, result; var previous = 0; if (!options) &#123; options = &#123;&#125;; &#125; var later = function() &#123; previous = options.leading ? 0 : new Date().getTime(); timeout = null; result = func.apply(context, args); &#125;; var throttled = function() &#123; var now = new Date().getTime(); if (!previous &amp;&amp; options.leading === false) &#123; previous = now; &#125; var remaining = wait - (now - previous); context = this; args = arguments; if (remaining &lt;= 0 || remaining &gt; wait) &#123; if (timeout) &#123; clearTimeout(timeout); timeout = null; &#125; result = func.apply(context, args); previous = now; &#125; else if (!timeout &amp;&amp; options.trailing !== false) &#123; timeout = setTimeout(later, remaining); &#125; return result; &#125;; // 取消 throttled.cancel = function() &#123; clearTimeout(timeout); previous = 0; timeout = null; &#125;; return throttled;&#125; 注意：就是 leading：false 和 trailing: false 不能同时设置。 学习资料 JavaScript 专题之跟着 underscore 学防抖 JavaScript 专题之跟着 underscore 学节流","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/categories/JavaScript/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://www.yangtao.site/tags/面试/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/tags/JavaScript/"}]},{"title":"关于 Array 方法的用法及 Polyfill","slug":"handwriting-array","date":"2020-04-01T09:49:51.000Z","updated":"2020-04-01T14:30:41.941Z","comments":true,"path":"2020/04/01/handwriting-array/","link":"","permalink":"https://www.yangtao.site/2020/04/01/handwriting-array/","excerpt":"主要有：isArray reduce flat forEach some every filter map 等 Array 方法。","text":"主要有：isArray reduce flat forEach some every filter map 等 Array 方法。 map, filter, reduce 各自有什么作用map 的作用是生成一个新数组，遍历原数组，将每个元素拿出来做一些变换然后放入到新的数组中。 1[1, 2, 3].map(v =&gt; v + 1) // -&gt; [2, 3, 4] 另外 map 的回调函数接受三个参数，分别是当前索引元素，索引，原数组 1['1','2','3'].map(parseInt) 第一轮遍历 parseInt(&#39;1&#39;, 0) -&gt; 1 第二轮遍历 parseInt(&#39;2&#39;, 1) -&gt; NaN 第三轮遍历 parseInt(&#39;3&#39;, 2) -&gt; NaN filter 的作用也是生成一个新数组，在遍历数组的时候将返回值为 true 的元素放入新数组，我们可以利用这个函数删除一些不需要的元素 123let array = [1, 2, 4, 6]let newArray = array.filter(item =&gt; item !== 6)console.log(newArray) // [1, 2, 4] 和 map 一样，filter 的回调函数也接受三个参数，用处也相同。 reduce 可以将数组中的元素通过回调函数最终转换为一个值。 对于 reduce 来说，它接受两个参数，分别是回调函数和初始值。 回调函数接受四个参数，分别为累计值、当前元素、当前索引、原数组。 接下来我们就通过 reduce 来实现 map 函数： 1234567const arr = [1, 2, 3]const mapArray = arr.map(value =&gt; value * 2)const reduceArray = arr.reduce((acc, current) =&gt; &#123; acc.push(current * 2) return acc&#125;, [])console.log(mapArray, reduceArray) // [2, 4, 6] Array.isArray 实现可以通过 toString() 来获取每个对象的类型。为了每个对象都能通过 Object.prototype.toString() 来检测，需要以 Function.prototype.call() 或者 Function.prototype.apply() 的形式来调用，传递要检查的对象作为第一个参数。 1234Array.myIsArray = function(o) &#123; return Object.prototype.toString.call(o) === \"[object Array]\";&#125;;console.log(Array.myIsArray([])); // true Array.prototype.reduce 实现reduce() 方法对数组中的每个元素执行一个由您提供的reducer函数(升序执行)，将其结果汇总为单个返回值。由 reduce 返回的值将是最后一次回调返回值。语法： 1arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue]) callback accumulator 累计器 currentValue 当前值 currentIndex 当前索引，可选 array 数组，可选 initialValue 可选，作为第一次调用 callback 函数时的第一个参数的值。 如果没有提供初始值，则将使用数组中的第一个元素。 栗子求数组之和： 12const array1 = [1, 2, 3, 4];let result = array1.reduce((prev, curr) =&gt; prev + curr); //10 数组去重： 12345678let arr = [1, 2, 1, 2, 3, 5, 4, 5, 3, 4, 4, 4, 4];let result = arr.sort().reduce((init, current) =&gt; &#123; if (init.length === 0 || init[init.length - 1] !== current) &#123; init.push(current); &#125; return init;&#125;, []);console.log(result); //[1,2,3,4,5] 按顺序运行 Promise： 123456789101112131415function runPromiseInSequence(arr, input) &#123; return arr.reduce( (promiseChain, currentFunction) =&gt; promiseChain.then(currentFunction), Promise.resolve(input) );&#125;// p1, p2, f3, p4 is promise function or normal functionfunction p1(a) &#123; return new Promise((resolve, reject) =&gt; &#123; resolve(a * 5); &#125;);&#125;const promiseArr = [p1, p2, f3, p4];runPromiseInSequence(promiseArr, 10).then(console.log); 功能型函数管道： 12345678910111213141516171819202122// Building-blocks to use for compositionconst double = x =&gt; x + x;const triple = x =&gt; 3 * x;// Function composition enabling pipe functionalityconst pipe = (...functions) =&gt; input =&gt; functions.reduce((acc, fn) =&gt; fn(acc), input);// 这里其实就是const pipe = function(...functions) &#123; return function(input) &#123; return functions.reduce(function(acc, fn) &#123; return fn(acc); &#125;, input); &#125;;&#125;;// Composed functions for multiplication of specific valuesconst multiply6 = pipe(double, triple);// Usagemultiply6(6); // 36 模拟实现第一版： 1234567891011Array.prototype.myreduce = function(callback, initialValue) &#123; // 判断第一次调用 callback 函数时的第一个参数的值。 // 如果没有提供初始值，则将使用数组中的第一个元素。 const _this = this; let accumulator = initialValue ? initialValue : this[0]; for (let i = initialValue ? 0 : 1; i &lt; this.length; i++) &#123; accumulator = callback(accumulator, this[i], i, _this); &#125; return accumulator;&#125;; 第二版： 1234567891011121314151617181920212223242526272829303132333435363738Array.prototype.myreduce = function reduce(callbackfn) &#123; const O = this; // 保存原数组 const len = O.length &gt;&gt;&gt; 0; // typeof ('1' &gt;&gt;&gt; 0) -&gt; number let k = 0, // 下标值初始化 accumulator = undefined, // 累加器初始化 kPresent = false, // k下标对应的值是否存在 initialValue = arguments.length &gt; 1 ? arguments[1] : undefined; // 初始值 if (typeof callbackfn !== \"function\") &#123; thrownewTypeError(callbackfn + \" is not a function\"); &#125; // 数组为空，并且有初始值，报错 if (len === 0 &amp;&amp; arguments.length &lt; 2) &#123; thrownewTypeError(\"Reduce of empty array with no initial value\"); &#125; // 如果初始值存在，累加器为初始值，否则使用数组中的第一个元素 if (arguments.length &gt; 1) &#123; accumulator = initialValue; &#125; else &#123; accumulator = O[k++]; &#125; while (k &lt; len) &#123; // 判断是否为 empty [,,,] kPresent = O.hasOwnProperty(k); if (kPresent) &#123; const kValue = O[k]; // 当前值 // 调用 callbackfn accumulator = callbackfn(accumulator, kValue, k, O); &#125; k++; &#125; return accumulator;&#125;; Array.prototype.flat 实现flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。 123456var newArray = arr.flat([depth]);// depth 可选// 指定要提取嵌套数组的结构深度，默认值为 1// 返回值// 一个包含将数组与子数组中所有元素的新数组。 例子： 12345678910111213141516var arr = [1, 2, [3, 4]];// 展开一层数组arr.flat();// 等效于arr.reduce((acc, val) =&gt; acc.concat(val), []);// [1, 2, 3, 4]// 使用扩展运算符 ...const flattened = arr =&gt; [].concat(...arr);// 展开两层数组arr.flat(2);// 使用 Infinity，可展开任意深度的嵌套数组arr.flat(Infinity); 使用 reduce、concat 和递归展开无限多层嵌套的数组： 123456789function flatDeep(arr, d = 1) &#123; return d &gt; 0 ? arr.reduce( (acc, val) =&gt; acc.concat(Array.isArray(val) ? flatDeep(val, d - 1) : val), [] ) : arr.slice();&#125; forEach： 12345678910111213141516171819202122// forEach 遍历数组会自动跳过空元素const eachFlat = (arr = [], depth = 1) =&gt; &#123; const result = []; // 缓存递归结果 // 开始递归 (function flat(arr, depth) &#123; // forEach 会自动去除数组空位 arr.forEach(item =&gt; &#123; // 控制递归深度 if (Array.isArray(item) &amp;&amp; depth &gt; 0) &#123; // 递归数组 flat(item, depth - 1); &#125; else &#123; // 缓存元素 result.push(item); &#125; &#125;); &#125;)(arr, depth); // 返回递归结果 return result;&#125;;eachFlat([1, 2, [3, [4, [5]]]], Infinity); //[1, 2, 3, 4, 5] for…of： 123456789101112131415// for of 循环不能去除数组空位，需要手动去除const forFlat = (arr = [], depth = 1) =&gt; &#123; const result = []; (function flat(arr, depth) &#123; for (let item of arr) &#123; if (Array.isArray(item) &amp;&amp; depth &gt; 0) &#123; flat(item, depth - 1); &#125; else &#123; // 去除空元素，添加非undefined元素 item !== void 0 &amp;&amp; result.push(item); &#125; &#125; &#125;)(arr, depth); return result;&#125;; 其他方法见MDN。 Array.prototype.forEach 实现forEach() 方法对数组的每个元素执行一次给定的函数。语法： 1arr.forEach(callback(currentValue [, index [, array]])[, thisArg]) forEach() 为每个数组元素执行一次 callback 函数；与 map() 或者 reduce() 不同的是，它总是返回 undefined 值，并且不可链式调用。 例子：对象复制器函数 12345678910111213141516function copy(obj) &#123; const copy = Object.create(Object.getPrototypeOf(obj)); // propNames is [\"a\", \"b\"] const propNames = Object.getOwnPropertyNames(obj); propNames.forEach(function(name) &#123; // desc is &#123;value: 1, writable: true, enumerable: true, configurable: true&#125; const desc = Object.getOwnPropertyDescriptor(obj, name); Object.defineProperty(copy, name, desc); &#125;); return copy;&#125;const obj1 = &#123; a: 1, b: 2 &#125;;const obj2 = copy(obj1); // 现在 obj2 看起来和 obj1 一模一样了 模拟实现： 12345678910111213141516171819202122232425262728Array.prototype.myforEach = function(callback, thisArg) &#123; var k, T; if (this == null) &#123; throw new TypeError(\" this is null or not defined\"); &#125; var O = Object(this); var len = O.length &gt;&gt;&gt; 0; if (typeof callback !== \"function\") &#123; throw new TypeError(callback + \" is not a function\"); &#125; if (arguments.length &gt; 1) &#123; T = thisArg; &#125; k = 0; while (k &lt; len) &#123; var kValue; // 已删除或者未初始化的项将被跳过 if (k in O) &#123; kValue = O[k]; callback.call(T, kValue, k, O); &#125; k++; &#125;&#125;; Array.prototype.every 实现every() 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。 12345678910111213141516171819202122232425262728293031323334if (!Array.prototype.every) &#123; Array.prototype.every = function(callbackfn, thisArg) &#123; \"use strict\"; var T, k; if (this == null) &#123; throw new TypeError(\"this is null or not defined\"); &#125; var O = Object(this); var len = O.length &gt;&gt;&gt; 0; if (typeof callbackfn !== \"function\") &#123; throw new TypeError(); &#125; if (arguments.length &gt; 1) &#123; T = thisArg; &#125; k = 0; while (k &lt; len) &#123; var kValue; if (k in O) &#123; kValue = O[k]; var testResult = callbackfn.call(T, kValue, k, O); if (!testResult) &#123; return false; &#125; &#125; k++; &#125; return true; &#125;;&#125; Array.prototype.some 实现some() 方法测试数组中是不是至少有 1 个元素通过了被提供的函数测试。它返回的是一个 Boolean 类型的值。 12345678910111213141516171819202122232425if (!Array.prototype.some) &#123; Array.prototype.some = function(fun /*, thisArg*/) &#123; \"use strict\"; if (this == null) &#123; throw new TypeError(\"Array.prototype.some called on null or undefined\"); &#125; if (typeof fun !== \"function\") &#123; throw new TypeError(); &#125; var t = Object(this); var len = t.length &gt;&gt;&gt; 0; var thisArg = arguments.length &gt;= 2 ? arguments[1] : void 0; for (var i = 0; i &lt; len; i++) &#123; if (i in t &amp;&amp; fun.call(thisArg, t[i], i, t)) &#123; return true; &#125; &#125; return false; &#125;;&#125; Array.prototype.map 实现map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。 map 方法会给原数组中的每个元素都按顺序调用一次 callback 函数。callback 每次执行后的返回值（包括 undefined）组合起来形成一个新数组。 用法： 1234[\"1\", \"2\", \"3\"].map(parseInt); // [1, NaN, NaN]// parseInt(string, radix) -&gt; map(parseInt(value, index))[\"1\", \"2\", \"3\"].map(str =&gt; parseInt(str)); // [1, 2, 3] Plyfill: 12345678910111213141516171819202122232425262728293031323334if (!Array.prototype.map) &#123; Array.prototype.map = function(callback /*, thisArg*/) &#123; var T, A, k; if (this == null) &#123; throw new TypeError(\"this is null or not defined\"); &#125; var O = Object(this); var len = O.length &gt;&gt;&gt; 0; if (typeof callback !== \"function\") &#123; throw new TypeError(callback + \" is not a function\"); &#125; if (arguments.length &gt; 1) &#123; T = arguments[1]; &#125; A = new Array(len); k = 0; while (k &lt; len) &#123; var kValue, mappedValue; if (k in O) &#123; kValue = O[k]; mappedValue = callback.call(T, kValue, k, O); A[k] = mappedValue; &#125; k++; &#125; return A; &#125;;&#125; Array.prototype.filter 实现filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。 filter 为数组中的每个元素调用一次 callback 函数，并利用所有使得 callback 返回 true 或等价于 true 的值的元素创建一个新数组。 用法： 12345678910const fruits = [\"apple\", \"banana\", \"grapes\", \"mango\", \"orange\"];const filterItems = query =&gt; &#123; return fruits.filter( el =&gt; el.toLowerCase().indexOf(query.toLowerCase()) &gt; -1 );&#125;;console.log(filterItems(\"ap\")); // ['apple', 'grapes']console.log(filterItems(\"an\")); // ['banana', 'mango', 'orange'] Polyfill: 1234567891011121314151617181920212223242526272829if (!Array.prototype.filter) &#123; Array.prototype.filter = function(func /*, thisArg*/) &#123; \"use strict\"; if (!((typeof func === \"Function\" || typeof func === \"function\") &amp;&amp; this)) throw new TypeError(); var len = this.length &gt;&gt;&gt; 0, res = new Array(len), // preallocate array t = this, c = 0, i = -1, T; if (arguments.length &gt; 1) &#123; T = arguments[1]; &#125; while (++i !== len) &#123; if (i in this) &#123; if (func.call(T, t[i], i, t)) &#123; res[c++] = t[i]; &#125; &#125; &#125; res.length = c; // shrink down array to proper size return res; &#125;;&#125; Array 迭代方法 Array.prototype.forEach()为数组中的每个元素执行一次回调函数。 Array.prototype.entries()返回一个数组迭代器对象，该迭代器会包含所有数组元素的键值对。 Array.prototype.every()如果数组中的每个元素都满足测试函数，则返回 true，否则返回 false。 Array.prototype.some()如果数组中至少有一个元素满足测试函数，则返回 true，否则返回 false。 Array.prototype.filter()将所有在过滤函数中返回 true 的数组元素放进一个新数组中并返回。 Array.prototype.find()找到第一个满足测试函数的元素并返回那个元素的值，如果找不到，则返回 undefined。 Array.prototype.findIndex()找到第一个满足测试函数的元素并返回那个元素的索引，如果找不到，则返回 -1。 Array.prototype.keys()返回一个数组迭代器对象，该迭代器会包含所有数组元素的键。 Array.prototype.map()返回一个由回调函数的返回值组成的新数组。 Array.prototype.reduce()从左到右为每个数组元素执行一次回调函数，并把上次回调函数的返回值放在一个暂存器中传给下次回调函数，并返回最后一次回调函数的返回值。 Array.prototype.reduceRight()从右到左为每个数组元素执行一次回调函数，并把上次回调函数的返回值放在一个暂存器中传给下次回调函数，并返回最后一次回调函数的返回值。 Array.prototype.values()返回一个数组迭代器对象，该迭代器会包含所有数组元素的值。 Array.prototype[@@iterator]()和上面的 values() 方法是同一个函数。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/tags/JavaScript/"},{"name":"手写系列","slug":"手写系列","permalink":"https://www.yangtao.site/tags/手写系列/"}]},{"title":"手写系列之 new、instanceof、class、typeAPI","slug":"handwriting-class","date":"2020-03-30T10:20:19.000Z","updated":"2020-04-01T11:42:00.302Z","comments":true,"path":"2020/03/30/handwriting-class/","link":"","permalink":"https://www.yangtao.site/2020/03/30/handwriting-class/","excerpt":"主要有：new、Object.create()、Object.setPrototypeOf()、instanceof、class、type API、原型链继承等。","text":"主要有：new、Object.create()、Object.setPrototypeOf()、instanceof、class、type API、原型链继承等。 new 实现我们看下 new 做了什么： 创建一个新对象； 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象） 执行构造函数中的代码（为这个新对象添加属性） 返回新对象。 123456789101112131415161718function objectFactory() &#123; // 1. 新建一个对象 obj const obj = new Object(); // 2. 取出第一个参数，就是我们要传入的构造函数 Constructor。 // 此外因为 shift 会修改原数组，所以 arguments 会被去除第一个参数 const Constructor = [].shift.call(arguments); // 3. 将 obj 的原型指向构造函数，这样 obj 就可以访问到构造函数原型中的属性 obj.__proto__ = Constructor.prototype; // 4. 使用 apply，改变构造函数 this 的指向到新建的对象，这样 obj 就可以访问到构造函数中的属性 // 如果构造函数返回值是对象则返回这个对象，如果不是对象则返回新的实例对象 const ret = Constructor.apply(obj, arguments); // 5. 返回 obj return typeof ret === \"object\" ? ret : obj;&#125; ES6： 123456789function createNew(Con, ...args) &#123; this.obj = &#123;&#125;; this.obj = Object.create(Con.prototype); // Object.setPrototypeOf(this.obj, Con.prototype); const ret = Con.apply(this.obj, args); return ret instanceof Object ? ret : this.obj;&#125; Object.create 实现Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。 使用 Object.create123456789101112131415161718192021222324252627282930313233343536var o;// 创建原型为 null 的空对象o = Object.create(null);o = &#123;&#125;;// 以字面量方式创建的空对象就相当于：o = Object.create(Object.prototype);function Constructor() &#123;&#125;o = new Constructor();// 上面的一句就相当于:o = Object.create(Constructor.prototype);// 相当于Object.setPrototypeOf(o, Constructor.prototype);// 再相当于o.__proto__ === Constructor.prototype);// 哇哦，完美o = Object.create(Object.prototype, &#123; // foo会成为所创建对象的数据属性 foo: &#123; writable: true, configurable: true, value: \"hello\" &#125;, // bar会成为所创建对象的访问器属性 bar: &#123; configurable: false, get: function() &#123; return 10; &#125;, set: function(value) &#123; console.log(\"Setting `o.bar` to\", value); &#125; &#125;&#125;); 模拟 Object.create 实现原理采用了原型式继承：将传入的对象作为创建的对象的原型。 12345Object.mycreate = function(proto) &#123; function F() &#123;&#125; F.prototype = proto; return new F();&#125;; 详细 Polyfill，见 MDN：Object.create()，其实就多了参数的判断等信息。 Object.setPrototypeOf 实现Object.setPrototypeOf() 方法设置一个指定的对象的原型 ( 即, 内部[[Prototype]]属性）到另一个对象或 null。 注意：由于性能问题，你应该使用 Object.create() 来创建带有你想要的[[Prototype]]的新对象。详情见：MDN。 使用较旧的 Object.prototype.__proto__ 属性，我们可以很容易地定义 setPrototypeOf： 1234567// 仅适用于Chrome和FireFox，在IE中不工作：Object.setPrototypeOf = Object.setPrototypeOf || function(obj, proto) &#123; obj.__proto__ = proto; return obj; &#125;; instanceof 实现用法：instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。 原理：其实就是沿着原型链一直询问，直到__proto__为 null为止。 注意：Object.prototype.isPrototypeOf()用于测试一个对象是否存在于另一个对象的原型链上。isPrototypeOf() 与 instanceof 运算符不同。在表达式 “object instanceof AFunction“中，object 的原型链是针对 AFunction.prototype 进行检查的，而不是针对 AFunction 本身。 如果你有段代码只在需要操作继承自一个特定的原型链的对象的情况下执行，同 instanceof 操作符一样 isPrototypeOf() 方法就会派上用场: 1234567891011function Car() &#123;&#125;var mycar = new Car();// 注意下面 instanceof 和 isPrototypeOf() 之间的区别：// instanceof 中的 mycar 原型链是针对 Car.prototype，而不是 Car 本身var a = mycar instanceof Car; // 返回 truevar b = mycar instanceof Object; // 返回 true// isPrototypeOf() 也是 Car.prototype，不过是显式的，注意这点小小区别var aa = Car.prototype.isPrototypeOf(mycar); // truevar bb = Object.prototype.isPrototypeOf(mycar); // true 要检测对象不是某个构造函数的实例时，你可以这样做: 123456if (!(mycar instanceof Car)) &#123; // Do something&#125;if (!Car.prototype.isPrototypeOf(mycar)) &#123; // Do something&#125; instanceof 模拟实现：主要是沿着__proto__判断：L.__proto__是否等于R.prototype： 123456789101112function myinstanceof(L, R) &#123; const O = R.prototype; L = L.__proto__; while (true) &#123; if (L === null) return false; if (O === L) return true; L = L.__proto__; &#125;&#125;var a = myinstanceof(mycar, Car); // 返回 truevar b = myinstanceof(mycar, Object); // 返回 true 原型链继承实现用法12345678910111213141516171819function Parent(name) &#123; this.name = name;&#125;Parent.prototype.getName = function() &#123; return this.name;&#125;;function Child(name, age) &#123; Parent.call(this, name); this.age = age;&#125;Child.prototype = Object.create(Parent.prototype);Child.prototype.constructor = Child;Child.prototype.getMsg = function() &#123; return `My name is $&#123;this.name&#125;, $&#123;this.age&#125; years old.`;&#125;; ES6: 123456789101112131415161718class Parent &#123; constructor(name) &#123; this.name = name; &#125; getName() &#123; return this.name; &#125;&#125;class Child extends Parent &#123; constructor(name, age) &#123; super(name); this.age = age; &#125; getMsg() &#123; return `My name is $&#123;this.name&#125;, $&#123;this.age&#125; years old.`; &#125;&#125; 封装继承方法第一版： 123456function prototype(child, parent) &#123; const F = function() &#123;&#125;; F.prototype = parent.prototype; child.prototype = new F(); child.prototype.constructor = child;&#125; 第二版： 12345678910function create(o) &#123; const F = function() &#123;&#125;; F.prototype = o; return new F();&#125;function prototype(child, parent) &#123; child.prototype = create(parent.prototype); child.prototype.constructor = child;&#125; 第三版： 1234function prototype(child, parent) &#123; child.prototype = Object.create(parent.prototype); child.prototype.constructor = child;&#125; 使用到的几种继承方式组合式继承：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。组合继承最大的缺点是会调用两次父构造函数。 原型式继承：Object.create 的模拟实现，将传入的对象作为创建的对象的原型。 寄生组合式继承：只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。 PS：其他几种继承方式见这里JavaScript 深入之继承的多种方式和优缺点。 引用《JavaScript 高级程序设计》中对寄生组合式继承的夸赞就是： 这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。 class 实现主要是模拟使用extends，并模拟super可以给其父构造函数传值，如 Parent 中的 opt： 1234567891011121314151617181920class Parent &#123; constructor(opt) &#123; this.name = opt.name; &#125; getName() &#123; return this.name; &#125;&#125;class Child extends Parent &#123; constructor(opt) &#123; super(opt); this.age = opt.age; &#125; getAge() &#123; return this.age + \" years old.\"; &#125;;&#125;const me = new Child(&#123; name: \"Yang\", age: 28 &#125;); 开始模拟实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function _extends(child, parent) &#123; child.prototype = Object.create(parent &amp;&amp; parent.prototype); child.prototype.constructor = child; Object.setPrototypeOf ? Object.setPrototypeOf(child, parent) : (child.__proto__ = parent);&#125;function _classCallCheck(instance, Constructor) &#123; if (!(instance instanceof Constructor)) &#123; throw new TypeError(\"Cannot call a class as a function\"); &#125;&#125;var Parent = (function() &#123; function Parent(opt) &#123; _classCallCheck(this, Parent); this.name = opt.name; &#125; Parent.prototype.getName = function getName() &#123; return this.name; &#125;; return Parent;&#125;)();var Child = (function(_Parent) &#123; _extends(Child, _Parent); function Child(opt) &#123; _classCallCheck(this, Child); // Constrctor =&gt; _Parent.call(this, opt) var _this = (_Parent != null &amp;&amp; _Parent.call(this, opt)) || this; _this.age = opt.age; return _this; &#125; Child.prototype.getAge = function getAge() &#123; return this.age + \" years old.\"; &#125;; return Child;&#125;)(Parent);const myself = new Child(&#123; name: \"YyY\", age: 18 &#125;); 附加两篇文章： ES6 系列之 Babel 是如何编译 Class 的(上) ES6 系列之 Babel 是如何编译 Class 的(下) Array.isArray 实现可以通过 toString() 来获取每个对象的类型。为了每个对象都能通过 Object.prototype.toString() 来检测，需要以 Function.prototype.call() 或者 Function.prototype.apply() 的形式来调用，传递要检查的对象作为第一个参数。 1234Array.myIsArray = function(o) &#123; return Object.prototype.toString.call(o) === \"[object Array]\";&#125;;console.log(Array.myIsArray([])); // true type API 实现写一个 type 函数能检测各种类型的值，如果是基本类型，就使用 typeof，引用类型就使用 toString。 此外鉴于 typeof 的结果是小写，我也希望所有的结果都是小写。 123456789101112131415161718192021222324252627var class2type = &#123;&#125;;\"Boolean Number String Function Array Date RegExp Object Error Null Undefined Symbol Set Map BigInt\" .split(\" \") .map(function(item) &#123; // 格式如：\"[object Array]\": \"array\" class2type[\"[object \" + item + \"]\"] = item.toLowerCase(); &#125;);function type(obj) &#123; if (obj == null) &#123; return obj + \"\"; // IE6 &#125; return typeof obj === \"object\" || typeof obj === \"function\" ? class2type[Object.prototype.toString.call(obj)] : typeof obj;&#125;function isFunction(obj) &#123; return type(obj) === \"function\";&#125;var isArray = Array.isArray || function(obj) &#123; return type(obj) === \"array\"; &#125;; 参考资料：JavaScript 专题之类型判断(上) 参考资料 各种手写源码实现 JavaScript 中各种源码实现（前端面试笔试必备） JavaScript 深入之 new 的模拟实现 JavaScript 深入之类数组对象与 arguments","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/tags/JavaScript/"},{"name":"手写系列","slug":"手写系列","permalink":"https://www.yangtao.site/tags/手写系列/"}]},{"title":"手写系列之 bind、call、apply","slug":"handwriting-call-apply-bind","date":"2020-03-29T07:50:44.000Z","updated":"2020-03-29T07:59:31.611Z","comments":true,"path":"2020/03/29/handwriting-call-apply-bind/","link":"","permalink":"https://www.yangtao.site/2020/03/29/handwriting-call-apply-bind/","excerpt":"bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。(来自于 MDN )","text":"bind() 方法会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。(来自于 MDN ) bind 实现我们可以首先得出 bind 函数的两个特点： 返回一个函数 可以传入参数 如： 123456789101112var foo = &#123; value: 1&#125;;function bar(name, age) &#123; console.log(this.value); console.log(name); console.log(age);&#125;var bindFoo = bar.bind(foo, \"yyy\");bindFoo(\"28\"); 第一步：返回一个函数 123456Function.prototype.mybind1 = function(context) &#123; const self = this; return function() &#123; return self.apply(context); &#125;;&#125;; 第二步：可以传参，并且可以这样：函数需要传 name 和 age 两个参数，可以在 bind 的时候，只传一个 name，在执行返回的函数的时候，再传另一个参数 age! 1234567891011Function.prototype.mybind2 = function(context) &#123; const self = this; // 截取参数，如： // context = [].shift.call(arguments) // args = [].slice.call(arguments) const args = Array.prototype.slice.call(arguments, 1); return function() &#123; const bindArgs = Array.prototype.slice.call(arguments); return self.apply(context, args.concat(bindArgs)); &#125;;&#125;; 第三步：当 bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，但传入的参数依然生效。 123456789101112131415161718192021222324Function.prototype.mybind3 = function(context) &#123; const self = this; const args = Array.prototype.slice.call(arguments, 1); // 通过一个空函数来进行中转 const fNOP = function() &#123;&#125;; const fBound = function() &#123; const bindArgs = Array.prototype.slice.call(arguments); // this 指向 实例，说明是构造函数，需要将绑定函数的 this 指向该实例， // 可以让实例获得来自绑定函数的值 // this 指向 window，说明使普通函数调用，将绑定函数的 this 指向 context return self.apply( this instanceof fNOP ? this : context, args.concat(bindArgs) ); &#125;; fNOP.prototype = this.prototype; // 让实例继承绑定函数的原型(this.prototype)中的值 fBound.prototype = new fNOP(); return fBound;&#125;; 最终版： 12345678910111213141516171819202122Function.prototype.mybind = function(context) &#123; if (typeof this !== \"function\") &#123; throw new Error( \"Function.prototype.bind - what is trying to be bound is not callable\" ); &#125; const self = this; const args = Array.prototype.slice.call(arguments, 1); const fNOP = function() &#123;&#125;; const fBound = function() &#123; const bindArgs = Array.prototype.slice.call(arguments); return self.apply( this instanceof fNOP ? this : context, args.concat(bindArgs) ); &#125;; fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound;&#125;; call 实现我们模拟的步骤可以分为： 将函数设为对象的属性 执行该函数 删除该函数 12345678910111213141516171819202122232425262728293031323334353637Function.prototype.myCall = function(context) &#123; if (typeof this !== \"function\") &#123; throw new Error(`$&#123;this&#125; is not a function.`); &#125; if (typeof context != \"object\") &#123; throw new Error(\"Arguments error\"); &#125; var args = []; var result; context = context || window; // 如果本身存在 fn 属性，先保存，使用完毕，后恢复 if (\"fn\" in context &amp;&amp; context.hasOwnProperty(\"fn\")) &#123; var fn = context.fn; var fnFlag = true; &#125; // 1. 将函数设为对象的属性 context.fn = this; for (var i = 1, l = arguments.length; i &lt; l; i++) &#123; // args = [\"arguments[1]\", \"arguments[2]\"] args.push(\"arguments[\" + i + \"]\"); &#125; // 2. 执行该函数 result = eval(\"context.fn(\" + args + \")\"); if (fnFlag) &#123; // 恢复 context.fn = fn; &#125; else &#123; // 3. 删除该函数 delete context.fn; &#125; return result;&#125;; ES6: 1234567891011121314Function.prototype.myCall = function(context) &#123; if (typeof this !== \"function\") &#123; throw new Error(`$&#123;this&#125; is not a function.`); &#125; const args = [...arguments].slice(1); context = context || window; // 1. 将函数设为对象的属性 context.fn = this; // 2. 执行该函数 const result = context.fn(...args); // 3. 删除该函数 delete context.fn; return result;&#125;; apply 实现1234567891011121314151617181920Function.prototype.myapply = function(context, arr) &#123; if (typeof this !== \"function\") &#123; throw new Error(`$&#123;this&#125; is not a function.`); &#125; context = context || window; context.fn = this; let result; if (!arr) &#123; result = context.fn(); &#125; else &#123; let args = []; for (var i = 0, l = arr.length; i &lt; l; i++) &#123; args.push(\"arr[\" + i + \"]\"); &#125; result = eval(\"context.fn(\" + args + \")\"); &#125; delete context.fn; return result;&#125;; ES6: 12345678910111213141516171819Function.prototype.myapply = function(context) &#123; if (typeof this !== \"function\") &#123; throw new Error(`$&#123;this&#125; is not a function.`); &#125; context = context || window; context.fn = this; const args = arguments[1]; let result; if (!args) &#123; result = context.fn(); &#125; else &#123; result = context.fn(...args); &#125; delete context.fn; return result;&#125;; 参考资料 各种手写源码实现 JavaScript 中各种源码实现（前端面试笔试必备） JavaScript 深入之 call 和 apply 的模拟实现 JavaScript 深入之 bind 的模拟实现","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/tags/JavaScript/"},{"name":"手写系列","slug":"手写系列","permalink":"https://www.yangtao.site/tags/手写系列/"}]},{"title":"浏览器是怎么缓存资源的","slug":"web-cache","date":"2020-03-27T12:24:41.000Z","updated":"2020-03-27T12:29:14.430Z","comments":true,"path":"2020/03/27/web-cache/","link":"","permalink":"https://www.yangtao.site/2020/03/27/web-cache/","excerpt":"对浏览器的缓存机制来做个简要的总结：首先通过 Cache-Control 验证强缓存是否可用；如果强缓存可用，直接使用；否则进入协商缓存，即发送 HTTP 请求，服务器通过请求头中的If-Modified-Since或者If-None-Match这些条件请求字段检查资源是否更新。若资源更新，返回资源和200 状态码；否则，返回304，告诉浏览器直接从缓存获取资源","text":"对浏览器的缓存机制来做个简要的总结：首先通过 Cache-Control 验证强缓存是否可用；如果强缓存可用，直接使用；否则进入协商缓存，即发送 HTTP 请求，服务器通过请求头中的If-Modified-Since或者If-None-Match这些条件请求字段检查资源是否更新。若资源更新，返回资源和200 状态码；否则，返回304，告诉浏览器直接从缓存获取资源 前言浏览器缓存（Brower Caching）是浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档。这样做的好处有：减少冗余数据传输、减少服务器负担、加快客户端加载网页的速度。 浏览器的缓存规则分为两大块：强制缓存和协商缓存。对于某个文件来说，具体是采用哪种缓存方式，由 HTTP Response Headers 设置，当然也可以通过 meta 标签，但是现在越来越多浏览器忽略设置缓存的 meta 标签，所以还是推荐通过 HTTP Response Headers 设置。 强制缓存首先客户端会检查本地缓存中是否有所要请求的数据，如果有，就直接从缓存中获取数据；如果没有，就从服务器获取数据。 HTTP Response Headers 中 Cache-Control 和 Expires 字段都表示对本资源启动强制缓存，其中 Cache-Control 是 http1.1 标准中的字段，而 Expires 是 http1.0 的字段，Cache-Control 优先级更高，使用更广泛。 ExpiresExpires 即过期时间，存在于服务端返回的响应头中，告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求，如： 1Expires: Wed, 22 Nov 2019 08:41:00 GMT Cache-ControlCache-Control 的值的单位为秒，关键字 max-age 表示可以被缓存多长时间。 1cache-control: max-age=36029314 百度首页加载的一个资源返回头中出现了 Cache-Control 字段，当 Cache-Control 值设为 max-age=300 时，则代表在这个请求正确返回时间（浏览器也会记录下来）的 5 分钟内再次加载资源，就会命中强缓存。 常用的设置值： no-cache： 不使用本地缓存。需要使用缓存协商，先与服务器确认返回的响应是否被更改，如果之前的响应中存在 ETag，那么请求的时候会与服务端验证，如果资源未被更改，则可以避免重新下载。 no-store： 直接禁止浏览器缓存数据，每次用户请求该资源，都会向服务器发送一个请求，每次都会下载完整的资源。 public： 可以被所有的用户缓存，包括终端用户和 CDN 等中间代理服务器。 private： 只能被终端用户的浏览器缓存，不允许 CDN 等中继缓存服务器对其缓存。 s-maxage：这和 max-age 长得比较像，但是区别在于 s-maxage 是针对代理服务器的缓存时间。 must-revalidate：是缓存就会有过期的时候，加上这个字段一旦缓存过期，就必须回到源服务器验证。 注意：当 Expires 和 Cache-Control 同时存在的时候，Cache-Control 会优先考虑。 当然，还存在一种情况，当资源缓存时间超时了，也就是强缓存失效了，接下来怎么办？没错，这样就进入到第二级屏障——协商缓存了。 协商缓存强缓存失效之后，浏览器在请求头中携带相应的缓存 tag 来向服务器发请求，由服务器根据这个 tag，来决定是否使用缓存，这就是协商缓存。 具体来说，这样的缓存 tag 分为两种: Last-Modified 和 ETag。这两者各有优劣，并不存在谁对谁有绝对的优势，跟上面强缓存的两个 tag 不一样。 Last-Modified资源被服务器返回时，HTTP Response Headers 中的 Last-Modified 返回头标识了此资源在服务器上的最后修改时间。 浏览器再次请求服务器时，会将上次 Last-Modified 的值作为 if-Modified-Since 头的值发送，服务器收到请求后，查看最后修改时间以后资源是否被修改过： 没有被修改过，就返回 304，从缓存读取 修改过，返回状态 200 以及整个资源 1last-modified: Wed, 13 Nov 2019 15:16:37 GMT EtagETag 是服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变。服务器通过响应头把这个值给浏览器。 浏览器接收到 ETag 的值，会在下次请求时，将这个值作为If-None-Match这个字段的内容，并放到请求头中，然后发给服务器。 服务器接收到 If-None-Match 后，会跟服务器上该资源的 ETag 进行比对： 两者不一样，说明要更新了。返回新的资源，跟常规的 HTTP 请求响应的流程一样 否则返回 304，告诉浏览器直接用缓存 1etag: W/\"36BE6ECF0746FFAC5024A69C27141E08\" 两者对比精度上Etag 要优于 Last-Modified。Last-Modified 的时间单位是秒，如果某个文件在 1 秒内改变了多次，那么他们的 Last-Modified 其实并没有体现出来修改，但是 Etag 每次都会改变确保了精度。 性能上，Last-Modified 要优于 Etag，毕竟 Last-Modified 只需要记录时间，而 Etag 需要服务器通过算法来计算出一个 hash 值。 优先级上，服务器校验优先考虑 Etag。 浏览器缓存浏览器缓存这一块，最重要的是能区分开强制缓存和协商缓存： 完全不向服务器发送请求的是强制缓存 服务器发送请求的是协商缓存，涉及到 304 的都是协商缓存 总结一下浏览器缓存的全过程： 浏览器第一次加载资源，服务器返回 200，浏览器从服务器下载资源文件，并缓存住资源文件与 response header 以供下次加载时对比使用； 下一次加载资源时，由于强制缓存优先级较高，先比较当前时间与上一次返回 200 时的时间差，如果没有超过 cache-control 设置的 max-age，则没有过期，并命中强缓存，直接从本地读取资源。如果浏览器不支持 HTTP1.1，则使用 expires 头判断是否过期； 如果资源已过期，则表明强制缓存没有被命中，则开始协商缓存，向服务器发送带有 If-None-Match 和 If-Modified-Since 的请求； 服务器收到请求后，优先根据 Etag 的值判断被请求的文件有没有做修改，Etag 值一致则没有修改，命中协商缓存，返回 304；如果不一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200； 如果服务器收到的请求没有 Etag 值，则将 If-Modified-Since 和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回 304；不一致则返回新的 last-modified 和文件并返回 200。 其他问题点击刷新按钮或者按 F5浏览器直接对本地的缓存文件过期，但是会带上If-Modifed-Since，If-None-Match，这就意味着服务器会对文件检查新鲜度，返回结果可能是 304，也有可能是 200。 用户按 Ctrl+F5浏览器不仅会对本地文件过期，而且不会带上 If-Modifed-Since，If-None-Match，相当于之前从来没有请求过，返回结果是 200。 地址栏回车浏览器发起请求，按照正常流程，本地检查是否过期，然后服务器检查新鲜度，最后返回内容。 最后还可以提到，你注意到很多网站的资源后面都加了版本号，这样做的目的是：每次升级了 JS 或 CSS 文件后，为了防止浏览器进行缓存，强制改变版本号，客户端浏览器就会重新下载新的 JS 或 CSS 文件 ，以保证用户能够及时获得网站的最新更新。 缓存的资源都存在哪里按优先级从高到低分别是： Service Worker：运行在 JavaScript 主线程之外，虽然由于脱离了浏览器窗体无法直接访问 DOM，但是它可以完成离线缓存、消息推送、网络代理等功能。 Memory Cache：就是内存缓存，它的效率最快，但是存活时间最短，你一关掉浏览器 Memory Cache 里的文件就被清空了。 Disk Cache：Cache 资源被存储在硬盘上，存活时间比 Memory Cache 要持久很多。 Push Cache：即推送缓存，这是浏览器缓存的最后一道防线。它是 HTTP/2 中的内容，虽然现在应用的并不广泛，但随着 HTTP/2 的推广，它的应用越来越广泛。 Node 演示123456789101112131415161718192021222324252627282930313233343536373839const http = require(\"http\");const fs = require(\"fs\");const md5 = require(\"md5\");function handle(req, res) &#123; const html = fs.readFileSync(\"index.html\", \"utf-8\"); const script = fs.readFileSync(\"script.js\", \"utf-8\"); if (req.url === \"/\") &#123; res.writeHead(200, &#123; \"Content-Type\": \"text/html\" &#125;); res.write(html); &#125; if (req.url === \"/script.js\") &#123; const etag = md5(script); const lastMidified = lastUpdatedDate(\"./script.js\"); const ifNoneMatch = req.headers[\"if-none-match\"]; let statusCode = ifNoneMatch === etag ? 304 : 200; res.writeHead(statusCode, &#123; \"Content-Type\": \"text/javascript\", \"Cache-Control\": \"no-cache\", \"Last-Modified\": lastMidified, Etag: etag &#125;); res.write(script); &#125; res.end();&#125;function lastUpdatedDate(file) &#123; const &#123; mtime &#125; = fs.statSync(file); return mtime;&#125;http.createServer(handle).listen(8000); 参考资料 浏览器是怎么缓存资源的 能不能说一说前端缓存 浏览器缓存 cache-control etag","categories":[{"name":"网络知识","slug":"网络知识","permalink":"https://www.yangtao.site/categories/网络知识/"}],"tags":[{"name":"http","slug":"http","permalink":"https://www.yangtao.site/tags/http/"}]},{"title":"5 个有趣的 Node.js 库,带你走进 彩色 Node.js 世界","slug":"node-5-util","date":"2020-03-26T14:20:41.000Z","updated":"2020-03-26T14:23:51.527Z","comments":true,"path":"2020/03/26/node-5-util/","link":"","permalink":"https://www.yangtao.site/2020/03/26/node-5-util/","excerpt":"📦 5 个有趣的 Node.js 库,带你走进 彩色 Node.js 世界 🎉 🎉 🎉","text":"📦 5 个有趣的 Node.js 库,带你走进 彩色 Node.js 世界 🎉 🎉 🎉 1、ChalkGithub：chalk 这是一个能给你的 log 染色的库,让你的代码靓起来 !! 123456789101112131415161718192021222324252627282930313233343536373839404142const chalk = require(\"chalk\");const log = console.log;// Combine styled and normal stringslog(chalk.blue(\"Hello\") + \" World\" + chalk.red(\"!\"));// Compose multiple styles using the chainable APIlog(chalk.blue.bgRed.bold(\"Hello world!\"));// Pass in multiple argumentslog(chalk.blue(\"Hello\", \"World!\", \"Foo\", \"bar\", \"biz\", \"baz\"));// Nest styleslog(chalk.red(\"Hello\", chalk.underline.bgBlue(\"world\") + \"!\"));// Nest styles of the same type even (color, underline, background)log( chalk.green( \"I am a green line \" + chalk.blue.underline.bold(\"with a blue substring\") + \" that becomes green again!\" ));// ES2015 template literallog(`CPU: $&#123;chalk.red(\"90%\")&#125;RAM: $&#123;chalk.green(\"40%\")&#125;DISK: $&#123;chalk.yellow(\"70%\")&#125;`);// ES2015 tagged template literallog(chalk`CPU: &#123;red $&#123;cpu.totalPercent&#125;%&#125;RAM: &#123;green $&#123;(ram.used / ram.total) * 100&#125;%&#125;DISK: &#123;rgb(255,131,0) $&#123;(disk.used / disk.total) * 100&#125;%&#125;`);// Use RGB colors in terminal emulators that support it.log(chalk.keyword(\"orange\")(\"Yay for orange colored text!\"));log(chalk.rgb(123, 45, 67).underline(\"Underlined reddish color\"));log(chalk.hex(\"#DEADED\").bold(\"Bold gray!\")); 2、Inquirer.jsGithub：Inquirer.js 一个非常好看的交互式命令行用户界面,用它来定制你的 CLI 吧 ！ 123456789101112131415var inquirer = require(\"inquirer\");inquirer .prompt([ /* Pass your questions in here */ ]) .then(answers =&gt; &#123; // Use user feedback for... whatever!! &#125;) .catch(error =&gt; &#123; if (error.isTtyError) &#123; // Prompt couldn't be rendered in the current environment &#125; else &#123; // Something else when wrong &#125; &#125;); Checkbox list examples： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364var inquirer = require(\"inquirer\");inquirer .prompt([ &#123; type: \"checkbox\", message: \"Select toppings\", name: \"toppings\", choices: [ new inquirer.Separator(\" = The Meats = \"), &#123; name: \"Pepperoni\" &#125;, &#123; name: \"Ham\" &#125;, &#123; name: \"Ground Meat\" &#125;, &#123; name: \"Bacon\" &#125;, new inquirer.Separator(\" = The Cheeses = \"), &#123; name: \"Mozzarella\", checked: true &#125;, &#123; name: \"Cheddar\" &#125;, &#123; name: \"Parmesan\" &#125;, new inquirer.Separator(\" = The usual =\"), &#123; name: \"Mushroom\" &#125;, &#123; name: \"Tomato\" &#125;, new inquirer.Separator(\" = The extras = \"), &#123; name: \"Pineapple\" &#125;, &#123; name: \"Olives\", disabled: \"out of stock\" &#125;, &#123; name: \"Extra cheese\" &#125; ], validate: function(answer) &#123; if (answer.length &lt; 1) &#123; return \"You must choose at least one topping.\"; &#125; return true; &#125; &#125; ]) .then(answers =&gt; &#123; console.log(JSON.stringify(answers, null, \" \")); &#125;); 输出： 12345678910? Select toppings (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection) = The Meats =❯◯ Pepperoni ◯ Ham ◯ Ground Meat ◯ Bacon = The Cheeses = ◉ Mozzarella(Move up and down to reveal more choices) 3、OraGithub：ora 1234567891011121314const ora = require(\"ora\");const spinner = ora(\"Loading unicorns\").start();setTimeout(() =&gt; &#123; spinner.color = \"cyan\"; spinner.text = \"Loading rainbows\";&#125;, 1000);setTimeout(() =&gt; &#123; spinner.text = \"Loading success\"; spinner.succeed(); // spinner.fail();&#125;, 3000); 输出（icon 是有对应颜色的）： 12⠧ Loading rainbows✔ Loading success 4、figlet.jsGithub：figlet.js 12345678910var figlet = require(\"figlet\");figlet(\"Hello World!!\", function(err, data) &#123; if (err) &#123; console.log(\"Something went wrong...\"); console.dir(err); return; &#125; console.log(data);&#125;); 然后输出： 12345 _ _ _ _ __ __ _ _ _ _| | | | ___| | | ___ \\ \\ / /__ _ __| | __| | | || |_| |/ _ \\ | |/ _ \\ \\ \\ /\\ / / _ \\| '__| |/ _` | | || _ | __/ | | (_) | \\ V V / (_) | | | | (_| |_|_||_| |_|\\___|_|_|\\___/ \\_/\\_/ \\___/|_| |_|\\__,_(_|_) 5、boxenGithub：boxen 12345678910111213const boxen = require(\"boxen\");console.log(boxen(\"Hello World\", &#123; padding: 1, borderColor: \"yellow\" &#125;));console.log( boxen(\"I LOVE YOU\", &#123; padding: 1, margin: 1, borderStyle: \"classic\", borderColor: \"red\", backgroundColor: \"magenta\" &#125;)); 输出效果： 1234567891011┌─────────────────┐│ ││ Hello World ││ │└─────────────────┘ +----------------+ | | | I LOVE YOU | | | +----------------+ 资料 📦 5 个有趣的 Node.js 库,带你走进 彩色 Node.js 世界 🎉","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://www.yangtao.site/categories/Nodejs/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://www.yangtao.site/tags/Nodejs/"}]},{"title":"跨域资源共享 CORS","slug":"cross-cors","date":"2020-03-25T06:43:47.000Z","updated":"2020-03-27T08:30:19.059Z","comments":true,"path":"2020/03/25/cross-cors/","link":"","permalink":"https://www.yangtao.site/2020/03/25/cross-cors/","excerpt":"跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain) 上的 Web 应用被准许访问来自不同源服务器上的指定的资源。 — MDN","text":"跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain) 上的 Web 应用被准许访问来自不同源服务器上的指定的资源。 — MDN 什么情况下需要 CORS允许在下列场景中使用跨域 HTTP 请求： 由 XMLHttpRequest 或 Fetch 发起的跨域 HTTP 请求 Web 字体 (CSS 中通过 @font-face 使用跨域字体资源) WebGL 贴图 使用 drawImage 将 Images/video 画面绘制到 canvas 两种请求浏览器将 CORS 请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。 只要同时满足以下两大条件，就属于简单请求（不会触发 CORS 预检请求）。 请求方法是以下三种方法之一：HEAD、GET、POST HTTP 的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type（只限于三个值） application/x-www-form-urlencoded multipart/form-data text/plain 凡是不同时满足上面两个条件，就属于非简单请求。 CORS 如何工作首先，浏览器判断请求是简单请求还是复杂请求（非简单请求）。 如果是复杂请求，那么在进行真正的请求之前，浏览器会先使用 OPTIONS 方法发送一个预检请求 (preflight request)，OPTIONS 是 HTTP/1.1 协议中定义的方法，用以从服务器获取更多信息。 该方法不会对服务器资源产生影响，预检请求中同时携带了下面两个首部字段： Access-Control-Request-Method: 这个字段表明了请求的方法； Access-Control-Request-Headers: 这个字段表明了这个请求的 Headers； Origin: 这个字段表明了请求发出的域。 服务端收到请求后，会以 Access-Control-* response headers 的形式对客户端进行回复： Access-Control-Allow-Origin: 能够被允许发出这个请求的域名，也可以使用*来表明允许所有域名； Access-Control-Allow-Methods: 用逗号分隔的被允许的请求方法的列表； Access-Control-Allow-Headers: 用逗号分隔的被允许的请求头部字段的列表； Access-Control-Max-Age: 这个预检请求能被缓存的最长时间，在缓存时间内，同一个请求不会再次发出预检请求。 简单请求对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是在头信息之中，自动增加一个 Origin 字段，用来说明请求来自哪个源。服务器拿到请求之后，在回应时对应地添加Access-Control-Allow-Origin字段，如果 Origin 不在这个字段的范围中，那么浏览器就会将响应拦截。 Access-Control-Allow-Credentials。这个字段是一个布尔值，表示是否允许发送 Cookie，对于跨域请求，浏览器对这个字段默认值设为 false，而如果需要拿到浏览器的 Cookie，需要添加这个响应头并设为 true, 并且在前端也需要设置withCredentials属性： 12let xhr = new XMLHttpRequest();xhr.withCredentials = true; Access-Control-Expose-Headers。这个字段是给 XMLHttpRequest 对象赋能，让它不仅可以拿到基本的 6 个响应头字段（包括Cache-Control、Content-Language、Content-Type、Expires、Last-Modified和Pragma）, 还能拿到这个字段声明的响应头字段。比如这样设置: 1Access-Control-Expose-Headers: aaa 那么在前端可以通过 XMLHttpRequest.getResponseHeader(&#39;aaa&#39;) 拿到 aaa 这个字段的值。 举个栗子比如下面开启一个端口为 8001 的服务，去请求端口为 8000 的数据： 12345678910111213141516const url = \"http://127.0.0.1:8000\";const data = &#123; username: \"example\" &#125;;const myHeaders = new Headers(&#123; \"Content-Type\": \"text/plain\"&#125;);fetch(url, &#123; method: \"POST\", headers: myHeaders, body: JSON.stringify(data), mode: \"cors\"&#125;) .then(res =&gt; res.json()) .then(res =&gt; &#123; console.log(JSON.parse(res.postData)); //&#123;username: \"example\"&#125; &#125;); 端口为 8000 的服务端设置： 1234567891011121314151617181920const http = require(\"http\");const server = http.createServer((req, res) =&gt; &#123; res.writeHead(200, &#123; \"Content-Type\": \"text/plain\", \"Access-Control-Allow-Origin\": \"*\" &#125;); let resData = &#123;&#125;; let postData = []; req.on(\"data\", chunk =&gt; &#123; postData.push(chunk); &#125;); req.on(\"end\", () =&gt; &#123; resData.postData = Buffer.concat(postData).toString(); res.end(JSON.stringify(resData)); &#125;);&#125;);server.listen(8000); 非简单请求非简单请求相对而言会有些不同，体现在两个方面: 预检请求和响应字段。 预检请求比如使用 PUT 请求方法： 12345678910111213141516const url = \"http://127.0.0.1:8000\";const data = &#123; username: \"example\" &#125;;const myHeaders = new Headers(&#123; \"X-Custom-Header\": \"xxx\"&#125;);fetch(url, &#123; method: \"PUT\", // 改成 PUT headers: myHeaders, body: JSON.stringify(data), mode: \"cors\"&#125;) .then(res =&gt; res.json()) .then(res =&gt; &#123; console.log(JSON.parse(res.postData)); //&#123;username: \"example\"&#125; &#125;); Node 部分： 12345678res.writeHead(200, &#123; \"Content-Type\": \"text/json\", \"Access-Control-Allow-Origin\": \"*\", \"Access-Control-Allow-Methods\": \"PUT, POST, GET\", \"Access-Control-Allow-Headers\": \"X-Custom-Header\", \"Access-Control-Max-Age\": 2000, \"Access-Control-Allow-Credentials\": true&#125;); 当这段代码执行后，首先会发送预检请求。这个预检请求的请求行和请求体是下面这个格式: 12345OPTIONS / HTTP/1.1Host: 127.0.0.1:8000Access-Control-Request-Method: PUTAccess-Control-Request-Headers: x-custom-headerOrigin: http://127.0.0.1:8001 预检请求的方法是OPTIONS，同时会加上 Origin 源地址和 Host 目标地址，这很简单。同时也会加上两个关键的字段: Access-Control-Request-Method, 列出 CORS 请求用到哪个 HTTP 方法 Access-Control-Request-Headers，指定 CORS 请求将要加上什么请求头 这是预检请求。接下来是响应字段。 响应字段也分为两部分，一部分是对于预检请求的响应，一部分是对于CORS 请求的响应。 预检请求的响应： 12345678910HTTP/1.1 200 OKContent-Type: text/jsonAccess-Control-Allow-Origin: *Access-Control-Allow-Methods: PUT, POST, GETAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Max-Age: 2000Access-Control-Allow-Credentials: trueDate: Fri, 27 Mar 2020 08:16:58 GMTConnection: keep-aliveTransfer-Encoding: chunked 在预检请求的响应返回后，如果请求不满足响应头的条件，则触发XMLHttpRequest的onerror方法，当然后面真正的 CORS 请求也不会发出去了。 CORS 请求的响应：现在它和简单请求的情况是一样的。浏览器自动加上 Origin 字段，服务端响应头返回 Access-Control-Allow-Origin。在设置的Access-Control-Max-Age: 2000里是不会再次发送预检请求的，除非时间过期。 参考资料 什么是跨域？浏览器如何拦截响应？如何解决 阮一峰 跨域资源共享 CORS 详解 MDN HTTP 访问控制（CORS） 使用 Fetch HTTP协议原理+实践Web开发工程师必学 - 慕课网付费课程","categories":[{"name":"网络知识","slug":"网络知识","permalink":"https://www.yangtao.site/categories/网络知识/"}],"tags":[{"name":"http","slug":"http","permalink":"https://www.yangtao.site/tags/http/"}]},{"title":"跨域解决方案 JSONP","slug":"cross-jsonp","date":"2020-03-25T03:07:14.000Z","updated":"2020-03-27T07:39:12.082Z","comments":true,"path":"2020/03/25/cross-jsonp/","link":"","permalink":"https://www.yangtao.site/2020/03/25/cross-jsonp/","excerpt":"JSONP 请求本质上是利用了 “Ajax 请求会受到同源策略限制，而 script 标签请求不会” 这一点来绕过同源策略。","text":"JSONP 请求本质上是利用了 “Ajax 请求会受到同源策略限制，而 script 标签请求不会” 这一点来绕过同源策略。 同源策略什么是同源策略，其作用是什么？ 同源策略指的是：协议+域名+端口三者皆相同，可以视为在同一个域，否则为不同域。同源策略限制了从同一个源加载的文档或脚本如何与来自另一个源的资源进行交互。 作用是一个用于隔离潜在恶意文件的重要安全机制。 所限制的跨域交互包括： Cookie、LocalStorage、IndexdDB 等存储内容； DOM 节点； Ajax 请求。 Ajax 为什么不能跨域Ajax 其实就是向服务器发送一个 GET 或 POST 请求，然后取得服务器响应结果，返回客户端。Ajax 跨域请求，在服务器端不会有任何问题，只是服务端响应数据返回给浏览器的时候，浏览器根据响应头的Access-Control-Allow-Origin字段的值来判断是否有权限获取数据。因此，服务端如果没有设置跨域字段设置，跨域是没有权限访问，数据被浏览器给拦截了。 所以，要解决的问题是：如何从客户端拿到返回的数据？ 其实，在同源策略的基础上，选择性地为同源策略开放了一些后门。例如 img、script、style 等标签，都允许跨域引用资源。 所以， JSONP 来了。 JSONP 实现JSONP(JSON with Padding（填充）)是 JSON 的一种“使用模式”，本质不是 Ajax 请求，是 script 标签请求。JSONP 请求本质上是利用了 “Ajax 请求会受到同源策略限制，而 script 标签请求不会” 这一点来绕过同源策略。 简单 JSONP 实现： 12345678910111213141516171819202122class Jsonp &#123; constructor(req) &#123; this.url = req.url; this.callbackName = req.callbackName; &#125; create() &#123; const script = document.createElement(\"script\"); const url = `$&#123;this.url&#125;?callback=$&#123;this.callbackName&#125;`; script.src = url; document.getElementsByTagName(\"head\")[0].appendChild(script); &#125;&#125;new Jsonp(&#123; url: \"http://127.0.0.1:8000/\", callbackName: \"getMsg\"&#125;).create();function getMsg(data) &#123; data = JSON.parse(data); console.log(`My name is $&#123;data.name&#125;, and $&#123;data.age&#125; years old.`);&#125; 服务端（Node）: 123456789101112131415const http = require(\"http\");const querystring = require(\"querystring\");const server = http.createServer((req, res) =&gt; &#123; const url = req.url; const query = querystring.parse(url.split(\"?\")[1]); const &#123; callback &#125; = query; const data = &#123; name: \"Yang Min\", age: \"8\" &#125;; res.end(`$&#123;callback&#125;('$&#123;JSON.stringify(data)&#125;')`);&#125;);server.listen(8000); 前端利用 http-server -p 8001 .，开启一个服务，然后 Node 也开启一个端口为 8000 的服务，运行： 1My name is Yang Min, and 8 years old. 一个 JSONP 的步骤实质客户端发送 script 请求，参数中带着处理返回数据的回调函数的名字 (通常是 callback)，如请求 script 的 url 是： 1http://127.0.0.1:8000/?callback=getMsg 服务端收到请求，以回调函数名和返回数据组成立即执行函数的字符串，比如：其中 callback 的值是客户端发来的回调函数的名字，假设回调函数的名字是 getMsg，返回脚本的内容就是： 1getMsg(\"&#123;name: 'Yang Min', age: '8'&#125;\"); 客户端收到 JavaScript 脚本内容后，立即执行脚本，这样就实现了获取跨域服务器数据的目的。 很明显，由于 JSONP 技术本质上利用了 script 脚本请求，所以只能实现 GET 跨域请求，这也是 JSONP 跨域的最大限制。 由于 server 产生的响应为 json 数据的包装（故称之为 jsonp，即 json padding），形如：getMsg(&quot;{name: &#39;Yang Min&#39;, age: &#39;8&#39;}&quot;) JSONP 封装客户端： 123456789101112131415161718192021222324252627282930313233343536373839404142const jsonp = (&#123; url, params, callbackName &#125;) =&gt; &#123; const generateURL = () =&gt; &#123; let dataStr = \"\"; for (let key in params) &#123; dataStr += `$&#123;key&#125;=$&#123;params[key]&#125;&amp;`; &#125; dataStr += `callback=$&#123;callbackName&#125;`; return `$&#123;url&#125;?$&#123;dataStr&#125;`; &#125;; return new Promise((resolve, reject) =&gt; &#123; // 初始化回调函数名称 callbackName = callbackName || \"cb\" + Math.random() .toString() .replace(\".\", \"\"); let scriptEle = document.createElement(\"script\"); scriptEle.src = generateURL(); document.body.appendChild(scriptEle); // 绑定到 window 上，为了后面调用 window[callbackName] = data =&gt; &#123; resolve(data); // script 执行完了，成为无用元素，需要清除 document.body.removeChild(scriptEle); &#125;; &#125;);&#125;;jsonp(&#123; url: \"http://127.0.0.1:8000/\", params: &#123; name: \"Yang Min\", age: \"8\" &#125;, callbackName: \"getData\"&#125;) .then(data =&gt; JSON.parse(data)) .then(data =&gt; &#123; console.log(data); // &#123;name: \"Yang Min\", age: \"8\"&#125; &#125;); Node 端： 123456789101112131415const http = require(\"http\");const querystring = require(\"querystring\");const server = http.createServer((req, res) =&gt; &#123; const url = req.url; const query = querystring.parse(url.split(\"?\")[1]); const &#123; name, age, callback &#125; = query; const data = &#123; name, age &#125; res.end(`$&#123;callback&#125;('$&#123;JSON.stringify(data)&#125;')`);&#125;);server.listen(8000); jQuery 中的 JSONPNode 部分不变，使用 jQuery(3.4.1) 如下： 123456789101112131415161718function getAjaxData() &#123; $.ajax(&#123; type: \"get\", async: false, url: \"http://127.0.0.1:8000/\", dataType: \"jsonp\", //由 JSON 改为 JSONP jsonp: \"callback\", //传递给请求处理程序或页面的，标识jsonp回调函数名(一般为:callback) jsonpCallback: \"getData\", //callback的function名称，成功就会直接走 success 方法 success: function(data) &#123; data = JSON.parse(data); console.log(`My name is $&#123;data.name&#125;, and $&#123;data.age&#125; years old.`); &#125;, error: function() &#123; console.log(\"Error\"); &#125; &#125;);&#125;getAjaxData(); 使用延迟对象重新写下： 12345678910111213141516171819function getAjaxData() &#123; const def = $.ajax(&#123; type: \"get\", async: false, url: \"http://127.0.0.1:8000/\", dataType: \"jsonp\", jsonp: \"callback\", jsonpCallback: \"getData\" &#125;); def .done(data =&gt; &#123; data = JSON.parse(data); console.log(`My name is $&#123;data.name&#125;, and $&#123;data.age&#125; years old.`); &#125;) .fail(err =&gt; &#123; console.log(err); &#125;);&#125; JSONP 缺点 只支持 GET 请求 只支持跨域 HTTP 请求这种情况，不能解决不同域的两个页面之间如何进行 JavaScript 调用的问题 调用失败的时候不会返回各种 HTTP 状态码。 安全性，万一假如提供 JSONP 的服务存在页面注入漏洞，即它返回的 javascript 的内容被人控制的。 参考资料 什么是跨域？浏览器如何拦截响应？如何解决 jsonp 跨域原理分析 - 分析了 Ajax 和 jsonp 之间的关系","categories":[{"name":"网络知识","slug":"网络知识","permalink":"https://www.yangtao.site/categories/网络知识/"}],"tags":[{"name":"http","slug":"http","permalink":"https://www.yangtao.site/tags/http/"}]},{"title":"Node 中间件原理","slug":"node-middleware","date":"2020-03-20T09:59:34.000Z","updated":"2020-03-20T10:06:45.464Z","comments":true,"path":"2020/03/20/node-middleware/","link":"","permalink":"https://www.yangtao.site/2020/03/20/node-middleware/","excerpt":"Koa 和 Express 的设计风格非常类似，底层也都是共用的同一套 HTTP 基础库，但是有几个显著的区别，除了上面提到的默认异步解决方案之外，主要的特点还有下面几个。","text":"Koa 和 Express 的设计风格非常类似，底层也都是共用的同一套 HTTP 基础库，但是有几个显著的区别，除了上面提到的默认异步解决方案之外，主要的特点还有下面几个。 MiddlewareKoa 的中间件和 Express 不同，Koa 选择了洋葱圈模型。 所有的请求经过一个中间件的时候都会执行两次，对比 Express 形式的中间件，Koa 的模型可以非常方便的实现后置处理逻辑，对比 Koa 和 Express 的 Compress 中间件就可以明显的感受到 Koa 中间件模型的优势。 Context和 Express 只有 Request 和 Response 两个对象不同，Koa 增加了一个 Context 的对象，作为这次请求的上下文对象（在 Koa 1 中为中间件的 this，在 Koa 2 中作为中间件的第一个参数传入）。 我们可以将一次请求相关的上下文都挂载到这个对象上。类似 traceId 这种需要贯穿整个请求（在后续任何一个地方进行其他调用都需要用到）的属性就可以挂载上去。相较于 request 和 response 而言更加符合语义。 同时 Context 上也挂载了 Request 和 Response 两个对象。和 Express 类似，这两个对象都提供了大量的便捷方法辅助开发，例如 get request.query get request.hostname set response.body set response.status 异常处理通过同步方式编写异步代码带来的另外一个非常大的好处就是异常处理非常自然，使用 try catch 就可以将按照规范编写的代码中的所有错误都捕获到。这样我们可以很便捷的编写一个自定义的错误处理中间件。 123456789async function onerror(ctx, next) &#123; try &#123; await next(); &#125; catch (err) &#123; ctx.app.emit(\"error\", err); ctx.body = \"server error\"; ctx.status = err.status || 500; &#125;&#125; 只需要将这个中间件放在其他中间件之前，就可以捕获它们所有的同步或者异步代码中抛出的异常了。 注：以上所有皆来自Egg.js 与 Koa 中间件模拟Express123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101const http = require(\"http\");const slice = Array.prototype.slice;class LikeExpress &#123; constructor() &#123; // 存放中间件的列表 this.routes = &#123; all: [], // app.use(...) get: [], // app.get(...) post: [] // app.post(...) &#125;; &#125; register(path) &#123; const info = &#123;&#125;; if (typeof path === \"string\") &#123; info.path = path; // 从第二个参数开始，转换为数组，存入 stack info.stack = slice.call(arguments, 1); &#125; else &#123; info.path = \"/\"; // 从第一个参数开始，转换为数组，存入 stack info.stack = slice.call(arguments, 0); &#125; return info; &#125; use() &#123; const info = this.register.apply(this, arguments); this.routes.all.push(info); &#125; get() &#123; const info = this.register.apply(this, arguments); this.routes.get.push(info); &#125; post() &#123; const info = this.register.apply(this, arguments); this.routes.post.push(info); &#125; match(method, url) &#123; let stack = []; if (url === \"/favicon.ico\") &#123; return stack; &#125; // 获取 routes let curRoutes = []; curRoutes = curRoutes.concat(this.routes.all); curRoutes = curRoutes.concat(this.routes[method]); curRoutes.forEach(routeInfo =&gt; &#123; if (url.indexOf(routeInfo.path) === 0) &#123; // url === '/api/get-cookie' 且 routeInfo.path === '/' // url === '/api/get-cookie' 且 routeInfo.path === '/api' // url === '/api/get-cookie' 且 routeInfo.path === '/api/get-cookie' stack = stack.concat(routeInfo.stack); &#125; &#125;); return stack; &#125; // 核心的 next 机制 handle(req, res, stack) &#123; const next = () =&gt; &#123; // 拿到第一个匹配的中间件 const middleware = stack.shift(); if (middleware) &#123; // 执行中间件函数 middleware(req, res, next); &#125; &#125;; next(); &#125; callback() &#123; return (req, res) =&gt; &#123; res.json = data =&gt; &#123; res.setHeader(\"Content-type\", \"application/json\"); res.end(JSON.stringify(data)); &#125;; const url = req.url; const method = req.method.toLowerCase(); const resultList = this.match(method, url); this.handle(req, res, resultList); &#125;; &#125; listen(...args) &#123; const server = http.createServer(this.callback()); server.listen(...args); &#125;&#125;// 工厂函数module.exports = () =&gt; &#123; return new LikeExpress();&#125;; Koa12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758const http = require(\"http\");// 组合中间件function compose(middlewareList) &#123; return function(ctx) &#123; function dispatch(i) &#123; const fn = middlewareList[i]; try &#123; return Promise.resolve( fn(ctx, dispatch.bind(null, i + 1)) // promise ); &#125; catch (err) &#123; return Promise.reject(err); &#125; &#125; return dispatch(0); &#125;;&#125;class LikeKoa2 &#123; constructor() &#123; this.middlewareList = []; &#125; use(fn) &#123; this.middlewareList.push(fn); return this; &#125; createContext(req, res) &#123; const ctx = &#123; req, res &#125;; ctx.query = req.query; return ctx; &#125; handleRequest(ctx, fn) &#123; return fn(ctx); &#125; callback() &#123; const fn = compose(this.middlewareList); return (req, res) =&gt; &#123; const ctx = this.createContext(req, res); return this.handleRequest(ctx, fn); &#125;; &#125; listen(...args) &#123; const server = http.createServer(this.callback()); server.listen(...args); &#125;&#125;module.exports = LikeKoa2; 项目实践Node.js 从零开发 web server博客项目，并使用express、koa2重构","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://www.yangtao.site/categories/Nodejs/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://www.yangtao.site/tags/Nodejs/"}]},{"title":"Cookie、Session、LocalStorage、SessionStorage","slug":"cookie-session","date":"2020-03-20T04:08:07.000Z","updated":"2020-03-31T03:30:13.505Z","comments":true,"path":"2020/03/20/cookie-session/","link":"","permalink":"https://www.yangtao.site/2020/03/20/cookie-session/","excerpt":"Session 是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie 是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现 Session 的一种方式；LocalStorage 是 Web Storage API 的一种类型，能在浏览器端存储键值对数据；SessionStorage 只存储当前会话页(tab 页)的数据，一旦用户关闭当前页或者浏览器，数据就自动被清除掉了。","text":"Session 是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；Cookie 是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现 Session 的一种方式；LocalStorage 是 Web Storage API 的一种类型，能在浏览器端存储键值对数据；SessionStorage 只存储当前会话页(tab 页)的数据，一旦用户关闭当前页或者浏览器，数据就自动被清除掉了。 Cookie在网站中，http 请求是无状态的。也就是说即使第一次和服务器连接后并且登录成功后，第二次请求服务器依然不能知道当前请求是哪个用户。 cookie 的出现就是为了解决这个问题，第一次登录后服务器返回一些数据（cookie）给浏览器，然后浏览器保存在本地，当该用户发送第二次请求的时候，就会自动的把上次请求存储的 cookie 数据自动的携带给服务器，服务器通过浏览器携带的数据就能判断当前用户是哪个了。 cookie 存储的数据量有限，不同的浏览器有不同的存储大小，但一般不超过 4KB。因此使用 cookie 只能存储一些小量的数据。 Cookie 的优点： 能用于和服务端通信 当 cookie 快要自动过期时，我们可以重新设置而不是删除 Cookie 缺点： 增加了文档传输的负载 只能存储少量的数据 只能存储字符串 潜在的 安全问题（通过服务端设置 httpOnly） 解决办法：Web Storage API (Local and Session Storage)。 创建，读取，更新和删除 Cookie： 12345678// 读取document.cookie;// 修改/更新document.cookie = \"testname=Yangtao\";// 删除，设置expires的过期时间document.cookie = \"testname=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;\"; 客户端设置： 1234567891011121314151617181920212223242526272829303132333435(function() &#123; var getAndSetCookie = &#123; init: function() &#123; this.checkCookie(); &#125;, // 设置cookie，同一域名都可获取 setCookie: function(name, value, exdays) &#123; var exdays = exdays || 1; var d = new Date(); d.setTime(d.getTime() + exdays * 24 * 60 * 60 * 1000); document.cookie = name + \"=\" + escape(value) + \";path=/;expires=\" + d.toGMTString(); &#125;, // 读取cookies，判断是否存在设置的name getCookie: function(name) &#123; var name = name + \"=\"; var ca = document.cookie.split(\";\"); for (var i = 0; i &lt; ca.length; i++) &#123; var c = ca[i].trim(); if (c.indexOf(name) == 0) &#123; return c.substring(name.length, c.length); &#125; &#125; return \"\"; &#125;, checkCookie: function(pc) &#123; var user = this.getCookie(\"msgCookie\"); if (user == \"\") &#123; this.setCookie(\"msgCookie\", \"msgCookie\", 1); &#125; &#125; &#125;; // init getAndSetCookie.init();&#125;)(); Node 设置： 1234567891011121314151617181920212223242526// 获取 cookie 过期时间const getCookieExpires = () =&gt; &#123;const d = new Date();d.setTime(d.getTime() + 24 * 60 * 60 * 1000);return d.toGMTString();&#125;;// 设置res.setHeader(\"Set-Cookie\",`username=$&#123;data.username&#125;; path=/; httpOnly; expires=$&#123;getCookieExpires()&#125;`);// 解析 cookiereq.cookie = &#123;&#125;;const cookieStr = req.headers.cookie || \"\"; // \"k1=v1; k2=v2; k3=v3\"cookieStr.split(\";\").forEach(item =&gt; &#123; if (!item) &#123; return; &#125; const str = item.split(\"=\"); const key = str[0].trim(); const val = str[1].trim(); req.cookie[key] = val;&#125;); Sessionsession 和 cookie 的作用有点类似，都是为了存储用户相关的信息。不同的是，cookie 是存储在本地浏览器，而 session 存储在服务器。 存储在服务器的数据会更加的安全，不容易被窃取。但存储在服务器也有一定的弊端，就是会占用服务器的资源，所以就用到了 redis。 Session 的问题： session 是一个变量存在 nodejs 进程内存中 进程内存有限，访问量过大，内存容易暴增 线上多为多进程，进程间内存无法共享 可以借助 redis 解决 Cookie+Sessioncookie 和 session 的使用已经出现了一些非常成熟的方案。在如今的市场或者企业里，一般有两种存储方式： 1、存储在服务端 通过 cookie 存储一个 session_id，然后具体的数据则是保存在 session 中。如果用户已经登录，则服务器会在 cookie 中保存一个 session_id，下次再次请求的时候，会把该 session_id 携带上来，服务器根据 session_id 在 session 库中获取用户的 session 数据。就能知道该用户到底是谁，以及之前保存的一些状态信息。这种专业术语叫做 server side session。 2、将 session 数据加密，然后存储在 cookie 中 这种专业术语叫做 client side session。 总结： 存储在浏览器的一段字符串 跨域不共享 可以存储结构化数据，格式为：”k1=v1; k2=v2; k3=v3” 浏览器可以使用 JavaScript 修改 cookie（有限制） 每次发送 http 请求，都将请求域的 cookie 一起发给 server server 可以修改 cookie，并返给浏览器 12345678910111213141516171819202122232425262728293031323334353637383940const SESSION_DATA = &#123;&#125;;let needSetCookie = false;const serverHandle = (req, res) =&gt; &#123; // 解析 session let userId = req.cookie.userid; if (userId) &#123; if (!SESSION_DATA[userId]) &#123; SESSION_DATA[userId] = &#123;&#125;; &#125; &#125; else &#123; needSetCookie = true; userId = `$&#123;Date.now()&#125;_$&#123;Math.random()&#125;`; SESSION_DATA[userId] = &#123;&#125;; &#125; req.session = SESSION_DATA[userId]; // 操作 cookie if (needSetCookie) &#123; res.setHeader( \"Set-Cookie\", `userid=$&#123;userId&#125;; path=/; httpOnly; expires=$&#123;getCookieExpires()&#125;` ); &#125; // ... // 获取username并赋值 if (data.username) &#123; req.session.username = data.username; return new SuccessModel(); &#125; // 然后返回 if (req.session.username) &#123; return Promise.resolve( new SuccessModel(&#123; session: req.session &#125;) ); &#125;&#125;; 详细内容：登录 LocalStorageLocal Storage 是 Web Storage API 的一种类型，能在浏览器端存储键值对数据。 Local Storage 因提供了更直观和安全的 API 来存储简单的数据，被视为替代 Cookies 的一种解决方案。从技术上说，尽管 Local Storage 只能存储字符串，但是它也是可以存储字符串化的 JSON 数据。这就意味着，Local Storage 能比 Cookies 存储更复杂的数据。 创建，读取，更新和删除 Local Storage： 1234567891011121314// Createconst user = &#123; name: \"Bob\", age: 25 &#125;;localStorage.setItem(\"user\", JSON.stringify(user));// Read (Single)console.log(JSON.parse(localStorage.getItem(\"user\")));// Updateconst updatedUser = &#123; name: \"Bob\", age: 24 &#125;;localStorage.setItem(\"user\", JSON.stringify(updatedUser));// DeletelocalStorage.removeItem(\"user\"); Local Storage 的优点：相比于 Cookie，其提供了更直观地接口来存储数据更安全,能存储更多数据。 Local Storage 的缺点：只能存储字符串数据，浏览器支持IE8+/Edge/Firefox 2+/Chrome/Safari 4+/Opera 11.5+(caniuse) SessionStorageSession Storage 和 Local Storage 非常类似，区别是 Session Storage 只存储当前会话页(tab 页)的数据，一旦用户关闭当前页或者浏览器，数据就自动被清除掉了。 创建，读取，更新和删除 Session Storage： 12345678910111213// Createconst user = &#123; name: 'Bob', age: 25 &#125;sessionStorage.setItem('user', JSON.stringify(user))// Read (Single)console.log( JSON.parse(sessionStorage.getItem('user')) )// Updateconst updatedUser = &#123; name: 'Bob', age: 24 &#125;sessionStorage.setItem('user', JSON.stringify(updatedUser))// DeletesessionStorage.removeItem('user') sessionStorage、localStorage、cookie 都是在浏览器端存储的数据。 其中，sessionStorage 的概念很特别，引入了一个“浏览器窗口”的概念，sessionStorage 是在同源的同窗口中，始终存在的数据，也就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一个页面，数据仍然存在，关闭窗口后 sessionStorage 就会被销毁，同时“独立”打开的不同窗口，即使同一页面，sessionStorage 对象也是不同的。 客户端存储方式异同cookie，sessionStorage 和 localStorage 的区别？ cookie 是网站为了标示用户身份而储存在用户本地终端（Client Side）上 的数据（通常经过加密）- cookie 数据始终在同源的 http 请求中携带（即使不需要），记会在浏 览器和服务器间来回传递 sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地 保存 存储大小： cookie 数据大小不能超过 4k sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大 有效期（生命周期）： localStorage: 存储持久数据，浏览器关闭后数据不丢失，除非主动删除数据 sessionStorage: 数据在当前浏览器窗口关闭后自动删除 cookie: 设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭 参考资料 自己博客项目中什么是 cookie COOKIE 和 SESSION 有什么区别？ 浅谈 cookie，sessionStorage，localStorage","categories":[{"name":"网络知识","slug":"网络知识","permalink":"https://www.yangtao.site/categories/网络知识/"}],"tags":[{"name":"http","slug":"http","permalink":"https://www.yangtao.site/tags/http/"},{"name":"web","slug":"web","permalink":"https://www.yangtao.site/tags/web/"},{"name":"cookie","slug":"cookie","permalink":"https://www.yangtao.site/tags/cookie/"}]},{"title":"Understanding JavaScript Bind ()","slug":"js-bind","date":"2020-03-16T09:09:08.000Z","updated":"2020-03-16T11:04:08.368Z","comments":true,"path":"2020/03/16/js-bind/","link":"","permalink":"https://www.yangtao.site/2020/03/16/js-bind/","excerpt":"如何将“this”的上下文保留在另一个函数中？我们可能会需要使用Function.prototype.bind()。资料地址：Understanding JavaScript Bind ()","text":"如何将“this”的上下文保留在另一个函数中？我们可能会需要使用Function.prototype.bind()。资料地址：Understanding JavaScript Bind ()","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/tags/JavaScript/"}]},{"title":"React 设计思想【转载】","slug":"react-design-ideass","date":"2020-03-16T03:24:11.000Z","updated":"2020-03-16T03:28:38.441Z","comments":true,"path":"2020/03/16/react-design-ideass/","link":"","permalink":"https://www.yangtao.site/2020/03/16/react-design-ideass/","excerpt":"译者序：本文是 React 核心开发者、有 React API 终结者之称的 Sebastian Markbåge 撰写，阐述了他设计 React 的初衷。阅读此文，你能站在更高的高度思考 React 的过去、现在和未来。原文地址：https://github.com/reactjs/react-basic","text":"译者序：本文是 React 核心开发者、有 React API 终结者之称的 Sebastian Markbåge 撰写，阐述了他设计 React 的初衷。阅读此文，你能站在更高的高度思考 React 的过去、现在和未来。原文地址：https://github.com/reactjs/react-basic 我写此文是想正式地阐述我心中 React 的心智模型。目的是解释为什么我们会这样设计 React，同时你也可以根据这些论点反推出 React。 不可否认，此文中的部分论据或前提尚存争议，而且部分示例的设计可能存在 bug 或疏忽。这只是正式确定它的最初阶段。如果你有更好的完善它的想法可以随时提交 pull request。本文不会介绍框架细节中的奇技淫巧，相信这样能提纲挈领，让你看清 React 由简单到复杂的设计过程。 React.js 的真实实现中充满了具体问题的解决方案，渐进式的解法，算法优化，历史遗留代码，debug 工具以及其他一些可以让它真的具有高可用性的内容。这些代码可能并不稳定，因为未来浏览器的变化和功能权重的变化随时面临改变。所以具体的代码很难彻底解释清楚。 我偏向于选择一种我能完全 hold 住的简洁的心智模型来作介绍。 变换（Transformation）设计 React 的核心前提是认为 UI 只是把数据通过映射关系变换成另一种形式的数据。同样的输入必会有同样的输出。这恰好就是纯函数。 123function NameBox(name) &#123; return &#123; fontWeight: \"bold\", labelContent: name &#125;;&#125; 12&apos;Sebastian Markbåge&apos; -&gt;&#123; fontWeight: &apos;bold&apos;, labelContent: &apos;Sebastian Markbåge&apos; &#125;; 抽象（Abstraction）你不可能仅用一个函数就能实现复杂的 UI。重要的是，你需要把 UI 抽象成多个隐藏内部细节，又可复用的函数。通过在一个函数中调用另一个函数来实现复杂的 UI，这就是抽象。 123456function FancyUserBox(user) &#123; return &#123; borderStyle: \"1px solid blue\", childContent: [\"Name: \", NameBox(user.firstName + \" \" + user.lastName)] &#125;;&#125; 12345678&#123; firstName: &apos;Sebastian&apos;, lastName: &apos;Markbåge&apos; &#125; -&gt;&#123; borderStyle: &apos;1px solid blue&apos;, childContent: [ &apos;Name: &apos;, &#123; fontWeight: &apos;bold&apos;, labelContent: &apos;Sebastian Markbåge&apos; &#125; ]&#125;; 组合（Composition）为了真正达到重用的特性，只重用叶子然后每次都为他们创建一个新的容器是不够的。你还需要可以包含其他抽象的容器再次进行组合。我理解的“组合”就是将两个或者多个不同的抽象合并为一个。 12345678910function FancyBox(children) &#123; return &#123; borderStyle: \"1px solid blue\", children: children &#125;;&#125;function UserBox(user) &#123; return FancyBox([\"Name: \", NameBox(user.firstName + \" \" + user.lastName)]);&#125; 状态（State）UI 不单单是对服务器端或业务逻辑状态的复制。实际上还有很多状态是针对具体的渲染目标。举个例子，在一个 text field 中打字。它不一定要复制到其他页面或者你的手机设备。滚动位置这个状态是一个典型的你几乎不会复制到多个渲染目标的。 我们倾向于使用不可变的数据模型。我们把可以改变 state 的函数串联起来作为原点放置在顶层。 12345678910111213141516171819202122232425function FancyNameBox(user, likes, onClick) &#123; return FancyBox([ \"Name: \", NameBox(user.firstName + \" \" + user.lastName), \"Likes: \", LikeBox(likes), LikeButton(onClick) ]);&#125;// 实现细节var likes = 0;function addOneMoreLike() &#123; likes++; rerender();&#125;// 初始化FancyNameBox( &#123; firstName: \"Sebastian\", lastName: \"Markbåge\" &#125;, likes, addOneMoreLike); 注意：本例更新状态时会带来副作用（addOneMoreLike 函数中）。我实际的想法是当一个“update”传入时我们返回下一个版本的状态，但那样会比较复杂。此示例待更新 Memoization对于纯函数，使用相同的参数一次次调用未免太浪费资源。我们可以创建一个函数的 memorized 版本，用来追踪最后一个参数和结果。这样如果我们继续使用同样的值，就不需要反复执行它了。 1234567891011121314151617181920212223function memoize(fn) &#123; var cachedArg; var cachedResult; return function(arg) &#123; if (cachedArg === arg) &#123; return cachedResult; &#125; cachedArg = arg; cachedResult = fn(arg); return cachedResult; &#125;;&#125;var MemoizedNameBox = memoize(NameBox);function NameAndAgeBox(user, currentTime) &#123; return FancyBox([ \"Name: \", MemoizedNameBox(user.firstName + \" \" + user.lastName), \"Age in milliseconds: \", currentTime - user.dateOfBirth ]);&#125; 列表（Lists）大部分 UI 都是展示列表数据中不同 item 的列表结构。这是一个天然的层级。 为了管理列表中的每一个 item 的 state ，我们可以创造一个 Map 容纳具体 item 的 state。 123456789101112131415function UserList(users, likesPerUser, updateUserLikes) &#123; return users.map(user =&gt; FancyNameBox(user, likesPerUser.get(user.id), () =&gt; updateUserLikes(user.id, likesPerUser.get(user.id) + 1) ) );&#125;var likesPerUser = new Map();function updateUserLikes(id, likeCount) &#123; likesPerUser.set(id, likeCount); rerender();&#125;UserList(data.users, likesPerUser, updateUserLikes); 注意：现在我们向 FancyNameBox 传了多个不同的参数。这打破了我们的 memoization 因为我们每次只能存储一个值。更多相关内容在下面。 连续性（Continuations）不幸的是，自从 UI 中有太多的列表，明确的管理就需要大量的重复性样板代码。 我们可以通过推迟一些函数的执行，进而把一些模板移出业务逻辑。比如，使用“柯里化”（JavaScript 中的 bind）。然后我们可以从核心的函数外面传递 state，这样就没有样板代码了。 下面这样并没有减少样板代码，但至少把它从关键业务逻辑中剥离。 12345678910function FancyUserList(users) &#123; return FancyBox(UserList.bind(null, users));&#125;const box = FancyUserList(data.users);const resolvedChildren = box.children(likesPerUser, updateUserLikes);const resolvedBox = &#123; ...box, children: resolvedChildren&#125;; State Map之前我们知道可以使用组合避免重复执行相同的东西这样一种重复模式。我们可以把执行和传递 state 逻辑挪动到被复用很多的低层级的函数中去。 12345678910111213141516171819202122232425262728function FancyBoxWithState( children, stateMap, updateState) &#123; return FancyBox( children.map(child =&gt; child.continuation( stateMap.get(child.key), updateState )) );&#125;function UserList(users) &#123; return users.map(user =&gt; &#123; continuation: FancyNameBox.bind(null, user), key: user.id &#125;);&#125;function FancyUserList(users) &#123; return FancyBoxWithState.bind(null, UserList(users) );&#125;const continuation = FancyUserList(data.users);continuation(likesPerUser, updateUserLikes); Memoization Map一旦我们想在一个 memoization 列表中 memoize 多个 item 就会变得很困难。因为你需要制定复杂的缓存算法来平衡调用频率和内存占有率。 还好 UI 在同一个位置会相对的稳定。相同的位置一般每次都会接受相同的参数。这样以来，使用一个集合来做 memoization 是一个非常好用的策略。 我们可以用对待 state 同样的方式，在组合的函数中传递一个 memoization 缓存。 12345678910111213141516171819202122232425function memoize(fn) &#123; return function(arg, memoizationCache) &#123; if (memoizationCache.arg === arg) &#123; return memoizationCache.result; &#125; const result = fn(arg); memoizationCache.arg = arg; memoizationCache.result = result; return result; &#125;;&#125;function FancyBoxWithState(children, stateMap, updateState, memoizationCache) &#123; return FancyBox( children.map(child =&gt; child.continuation( stateMap.get(child.key), updateState, memoizationCache.get(child.key) ) ) );&#125;const MemoizedFancyNameBox = memoize(FancyNameBox); 代数效应（Algebraic Effects）多层抽象需要共享琐碎数据时，一层层传递数据非常麻烦。如果能有一种方式可以在多层抽象中快捷地传递数据，同时又不需要牵涉到中间层级，那该有多好。React 中我们把它叫做“context”。 有时候数据依赖并不是严格按照抽象树自上而下进行。举个例子，在布局算法中，你需要在实现他们的位置之前了解子节点的大小。 现在，这个例子有一点超纲。我会使用 代数效应 这个由我发起的 ECMAScript 新特性提议。如果你对函数式编程很熟悉，它们 在避免由 monad 强制引入的仪式一样的编码。 123456789101112131415161718192021222324function ThemeBorderColorRequest() &#123; &#125;function FancyBox(children) &#123; const color = raise new ThemeBorderColorRequest(); return &#123; borderWidth: '1px', borderColor: color, children: children &#125;;&#125;function BlueTheme(children) &#123; return try &#123; children(); &#125; catch effect ThemeBorderColorRequest -&gt; [, continuation] &#123; continuation('blue'); &#125;&#125;function App(data) &#123; return BlueTheme( FancyUserList.bind(null, data.users) );&#125; 原文地址：React 设计思想","categories":[{"name":"前端框架","slug":"前端框架","permalink":"https://www.yangtao.site/categories/前端框架/"}],"tags":[{"name":"react","slug":"react","permalink":"https://www.yangtao.site/tags/react/"}]},{"title":"Gulp 自动化构建","slug":"gulp-v4","date":"2020-03-14T04:18:36.000Z","updated":"2020-03-14T04:25:07.814Z","comments":true,"path":"2020/03/14/gulp-v4/","link":"","permalink":"https://www.yangtao.site/2020/03/14/gulp-v4/","excerpt":"Gulp 自动化构建的一些过程，以及其他插件的结合使用等","text":"Gulp 自动化构建的一些过程，以及其他插件的结合使用等 起步 Gulp 快速入门指南 Github Demo 导出项目根目录创建gulpfile.js: 123456function defaultTask(cb) &#123; console.log(\"success\"); cb();&#125;exports.default = defaultTask; gulp 命令： 12345➜ gulp-project git:(master) ✗ gulp[17:06:29] Using gulpfile ~/Documents/GitHub/gulp-project/gulpfile.js[17:06:29] Starting 'default'...success[17:06:29] Finished 'default' after 2.67 ms Gulpfile 分割 Node 的模块解析功能允许你将 gulpfile.js’ 文件替换为同样命名为 gulpfile.js 的目录，该目录中包含了一个名为 index.js 的文件，该文件被当作 gulpfile.js 使用。并且，该目录中还可以包含各个独立的任务（task）模块。 — 官方文档 创建 gulpfile.js目录，gulpfile.js目录下新建 index.js 组合任务 series() 允许将多个独立的任务组合为一个更大的操作 对于希望以最大并发来运行的任务（tasks），可以使用 parallel() 方法将它们组合起来 12345678910111213141516171819202122232425262728293031323334353637383940const &#123; series, parallel &#125; = require(\"gulp\");function clean(cb) &#123; cb();&#125;function cssTranspile(cb) &#123; cb();&#125;function cssMinify(cb) &#123; cb();&#125;function jsTranspile(cb) &#123; cb();&#125;function jsBundle(cb) &#123; cb();&#125;function jsMinify(cb) &#123; cb();&#125;function publish(cb) &#123; cb();&#125;function build(cb) &#123; cb();&#125;exports.default = series( clean, parallel(cssTranspile, series(jsTranspile, jsBundle)), parallel(cssMinify, jsMinify), publish); 输出： 12345678910111213141516[16:50:36] Starting 'default'...[16:50:36] Starting 'clean'...[16:50:36] Finished 'clean' after 606 μs[16:50:36] Starting 'cssTranspile'...[16:50:36] Finished 'cssTranspile' after 199 μs[16:50:36] Starting 'jsTranspile'...[16:50:36] Finished 'jsTranspile' after 131 μs[16:50:36] Starting 'jsBundle'...[16:50:36] Finished 'jsBundle' after 125 μs[16:50:36] Starting 'cssMinify'...[16:50:36] Starting 'jsMinify'...[16:50:36] Finished 'cssMinify' after 183 μs[16:50:36] Finished 'jsMinify' after 218 μs[16:50:36] Starting 'publish'...[16:50:36] Finished 'publish' after 115 μs[16:50:36] Finished 'default' after 4.55 ms 当一个组合操作执行时，这个组合中的每一个任务每次被调用时都会被执行。 12345678910111213141516171819// This is INCORRECTconst &#123; series, parallel &#125; = require(\"gulp\");const clean = function(cb) &#123; // body omitted cb();&#125;;const css = series(clean, function(cb) &#123; // body omitted cb();&#125;);const javascript = series(clean, function(cb) &#123; // body omitted cb();&#125;);exports.default = parallel(css, javascript); 输出： 12345678910[17:02:45] Starting 'default'...[17:02:45] Starting 'clean'...[17:02:45] Starting 'clean'...[17:02:45] Finished 'clean' after 850 μs[17:02:45] Starting '&lt;anonymous&gt;'...[17:02:45] Finished 'clean' after 2.04 ms[17:02:45] Starting '&lt;anonymous&gt;'...[17:02:45] Finished '&lt;anonymous&gt;' after 563 μs[17:02:45] Finished '&lt;anonymous&gt;' after 438 μs[17:02:45] Finished 'default' after 7.67 ms 重构： 12345678910111213141516171819// This is INCORRECTconst &#123; series, parallel &#125; = require(\"gulp\");const clean = function(cb) &#123; // body omitted cb();&#125;;const css = function(cb) &#123; // body omitted cb();&#125;;const javascript = function(cb) &#123; // body omitted cb();&#125;;exports.default = series(clean, parallel(css, javascript)); 再次输出： 12345678[17:04:48] Starting 'default'...[17:04:48] Starting 'clean'...[17:04:48] Finished 'clean' after 546 μs[17:04:48] Starting 'css'...[17:04:48] Starting 'javascript'...[17:04:48] Finished 'css' after 242 μs[17:04:48] Finished 'javascript' after 285 μs[17:04:48] Finished 'default' after 3.4 ms 异步执行 Node 库以多种方式处理异步功能。最常见的模式是 error-first callbacks，但是你还可能会遇到 streams、promises、event emitters、child processes, 或 observables。gulp 任务（task）规范化了所有这些类型的异步功能。 — 官方文档 返回 stream 1234567const &#123; src, dest &#125; = require(\"gulp\");function streamTask() &#123; return src(\"*.js\").pipe(dest(\"output\"));&#125;exports.default = streamTask; 然后发现，根目录下会看到 output 目录，及根目录下所有以 *js结尾的文件，包括目录。 返回 promise 12345function promiseTask() &#123; return Promise.resolve(\"the value is ignored\");&#125;exports.default = promiseTask; 返回 event emitter123456789const &#123; EventEmitter &#125; = require(\"events\");function eventEmitterTask() &#123; const emitter = new EventEmitter(); setTimeout(() =&gt; emitter.emit(\"finish\"), 250); return emitter;&#125;exports.default = eventEmitterTask; 使用 callback123456function callbackTask(cb) &#123; // `cb()` should be called by some async work cb();&#125;exports.default = callbackTask; 使用 async/await123456789const fs = require(\"fs\");async function asyncAwaitTask() &#123; const &#123; version &#125; = fs.readFileSync(\"package.json\"); console.log(\"version\"); await Promise.resolve(\"some result\");&#125;exports.default = asyncAwaitTask; 使用插件12345678910const &#123; src, dest &#125; = require(\"gulp\");const uglify = require(\"gulp-uglify\");const rename = require(\"gulp-rename\");exports.default = function() &#123; return src(\"src/assets/**/*.js\") .pipe(uglify()) .pipe(rename(&#123; extname: \".min.js\" &#125;)) .pipe(dest(\"output/\"));&#125;; browsersync Browsersync + Gulp.js 下载： 1npm install browser-sync gulp --save-dev 使用： 12345678910111213141516171819const &#123; task, watch &#125; = require(\"gulp\");const browserSync = require(\"browser-sync\").create();const reload = browserSync.reload;const serve = function(cb) &#123; browserSync.init(&#123; server: &#123; baseDir: \"./src\", https: true, directory: true //从与目录列表的应用程序目录中的文件即成 // index: \"index.html\" //从应用程序目录中提供文件，指定特定文件名为索引 &#125;, port: 8080, notify: false // 开启静默模式 &#125;); watch(\"src/*.html\").on(\"change\", reload);&#125;;task(serve); 本地使用： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061const &#123; src, dest, watch, series, parallel &#125; = require(\"gulp\");const uglify = require(\"gulp-uglify\");const rename = require(\"gulp-rename\");const browserSync = require(\"browser-sync\").create();const reload = browserSync.reload;const jsWatcher = watch(\"src/**/*.js\");const cssWatcher = watch(\"src/**/*.css\");const htmlWatcher = watch(\"src/**/*.html\");const clean = function(cb) &#123; // body omitted cb();&#125;;const css = function(cb) &#123; // body omitted cb();&#125;;const javascript = function(cb) &#123; // body omitted cb();&#125;;const serve = function(cb) &#123; browserSync.init(&#123; server: &#123; baseDir: \"./src\", // https: true, directory: true //从与目录列表的应用程序目录中的文件即成，如果要指定文件，可注释掉 // index: \"index.html\" //从应用程序目录中提供文件，指定特定文件名为索引 &#125;, port: 8080, notify: false // 开启静默模式 &#125;);&#125;;// 监听 globs 并在发生更改时运行任务jsWatcher.on(\"change\", function(path, stats) &#123; console.log(`File $&#123;path&#125; was changed`);&#125;);cssWatcher.on(\"change\", function(path, stats) &#123; console.log(`File $&#123;path&#125; was changed`);&#125;);htmlWatcher.on(\"change\", function(path, stats) &#123; console.log(`File $&#123;path&#125; was changed`); reload(); // Reloading Browsers&#125;);exports.build = function() &#123; return src(\"src/assets/**/*.js\") .pipe(uglify()) .pipe(rename(&#123; extname: \".min.js\" &#125;)) .pipe(dest(\"output/\"));&#125;;exports.serve = serve;exports.default = series(clean, parallel(css, javascript)); 然后在根目录下的package.json，修改： 12345\"scripts\": &#123; \"dev\": \"gulp\", \"build\": \"gulp build\", \"serve\": \"gulp serve\"&#125;, 启动： 1npm run serve Gulp + SASS-如何安装 Sass 1npm install node-sass gulp-sass --save-dev gulpfile.js 文件主要配置如下： 1234567891011const &#123; src, dest, watch &#125; = require(\"gulp\");const sass = require(\"gulp-sass\");sass.compiler = require(\"node-sass\");function scss() &#123; return src(scssGlobSrc) .pipe(sass(&#123; outputStyle: \"expanded\" &#125;).on(\"error\", sass.logError)) .pipe(dest(\"dist/sass\"));&#125;exports.scss = scss; 启动：gulp scss。 Gulp + Browsersync Browsersync + Gulp.js 下载： 1npm install browser-sync gulp --save-dev 使用： 1234567891011121314151617181920const &#123; task, watch &#125; = require(\"gulp\");const browserSync = require(\"browser-sync\").create();const reload = browserSync.reload;const serve = function(cb) &#123; browserSync.init(&#123; server: &#123; baseDir: \"./src\", https: true, directory: true //从与目录列表的应用程序目录中的文件即成 // index: \"index.html\" //从应用程序目录中提供文件，指定特定文件名为索引 &#125;, port: 8080, notify: false // 开启静默模式 &#125;); watch(\"src/*.html\").on(\"change\", reload);&#125;;exports.serve = serve; 运行： 1gulp serve Gulp + TypeScript根目录下初始化：tsc --init。 安装依赖： 1npm i -D typescript gulp-typescript 配置： 1234567891011const ts = require(\"gulp-typescript\");const tsProject = ts.createProject(\"tsconfig.json\");function typescript() &#123; return tsProject .src() .pipe(tsProject()) .js.pipe(dest(\"dist/ts\"));&#125;exports.typescript = typescript; src 目录下新建文件 main.ts： 1234567891011121314151617181920class Student &#123; fullName: string; constructor(public firstName: string, public lastName: string) &#123; this.fullName = `$&#123;firstName&#125; $&#123;lastName&#125; `; &#125;&#125;interface Person &#123; firstName: string; lastName: string;&#125;function greeter(person: Person) &#123; console.log(`hello, $&#123;person.firstName&#125; $&#123;person.lastName&#125;`);&#125;let user = new Student(\"Yang\", \"Tao\");greeter(user);console.log(user.fullName); 运行： 1gulp typescript Riot Riot.js 框架深入解析 riot.js 教程【一】简介 RIOT文档","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://www.yangtao.site/categories/开发工具/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"https://www.yangtao.site/tags/gulp/"}]},{"title":"Zepto-core-1.1.6 源码注释【转载】","slug":"zepto-v1.6.6","date":"2020-03-13T06:05:37.000Z","updated":"2020-03-16T04:05:11.179Z","comments":true,"path":"2020/03/13/zepto-v1.6.6/","link":"","permalink":"https://www.yangtao.site/2020/03/13/zepto-v1.6.6/","excerpt":"原文：zepto-core-1.1.6 源码注释","text":"原文：zepto-core-1.1.6 源码注释 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078107910801081108210831084108510861087108810891090109110921093109410951096109710981099110011011102110311041105110611071108110911101111111211131114111511161117111811191120112111221123112411251126112711281129113011311132113311341135113611371138113911401141114211431144114511461147114811491150115111521153115411551156115711581159116011611162116311641165116611671168116911701171117211731174117511761177117811791180118111821183118411851186118711881189119011911192119311941195119611971198119912001201120212031204120512061207120812091210121112121213121412151216121712181219122012211222122312241225122612271228122912301231123212331234123512361237123812391240124112421243124412451246124712481249125012511252125312541255125612571258125912601261126212631264126512661267126812691270127112721273127412751276127712781279128012811282128312841285128612871288128912901291129212931294129512961297129812991300130113021303130413051306130713081309131013111312131313141315131613171318131913201321132213231324132513261327132813291330133113321333133413351336133713381339134013411342134313441345134613471348134913501351135213531354135513561357135813591360136113621363136413651366136713681369137013711372137313741375137613771378137913801381138213831384138513861387138813891390139113921393139413951396139713981399140014011402140314041405140614071408140914101411141214131414141514161417141814191420142114221423142414251426142714281429143014311432143314341435143614371438143914401441144214431444144514461447144814491450145114521453145414551456145714581459146014611462146314641465146614671468146914701471147214731474147514761477147814791480148114821483148414851486148714881489149014911492149314941495149614971498149915001501150215031504150515061507150815091510151115121513151415151516151715181519152015211522152315241525152615271528152915301531153215331534153515361537153815391540154115421543154415451546154715481549155015511552155315541555155615571558155915601561156215631564156515661567156815691570157115721573157415751576157715781579158015811582158315841585158615871588158915901591159215931594159515961597159815991600160116021603160416051606160716081609161016111612161316141615161616171618161916201621162216231624162516261627162816291630163116321633163416351636163716381639164016411642164316441645164616471648164916501651165216531654165516561657165816591660166116621663166416651666166716681669167016711672167316741675167616771678167916801681168216831684168516861687168816891690169116921693169416951696169716981699170017011702170317041705170617071708170917101711171217131714171517161717171817191720172117221723172417251726172717281729173017311732173317341735173617371738173917401741174217431744174517461747174817491750175117521753175417551756175717581759176017611762176317641765176617671768176917701771177217731774177517761777177817791780178117821783178417851786178717881789179017911792179317941795179617971798179918001801180218031804180518061807180818091810181118121813181418151816181718181819182018211822182318241825182618271828182918301831183218331834183518361837183818391840184118421843184418451846184718481849185018511852185318541855185618571858185918601861186218631864/* Zepto v1.1.6 - zepto event ajax form ie - zeptojs.com/license */var Zepto = (function() &#123; var undefined, key, $, classList, // 获取数组的slice 和 filter（返回数组中的满足回调函数中指定的条件的元素）方法 emptyArray = [], slice = emptyArray.slice, filter = emptyArray.filter, document = window.document, elementDisplay = &#123;&#125;, classCache = &#123;&#125;, cssNumber = &#123; \"column-count\": 1, columns: 1, \"font-weight\": 1, \"line-height\": 1, opacity: 1, \"z-index\": 1, zoom: 1 &#125;, // 取出html代码中第一个html标签（或注释），如取出 &lt;p&gt;123&lt;/p&gt;&lt;h1&gt;345&lt;/h1&gt; 中的 &lt;p&gt; fragmentRE = /^\\s*&lt;(\\w+|!)[^&gt;]*&gt;/, // 匹配 &lt;img /&gt; &lt;p&gt;&lt;/p&gt; 不匹配 &lt;img src=\"\"/&gt; &lt;p&gt;123&lt;/p&gt; singleTagRE = /^&lt;(\\w+)\\s*\\/?&gt;(?:&lt;\\/\\1&gt;|)$/, // 单标签 tagExpanderRE = /&lt;(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^&gt;]*)\\/&gt;/gi, // body html rootNodeRE = /^(?:body|html)$/i, // 大写字母 capitalRE = /([A-Z])/g, // special attributes that should be get/set via method calls // 应该通过方法调用来设置/获取的特殊属性 methodAttributes = [ \"val\", \"css\", \"html\", \"text\", \"data\", \"width\", \"height\", \"offset\" ], adjacencyOperators = [\"after\", \"prepend\", \"before\", \"append\"], table = document.createElement(\"table\"), tableRow = document.createElement(\"tr\"), // 指定特殊元素的 容器 containers = &#123; tr: document.createElement(\"tbody\"), tbody: table, thead: table, tfoot: table, td: tableRow, th: tableRow, // 除了上面指定的，其他所有元素的容器都是 div \"*\": document.createElement(\"div\") &#125;, // interactive ？？？ readyRE = /complete|loaded|interactive/, // 匹配一个包括（字母、数组、下划线、-）的字符串 simpleSelectorRE = /^[\\w-]*$/, class2type = &#123;&#125;, toString = class2type.toString, zepto = &#123;&#125;, camelize, uniq, tempParent = document.createElement(\"div\"), // 属性转换为 camalCase 格式。 // $.fn.prop 方法用到了 propMap = &#123; tabindex: \"tabIndex\", readonly: \"readOnly\", for: \"htmlFor\", class: \"className\", maxlength: \"maxLength\", cellspacing: \"cellSpacing\", cellpadding: \"cellPadding\", rowspan: \"rowSpan\", colspan: \"colSpan\", usemap: \"useMap\", frameborder: \"frameBorder\", contenteditable: \"contentEditable\" &#125;, // 判断是否是arr的函数 isArray = Array.isArray || function(object) &#123; return object instanceof Array; &#125;; // 上文定义 zepto = &#123;&#125; // 判断 element 是否符合 selector 的选择要求 zepto.matches = function(element, selector) &#123; // selector有值，element有值，element是普通DOM节点 if (!selector || !element || element.nodeType !== 1) return false; // elem.matchesSelector('.item') // 判断当前的 elem 是否符合传入的 selector 的要求 var matchesSelector = element.webkitMatchesSelector || element.mozMatchesSelector || element.oMatchesSelector || element.matchesSelector; if (matchesSelector) return matchesSelector.call(element, selector); // 浏览器不支持 matchesSelector // fall back to performing a selector: var match, parent = element.parentNode, temp = !parent; // 上文定义 tempParent = document.createElement('div'), // 如果没有parent，parent赋值为一个div，然后将当前元素加入到这个div中 if (temp) &#123; parent = tempParent; tempParent.appendChild(element); // (parent = tempParent).appendChild(element); 这种写法不易读 &#125; // 通过 qsa 获取匹配的元素，判断其中有没有 element match = ~zepto.qsa(parent, selector).indexOf(element); if (temp) &#123; // 如果没有parent时，之前执行过 tempParent.appendChild(element); // 此时要移除子元素 tempParent.removeChild(element); &#125; // temp &amp;&amp; tempParent.removeChild(element) // 这种写法不易读 // 返回最终的匹配结果，经过 qsa 判断的结果 return match; &#125;; function type(obj) &#123; return obj == null ? String(obj) // null undefined : class2type[toString.call(obj)] || \"object\"; // 下文定义： // // Populate the class2type map // $.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function(i, name) &#123; // class2type[ \"[object \" + name + \"]\" ] = name.toLowerCase() // &#125;) &#125; function isFunction(value) &#123; return type(value) == \"function\"; &#125; // window的特点：window.window === window function isWindow(obj) &#123; return obj != null &amp;&amp; obj == obj.window; &#125; // document.nodeType === 9 // elem.DOCUMENT_NODE 也等于 9 （这里直接判断是不是9也行？？？） function isDocument(obj) &#123; return obj != null &amp;&amp; obj.nodeType == obj.DOCUMENT_NODE; &#125; function isObject(obj) &#123; return type(obj) == \"object\"; &#125; // 判断是否是最基本的object：Object.getPrototypeOf(obj) == Object.prototype function isPlainObject(obj) &#123; return ( isObject(obj) &amp;&amp; !isWindow(obj) &amp;&amp; Object.getPrototypeOf(obj) == Object.prototype ); &#125; // 数组或者对象数组 function likeArray(obj) &#123; return typeof obj.length == \"number\"; &#125; // 筛选数组，踢出 null undefined 元素 function compact(array) &#123; return filter.call(array, function(item) &#123; return item != null; &#125;); &#125; // 下文定义： // $.fn = &#123; // concat: emptyArray.concat, // $.fn.concat.apply([], array) —— 无论 array 是不是数组，都将返回一个数组， // 例如 $.fn.concat.call([], 'abc') 返回的是 ['abc'] function flatten(array) &#123; return array.length &gt; 0 ? $.fn.concat.apply([], array) : array; &#125; // camelize 已在上文定义 // 用于 css 的 camalCase 转换，例如 background-color 转换为 backgroundColor camelize = function(str) &#123; return str.replace(/-+(.)?/g, function(match, chr) &#123; return chr ? chr.toUpperCase() : \"\"; &#125;); &#125;; // 将 lineHeight 转换为 line-height 格式 function dasherize(str) &#123; return str .replace(/::/g, \"/\") .replace(/([A-Z]+)([A-Z][a-z])/g, \"$1_$2\") .replace(/([a-z\\d])([A-Z])/g, \"$1_$2\") .replace(/_/g, \"-\") .toLowerCase(); &#125; // uniq变量已经在前面定义 // 用来将 [1,1,2,2,3,3] 替换为 [1,2,3] uniq = function(array) &#123; return filter.call(array, function(item, idx) &#123; return array.indexOf(item) == idx; &#125;); &#125;; // 上文定义 classCache = &#123;&#125; function classRE(name) &#123; return name in classCache ? classCache[name] : (classCache[name] = new RegExp(\"(^|\\\\s)\" + name + \"(\\\\s|$)\")); // classCache 存储的数据是这样的： // &#123; // abc: /(^|\\s)abc(\\s|$)/, // 能匹配 'abc' 或 ' abc ' 或 ' abc' 或 'abc ' // xyz: /(^|\\s)abc(\\s|$)/, // ... // &#125; &#125; // 传入一个 css 的 name 和 value，判断这个 value 是否需要增加 'px' function maybeAddPx(name, value) &#123; // dasherize(name) 将 lineHeight 转换为 line-height 格式 // \\!cssNumber[dasherize(name)] 判断转换出来的 css name 是否再这个数组之外 return typeof value == \"number\" &amp;&amp; !cssNumber[dasherize(name)] ? // 如果 value 是数字，并且 name 不在 cssNumber 数组之内，就需要加 'px'，否则不需要 // 例如 'width'、'font-size' 就需要加 'px'， 'font-weight' 就不需要加 value + \"px\" : value; // 前文定义---------------------- // cssNumber = &#123; // 'column-count': 1, // 'columns': 1, // 'font-weight': 1, // 'line-height': 1, // 'opacity': 1, // 'z-index': 1, // 'zoom': 1 // &#125;, // function dasherize(str) &#123; // return str.replace(/::/g, '/') // .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2') // .replace(/([a-z\\d])([A-Z])/g, '$1_$2') // .replace(/_/g, '-') // .toLowerCase() // &#125; &#125; // 获取一个元素的默认 display 样式值，可能的结果是：inline block inline-block table .... （none 转换为 block） // $.fn.show 方法中用到了 function defaultDisplay(nodeName) &#123; var element, display; // 前文定义 elementDisplay = &#123;&#125; if (!elementDisplay[nodeName]) &#123; // 如果 elementDisplay 对象中，没有存储 nodeName 的信息 // 则新建一个 nodeName 元素，添加到 body 中 element = document.createElement(nodeName); document.body.appendChild(element); // 获取它的默认的 display 样式信息。 display = getComputedStyle(element, \"\").getPropertyValue(\"display\"); // 接着马上移除元素！！！ element.parentNode.removeChild(element); // 'none' 换成 'block'，另外还可能是 'inline' 'inline-block' 'table' 等等... display == \"none\" &amp;&amp; (display = \"block\"); // 存储下来 elementDisplay[nodeName] = display; // 下文定义 // var nativeGetComputedStyle = getComputedStyle; // window.getComputedStyle = function(element)&#123; // try &#123; // return nativeGetComputedStyle(element) // &#125; catch(e) &#123; // return null // &#125; // &#125; // 解释： // 如果浏览器支持 getComputedStyle 则使用，如果不支持，就返回 null // getComputedStyle(elem, '伪类，如 :link') 返回一个 CSSStyleDeclaration 对象，里面存储了元素的样式信息，可以通过 getPropertyValue('name') 方法获取 &#125; // 最终返回 display 结果 return elementDisplay[nodeName]; &#125; // 返回一个元素的子元素，数组形式 function children(element) &#123; // 有些浏览器支持 elem.children 获取子元素，有些不支持 return \"children\" in element ? // 上文定义 slice = [].slice // slice.call(likeArr) 可以将对象数组转换为真正的数组 slice.call(element.children) : // 浏览器不支持 elem.children 只能通过 elem.childNodes 获取子元素 // 只去 node.nodeType == 1 的子元素，通过 $.map 拼接成数组 // $.map 下文定义的， $.map = function (elements, callback) &#123;....&#125; // $.map 作用：针对 elements（对象数组或数组），对每个元素都经过 callback 函数的过滤，并将过滤通过的元素，push到一个新数组中，返回新数组 $.map(element.childNodes, function(node) &#123; if (node.nodeType == 1) return node; &#125;); &#125; // 上文定义 zepto = &#123;&#125; // 上文定义 zepto.matches = function(element, selector) &#123; /* 判断elem是否符合selector的要求 */ &#125; // `$.zepto.fragment` takes a html string and an optional tag name // to generate DOM nodes nodes from the given html string. // The generated DOM nodes are returned as an array. // This function can be overriden in plugins for example to make // it compatible with browsers that don't support the DOM fully. zepto.fragment = function(html, name, properties) &#123; /* 参数： @html: 待处理的html字符串 @name: 通过 name 可在 containers 中查找容器节点，如果不传入，取得的容器默认为 div @properties: 节点属性对象 */ var dom, nodes, container; // 上文定义：singleTagRE = /^&lt;(\\w+)\\s*\\/?&gt;(?:&lt;\\/\\1&gt;|)$/, // 匹配 &lt;img /&gt; &lt;p&gt;&lt;/p&gt; 不匹配 &lt;img src=\"\"/&gt; &lt;p&gt;123&lt;/p&gt; // 如果 html 是单标签，则直接用该标签创建元素 // RegExp.$1 表示正则中的第一个括号匹配的内容，在此即 (\\w+) 匹配的内容， // A special case optimization for a single tag if (singleTagRE.test(html)) dom = $(document.createElement(RegExp.$1)); if (!dom) &#123; // 说明 html 不是单标签，dom未被赋值 // 上文定义 tagExpanderRE = /&lt;(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^&gt;]*)\\/&gt;/ig, // 单标签 // 将 &lt;p/&gt;或&lt;p /&gt;，替换为 &lt;p&gt;&lt;/p&gt;，将&lt;p abc/&gt;替换为&lt;p&gt;abc&lt;/p&gt; // &lt;input/&gt; （在 tagExpanderRE 中定义）的不替换 if (html.replace) html = html.replace(tagExpanderRE, \"&lt;$1&gt;&lt;/$2&gt;\"); // fragmentRE = /^\\s*&lt;(\\w+|!)[^&gt;]*&gt;/, // 取出html代码中第一个html标签（或注释），如取出 &lt;p&gt;123&lt;/p&gt;&lt;h1&gt;345&lt;/h1&gt; 中的 &lt;p&gt; // 如果 name 未传入，则赋值为 html 的第一个标签 if (name === undefined) name = fragmentRE.test(html) &amp;&amp; RegExp.$1; // 上文定义 // 指定特殊元素的 容器 // containers = &#123; // 'tr': document.createElement('tbody'), // 'tbody': table, // 'thead': table, // 'tfoot': table, // 'td': tableRow, // 'th': tableRow, // 除了上面指定的，其他所有元素的容器都是 div // '*': document.createElement('div') // &#125;, if (!(name in containers)) name = \"*\"; container = containers[name]; container.innerHTML = \"\" + html; // 转变为字符串的快捷方式 // 遍历 container 的子元素（先转换为数组形式） // 返回的同时，将每个子元素移除。 // $.each 返回的是一个数组，因为第一个参数就是数组 slice.call(container.childNodes) dom = $.each(slice.call(container.childNodes), function() &#123; container.removeChild(this); &#125;); &#125; // 赋值属性 if (isPlainObject(properties)) &#123; // 先将dom转换为 zepto 对象 nodes = $(dom); $.each(properties, function(key, value) &#123; // 上文定义： // 应该通过方法调用来设置/获取的特殊属性 // methodAttributes = ['val', 'css', 'html', 'text', 'data', 'width', 'height', 'offset'], if (methodAttributes.indexOf(key) &gt; -1) nodes[key](value); // 满足 methodAttributes 的，通过方法赋值 else nodes.attr(key, value); // 否则，通过属性复制 &#125;); &#125; // 最终返回的dom可能有两种形式 // 第一，如果 html 是单标签，则dom被复制为一个zepto对象 dom = $(document.createElement(RegExp.$1)) // 第二，如果 html 不是单标签，则dom被复制为一个DOM节点的数组 return dom; &#125;; // 上文定义 zepto = &#123;&#125; // 上文定义 zepto.matches = function(element, selector) &#123; /* 判断elem是否符合selector的要求 */ &#125; // 上文定义 zepto.fragment = function(html, name, properties) &#123; /* 通过html字符串获取文档碎片 */ &#125; // `$.zepto.Z` swaps out the prototype of the given `dom` array // of nodes with `$.fn` and thus supplying all the Zepto functions // to the array. Note that `__proto__` is not supported on Internet // Explorer. This method can be overriden in plugins. zepto.Z = function(dom, selector) &#123; dom = dom || []; // 将 dom 隐式原型强制改为 $.fn // 下文 zepto.Z.prototype = $.fn 因此，dom.__proto__ = $.fn 即 dom.__proto__ = zepto.Z.prototype 可以不较真的认为 zepto.Z 就是一个构造函数（但感觉这么设计，有些蹩脚） dom.__proto__ = $.fn; dom.selector = selector || \"\"; return dom; &#125;; // `$.zepto.isZ` should return `true` if the given object is a Zepto // collection. This method can be overriden in plugins. zepto.isZ = function(object) &#123; // 上文 dom.__proto__ = $.fn // 下文 zepto.Z.prototype = $.fn // 可知：dom.__proto__ === $.fn === zepto.Z.prototype // 因此，zepto对象都符合 object instanceof zepto.Z return object instanceof zepto.Z; &#125;; // `$.zepto.init` is Zepto's counterpart to jQuery's `$.fn.init` and // takes a CSS selector and an optional context (and handles various // special cases). // This method can be overriden in plugins. zepto.init = function(selector, context) &#123; var dom; // If nothing given, return an empty Zepto collection if (!selector) return zepto.Z(); // Optimize for string selectors else if (typeof selector == \"string\") &#123; // 字符串的情况，一般有两种： // 第一，一段 html 代码，旨在通过zepto生成dom对象 // 第二，一段查询字符串，旨在通过zepto查找dom对象 // 将查询结果存储到 dom 变量中 selector = selector.trim(); // If it's a html fragment, create nodes from it // Note: In both Chrome 21 and Firefox 15, DOM error 12 // is thrown if the fragment doesn't begin with &lt; // 上文定义： // 取出html代码中第一个html标签（或注释），如取出 &lt;p&gt;123&lt;/p&gt;&lt;h1&gt;345&lt;/h1&gt; 中的 &lt;p&gt; // fragmentRE = /^\\s*&lt;(\\w+|!)[^&gt;]*&gt;/, if (selector[0] == \"&lt;\" &amp;&amp; fragmentRE.test(selector)) // 第一，RegExp.$1取出来的就是第一个标签名称，即正则中 (\\w+|!) 对应的内容 // 第二，此时的 context 应该传入的是css属性对象（这里会产生歧义，老版的不会传入 context） (dom = zepto.fragment(selector, RegExp.$1, context)), (selector = null); // If there's a context, create a collection on that context first, and select // nodes from there // 如果 selector 不是html字符串标签，并且 context 有值，则从context中查找 // find 应该是在 $.fn 中定义的，有待解读？？？ else if (context !== undefined) return $(context).find(selector); // If it's a CSS selector, use it to select nodes. // 除了以上情况，就从整个 document 执行 qsa 的查找 else dom = zepto.qsa(document, selector); &#125; // If a function is given, call it when the DOM is ready // 如果是函数，则dom ready时执行， // ready方法应该在 $.fn 中定义，有待解毒 else if (isFunction(selector)) return $(document).ready(selector); // If a Zepto collection is given, just return it // 传入的参数本身就已经是 zepto 对象，则直接返回 else if (zepto.isZ(selector)) return selector; else &#123; // compact函数：踢出数组中 == null 的元素 // normalize array if an array of nodes is given if (isArray(selector)) dom = compact(selector); // 如果传入的是object，直接强制塞进一个数组 // Wrap DOM nodes. else if (isObject(selector)) (dom = [selector]), (selector = null); // 及时清空 selector 不妨碍下面的判断 // 从此往下，感觉和上文 selector 是字符串的情况下，重复了 // ？？？？？？？？ // fragmentRE.test 即判断字符串是否是 html 标签开头（即是否是html fragement） // If it's a html fragment, create nodes from it else if (fragmentRE.test(selector)) //此时，context 也是属性集合，不是容器！！！ //（这里会产生歧义，老版的不会传入 context） (dom = zepto.fragment(selector.trim(), RegExp.$1, context)), (selector = null); // 及时清空 selector 不妨碍下面的判断 // If there's a context, create a collection on that context first, and select // nodes from there else if (context !== undefined) return $(context).find(selector); // And last but no least, if it's a CSS selector, use it to select nodes. else dom = zepto.qsa(document, selector); &#125; // 最终，还是通过 zepto.Z 创建了对象 // 这里的 dom，其实就是一个数组 // create a new Zepto collection from the nodes found return zepto.Z(dom, selector); &#125;; // `$` will be the base `Zepto` object. When calling this // function just call `$.zepto.init, which makes the implementation // details of selecting nodes and creating Zepto collections // patchable in plugins. $ = function(selector, context) &#123; return zepto.init(selector, context); &#125;; // $ 最终被这个匿名函数所返回，并复制给了全局的 Zepto 变量 // 全局的 zepto 变量暴露给了 window，并且可能有一个别名—— $ // 此 $ 非彼 $ // 对于初学者来说，这里肯定非常绕（还不如把这里的 $ 改改名字） function extend(target, source, deep) &#123; // key 在上文已经定义，否则就污染全局变量了 // 深度递归，首先必须 deep 参数为 true // 其次，source[key] 必须是数组或者对象，才有必要深度递归（否则没必要） for (key in source) if (deep &amp;&amp; (isPlainObject(source[key]) || isArray(source[key]))) &#123; // source[key] 是对象，而 target[key] 不是对象 // 则 target[key] = &#123;&#125; 初始化一下，否则递归会出错的 if (isPlainObject(source[key]) &amp;&amp; !isPlainObject(target[key])) target[key] = &#123;&#125;; // source[key] 是数组，而 target[key] 不是数组 // 则 target[key] = [] 初始化一下，否则递归会出错的 if (isArray(source[key]) &amp;&amp; !isArray(target[key])) target[key] = []; // 执行递归 extend(target[key], source[key], deep); &#125; // 不满足以上条件，说明 source[key] 是一般的值类型，直接赋值给 target 就是了 else if (source[key] !== undefined) target[key] = source[key]; &#125; // Copy all but undefined properties from one or more // objects to the `target` object. $.extend = function(target) &#123; // 一般传入的参数会是： // (targetObj, srcObj1, srcObj2, srcObj1...) // (true, targetObj, srcObj1, srcObj2, srcObj1...) // arguments 是对象数组，slice.call 会返回真正的数组（此处返回从第二项开始） var deep, args = slice.call(arguments, 1); // 第一个参数是boolean，这里会把第二个参数当做 target，其他的作为 source if (typeof target == \"boolean\") &#123; deep = target; target = args.shift(); &#125; // 将所有的 source 添加到 target 中 args.forEach(function(arg) &#123; extend(target, arg, deep); &#125;); return target; // 感觉这样设计是比较好，很好的将业务和底层进行了分离（虽然比较简单）： // 核心方法再 function extend(...)&#123;...&#125; 中定义， // 而 $.extend 方法中做一些外围的判断和处理，最终调用 extend 函数去执行 &#125;; // `$.zepto.qsa` is Zepto's CSS selector implementation which // uses `document.querySelectorAll` and optimizes for some special cases, like `#id`. // This method can be overriden in plugins. zepto.qsa = function(element, selector) &#123; /* @element: 容器 @selector: 选择器 */ var found, maybeID = selector[0] == \"#\", maybeClass = !maybeID &amp;&amp; selector[0] == \".\", // ID或class形式：返回 selector.slice(1) 即ID或者class的值 // 否则：返回 selector，如通过 tagName 查询 nameOnly = maybeID || maybeClass ? selector.slice(1) : selector, // Ensure that a 1 char tag name still gets checked // 是否是一个简单的字符串（可能是一个复杂的选择器，如 'div#div1 .item[link] .red'） isSimple = simpleSelectorRE.test(nameOnly); // 上文定义： // // 匹配一个包括（字母、数组、下划线、-）的字符串 // simpleSelectorRE = /^[\\w-]*$/, // 以下代码的基本思路是： // 1. 优先通过 ID 获取元素； // 2. 然后试图通过 className 和 tagName 获取元素 // 3. 最后通过 querySelectorAll 来获取 return isDocument(element) &amp;&amp; isSimple &amp;&amp; maybeID ? // 这是最简单的形式：容器是document、选择器是一个id // 因为 getElementById 只能在 document 上用，所以这里单独拿出来 (found = element.getElementById(nameOnly)) ? [found] : [] : element.nodeType !== 1 &amp;&amp; element.nodeType !== 9 ? // 容器不是一般元素，也不是document，直接返回 [] [] : // 将获取的所有元素集合，都转换为数组 slice.call( isSimple &amp;&amp; !maybeID ? // isSimple情况下，nameOnly 只可能是 className 或者 tagName // getElementsByClassName 和 getElementsByTagName 可以在 elem 上用，而且比 querySelectorAll 速度快 // 所以，只要elem容器有值，尽量单独拿出来处理 maybeClass ? element.getElementsByClassName(nameOnly) // If it's simple, it could be a class : element.getElementsByTagName(selector) // Or a tag : // 最后其他情况，只能通过 querySelectorAll 来处理 element.querySelectorAll(selector) // Or it's not simple, and we need to query all ); &#125;; // 根据 selector 筛选 nodes // 并将 nodes 封装为 zepto 对象 // $.fn.filter 下文定义 function filtered(nodes, selector) &#123; return selector == null ? $(nodes) : $(nodes).filter(selector); &#125; // 判断 parent 是否包含 node $.contains = document.documentElement.contains ? // 浏览器支持 contains 方法 function(parent, node) &#123; return parent !== node &amp;&amp; parent.contains(node); &#125; : // 不支持 contains 方法 function(parent, node) &#123; while (node &amp;&amp; (node = node.parentNode)) if (node === parent) return true; return false; &#125;; // 如果 arg 是函数，则改变函数的执行环境和参数 // 如果不是，直接返回 arg // $.fn.html 方法就用到了 function funcArg(context, arg, idx, payload) &#123; return isFunction(arg) ? arg.call(context, idx, payload) : arg; &#125; // 设置属性 function setAttribute(node, name, value) &#123; value == null ? node.removeAttribute(name) : node.setAttribute(name, value); &#125; // 设置或获取 node 的 className // 考虑 svg ？？？？ // access className property while respecting SVGAnimatedString function className(node, value) &#123; var klass = node.className || \"\", svg = klass &amp;&amp; klass.baseVal !== undefined; // 获取 if (value === undefined) return svg ? klass.baseVal : klass; // 设置 svg ? (klass.baseVal = value) : (node.className = value); &#125; // 将字符串变成响应的对象或者值，例如源代码的注释： // \"true\" =&gt; true // \"false\" =&gt; false // \"null\" =&gt; null // \"42\" =&gt; 42 // \"42.5\" =&gt; 42.5 // \"08\" =&gt; \"08\" // JSON =&gt; parse if valid // String =&gt; self function deserializeValue(value) &#123; try &#123; return value ? // value『有值』的情况： value == \"true\" || // 如果 value == 'true'，那么这个表达式本身就返回 true ，导致整个函数返回true // value !== 'true' 的情况： (value == \"false\" ? false // \"null\" =&gt; null : value == \"null\" ? null // \"null\" =&gt; null : +value + \"\" == value ? +value // 数字：\"42\" =&gt; 42 \"42.5\" =&gt; 42.5 （ 但是 '08' 却不符合这个条件 ） : /^[\\[\\&#123;]/.test(value) ? $.parseJSON(value) // '[...]' 或者 '&#123;...&#125;' : value) // 其他 : // value『无值』的情况： undefined / '' / flase / 0 / null value; &#125; catch (e) &#123; return value; &#125; &#125; // 将上文定义的函数，暴露给 $ 对象（其实 $ 是一个 function） $.type = type; $.isFunction = isFunction; $.isWindow = isWindow; $.isArray = isArray; $.isPlainObject = isPlainObject; $.isEmptyObject = function(obj) &#123; var name; for (name in obj) return false; return true; &#125;; $.inArray = function(elem, array, i) &#123; return emptyArray.indexOf.call(array, elem, i); &#125;; $.camelCase = camelize; $.trim = function(str) &#123; return str == null ? \"\" : String.prototype.trim.call(str); &#125;; // plugin compatibility $.uuid = 0; $.support = &#123;&#125;; $.expr = &#123;&#125;; // 重新组织 elements 对象（数组、对象或者对象数组），针对每一个元素，都用 callback 进行检验 // 检验通过后，将元素push进一个新数组，并返回 $.map = function(elements, callback) &#123; var value, values = [], i, key; // 数组，或者对象数组 if (likeArray(elements)) for (i = 0; i &lt; elements.length; i++) &#123; // 遍历，经过 callback 验证，push到结果中 value = callback(elements[i], i); if (value != null) values.push(value); &#125; // 对象 else for (key in elements) &#123; // 遍历，经过 callback 验证，push到结果中 value = callback(elements[key], key); if (value != null) values.push(value); &#125; // 返回数组 // flatten 函数上文定义的，作用：无论 values 是否是数组，都将返回一个正确的数组。例如，传入 'abc' ，返回 ['abc'] return flatten(values); &#125;; // 遍历 elements 所有元素（数组、对象数组、对象），执行 callback 方法，最终还是返回 elements // 注意1：callback.call(elements[i], i, elements[i]) 函数执行的环境和参数 // 注意2：=== false) return elements 一旦有函数返回 false，即跳出循环，类似 break // 注意3：无论哪种情况，最终返回的还是 elements $.each = function(elements, callback) &#123; var i, key; if (likeArray(elements)) &#123; for (i = 0; i &lt; elements.length; i++) if (callback.call(elements[i], i, elements[i]) === false) return elements; &#125; else &#123; for (key in elements) if (callback.call(elements[key], key, elements[key]) === false) return elements; &#125; return elements; &#125;; // 上文定义：filter = emptyArray.filter // 筛选数组 $.grep = function(elements, callback) &#123; return filter.call(elements, callback); &#125;; if (window.JSON) $.parseJSON = JSON.parse; // Populate the class2type map $.each( \"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function(i, name) &#123; class2type[\"[object \" + name + \"]\"] = name.toLowerCase(); /* 上文将 class2type 赋值为 &#123;&#125; 最终将 class2type 赋值为： &#123; '[object boolean]': 'boolean', '[object number]': 'number', '[object string]': 'string', ... &#125; 存储这个数据是为了方便的获取一些对象的类型， 例如 Object.prototype.toString.call([]) 返回的是 '[Object Array]' 那么即可根据这个获取 [] 的类型是 'array' */ &#125; ); // Define methods that will be available on all // Zepto collections $.fn = &#123; // 为何要这么多数组的方法？ // 因为一个 zepto 对象，本身就是一个数组 // Because a collection acts like an array // copy over these useful array functions. forEach: emptyArray.forEach, reduce: emptyArray.reduce, // 方法何用？？？？ push: emptyArray.push, sort: emptyArray.sort, indexOf: emptyArray.indexOf, concat: emptyArray.concat, // `map` and `slice` in the jQuery API work differently // from their array counterparts map: function(fn) &#123; // $.map 上文定义的， $.map = function (elements, callback) &#123;....&#125; // $.map 作用：针对 elements（对象、对象数组或数组），对每个元素都经过 callback 函数的过滤，并将过滤通过的元素，push到一个新数组中，返回新数组 // 最后，用 $ 封装返回 return $( // $.map 返回的是一个数组 $.map( this, // 针对每一个元素，都执行传入的函数，如果函数返回的 !=null 就将插入到新返回的数组 function(el, i) &#123; return fn.call(el, i, el); &#125; ) ); /* $('div').map(function(key, value)&#123; return value.id; // 或者 return this.id; &#125;) 这个结果就是 $(['div1', 'div2' ...]) */ &#125;, slice: function() &#123; // 直接数组的slice方法，并将结果用 $ 封装返回 return $(slice.apply(this, arguments)); &#125;, // 在 zepto.init 函数中，当传入的函数是函数时，就用到了 ready // else if (isFunction(selector)) return $(document).ready(selector) ready: function(callback) &#123; // need to check if document.body exists for IE as that browser reports // document ready when it hasn't yet created the body element // 下文定义：readyRE = /complete|loaded|interactive/, if (readyRE.test(document.readyState) &amp;&amp; document.body) callback($); else document.addEventListener( \"DOMContentLoaded\", function() &#123; callback($); &#125;, false ); // 返回当前对象 return this; &#125;, get: function(idx) &#123; return idx === undefined ? slice.call(this) // 未传参数，直接返回一整个数组 : // 有参数，则试图返回单个元素（大于0，小于0 两种情况） this[idx &gt;= 0 ? idx : idx + this.length]; &#125;, // 将zepto集合变为纯数组 toArray: function() &#123; return this.get(); &#125;, size: function() &#123; return this.length; &#125;, // 将元素从这个DOM树中移除 remove: function() &#123; return this.each(function() &#123; if (this.parentNode != null) this.parentNode.removeChild(this); &#125;); &#125;, each: function(callback) &#123; // [].every ES5中Array的新特性。循环数组每个元素，返回是否符合callback函数的要求 // every 函数返回的是 false 或者 true（不过这里返回什么无所谓，执行就可以了） emptyArray.every.call(this, function(el, idx) &#123; return callback.call(el, idx, el) !== false; &#125;); // 最后返回本身对象 return this; &#125;, filter: function(selector) &#123; // not函数下文定义 // 如果给not传入的参数是函数，则返回不符合这个函数规则的元素的数组（用 $ 封装） if (isFunction(selector)) return this.not(this.not(selector)); // 上文定义：zepto.matches 判断elements是否符合 selector 的要求 // zepto.matches = function(element, selector) &#123;...&#125; return $( filter.call(this, function(element) &#123; // 利用 [].filter 方法做筛选，利用 zepto.matches 做判断 return zepto.matches(element, selector); &#125;) ); &#125;, // $('div') 可能只有三个 div 节点，那么 $('div').add('p') 再三个 div 节点的基础上，增加三个 p 节点 add: function(selector, context) &#123; // uniq函数——数组去重，例如：用来将 [1,1,2,2,3,3] 替换为 [1,2,3] return $(uniq(this.concat($(selector, context)))); &#125;, is: function(selector) &#123; // 注意：这里只对 this[0] 第一个元素做判断了，其他的元素不管了 return this.length &gt; 0 &amp;&amp; zepto.matches(this[0], selector); &#125;, not: function(selector) &#123; var nodes = []; // 存储最后返回的结果 // 如果参数是函数 if (isFunction(selector) &amp;&amp; selector.call !== undefined) this.each(function(idx) &#123; // 遍历对象的所有元素，对每个元素都执行传入的函数 // 当函数返回 false 时（即不符合函数的规则），则将当前元素push到结果中，等待返回 if (!selector.call(this, idx)) nodes.push(this); &#125;); // 如果参数不是函数 else &#123; // 为 excludes 赋值 var excludes = // 如果 selector 是字符串（css选择器），则用filter过滤，将结果存储到 excludes 中 typeof selector == \"string\" ? this.filter(selector) : // 如果 selector 不是字符串 // 如果是数组或者对象数组（并且 selector.item 是函数？？？），则生成数组，赋值给 excludes likeArray(selector) &amp;&amp; isFunction(selector.item) ? slice.call(selector) : // 否则直接生成 zepto 对象，赋值给 excludes $(selector); // 至此，excludes 中就存储了通过 selector 查找出来的元素 // [].forEach 是ES5的新特性 this.forEach(function(el) &#123; // 取出 excludes 中不包含的元素，push到结果中 if (excludes.indexOf(el) &lt; 0) nodes.push(el); &#125;); &#125; // 返回最后的结果，用 $ 封装 return $(nodes); &#125;, has: function(selector) &#123; // 经过 filter 函数处理，返回的是一个处理后的值 return this.filter(function() &#123; return isObject(selector) ? // 如果 seletor 是 object（可能是elem节点），则用 $.contains 判断 $.contains(this, selector) : // 否则（selector是css选择字符串）则返回find后的size（如果 size === 0 即相当于返回 false） $(this) .find(selector) .size(); // $.fn.find 在下文定义 &#125;); &#125;, eq: function(idx) &#123; // 取出指定index的元素 // 可支持 -1、0、1、2 …… return idx === -1 ? this.slice(idx) : this.slice(idx, +idx + 1); &#125;, first: function() &#123; var el = this[0]; // 不是 object 则直接返回 // 是 object 类型，则用 $ 封装 （因为时刻都要支持链式操作！！！） return el &amp;&amp; !isObject(el) ? el : $(el); &#125;, last: function() &#123; var el = this[this.length - 1]; return el &amp;&amp; !isObject(el) ? el : $(el); &#125;, find: function(selector) &#123; // result 存储返回结果 var result, $this = this; // 如果没有参数，就返回一个空的 zepto 对象 if (!selector) result = $(); // 如果selector是对象 else if (typeof selector == \"object\") result = $(selector).filter(function() &#123; var node = this; return emptyArray.some.call($this, function(parent) &#123; return $.contains(parent, node); &#125;); &#125;); // 如果 selector 不是对象（即是css选择器）： // 如果只有一个元素，则使用 qsa 判断，结果经过 $ 封装后赋值给 result else if (this.length == 1) result = $(zepto.qsa(this[0], selector)); // 如果有多个元素，则使用 map 遍历所有元素，使用 qsa 针对每个元素判断，符合条件即返回（map将返回包含符合条件的元素的新数组，并 $ 封装，支持链式操作！！） else result = this.map(function() &#123; return zepto.qsa(this, selector); &#125;); // 返回最终结果 return result; &#125;, // 从元素本身开始，逐级向上级元素匹配，并返回最先匹配selector的元素 closest: function(selector, context) &#123; var node = this[0], collection = false; // 如果 selector 是对象，则用 $ 封装后，赋值给 collection if (typeof selector == \"object\") collection = $(selector); while ( // while循环的判断条件： // 第一，node有值（node一开始被赋值为对象的第一个元素） // 第二，collection有值（传入的selector是对象）则collection包含node；collection无值（传入的selector是字符串，css选择），则node满足selector条件 // 满足第一个条件，不满足第二条件，则循环继续（node试图赋值为node.parentNode）；否则，循环跳出（说明已经找到了符合条件的父节点） node &amp;&amp; !(collection ? collection.indexOf(node) &gt;= 0 : zepto.matches(node, selector)) ) // node赋值成 node.parentNode // 前提条件是：node != context &amp;&amp; node 不是 document，如果是这两个条件之一，那就不继续赋值 node = node !== context &amp;&amp; !isDocument(node) &amp;&amp; node.parentNode; // 返回最终结果 return $(node); &#125;, // 获取对象集合每个元素所有的祖先元素。 $('h1').parents() =&gt; [&lt;div#container&gt;, &lt;body&gt;, &lt;html&gt;] parents: function(selector) &#123; var ancestors = [], nodes = this; while (nodes.length &gt; 0) // 可能需要执行多次 while 循环 // 每次执行 $.map 函数都会对 nodes 重新赋值，然后再判断是否需要继续循环 // 因为要获取每个元素的所有祖先元素，所以要多次循环 nodes = $.map(nodes, function(node) &#123; // 使用 $.map（返回符合条件的元素的新数组，并用 $ 封装）遍历所有元素 if ( (node = node.parentNode) &amp;&amp; !isDocument(node) &amp;&amp; ancestors.indexOf(node) &lt; 0 ) &#123; // 将符合条件的元素push到结果中 // 条件：不能是 document，结果中元素不能重复。否则不执行push ancestors.push(node); // 返回的 node ，将拼接出新数组，重新复制给 nodes，然后试图继续执行 while 循环 return node; &#125; &#125;); // 如果css选择器参数给出，过滤出符合条件的元素 return filtered(ancestors, selector); &#125;, // 获取对象集合中每个元素的直接父元素。如果css选择器参数给出。过滤出符合条件的元素。 parent: function(selector) &#123; // pluck 函数在下文定义 // parent 函数，只获取第一级父节点即可 return filtered(uniq(this.pluck(\"parentNode\")), selector); &#125;, // 获得每个匹配元素集合元素的直接子元素，可通过 selector 过滤 children: function(selector) &#123; return filtered( this.map(function() &#123; return children(this); &#125;), selector ); &#125;, // 获得每个匹配元素集合元素的子元素，包括文字和注释节点 contents: function() &#123; return this.map(function() &#123; return slice.call(this.childNodes); &#125;); &#125;, // 获取对象集合中所有元素的兄弟节点，可通过 selector 过滤 siblings: function(selector) &#123; return filtered( this.map(function(i, el) &#123; // 获取兄弟节点 return filter.call(children(el.parentNode), function(child) &#123; return child !== el; &#125;); &#125;), selector ); &#125;, empty: function() &#123; return this.each(function() &#123; this.innerHTML = \"\"; &#125;); &#125;, // `pluck` is borrowed from Prototype.js pluck: function(property) &#123; // 获取自定义属性，返回值，拼接数组 return $.map(this, function(el) &#123; return el[property]; &#125;); &#125;, show: function() &#123; // 返回当前对象，保证可链式操作 return this.each(function() &#123; // 第一步，针对内联样式，将 none 改为空字符串，如 &lt;p id=\"p2\" style=\"display:none;\"&gt;p2&lt;/p&gt; this.style.display == \"none\" &amp;&amp; (this.style.display = \"\"); // 第二步，针对css样式，如果是 none 则修改为默认的显示样式 if (getComputedStyle(this, \"\").getPropertyValue(\"display\") == \"none\") this.style.display = defaultDisplay(this.nodeName); // show 方法是为了显示对象，而对象隐藏的方式有两种：内联样式 或 css样式 // this.style.display 只能获取内联样式的值（获取属性值） // getComputedStyle(this, '').getPropertyValue(\"display\") 可以获取内联、css样式的值（获取 renderTree 的值） // 因此，这两步都要做判断， &#125;); &#125;, replaceWith: function(newContent) &#123; // 先在前面插入，然后将当前对象移除 return this.before(newContent).remove(); &#125;, wrap: function(structure) &#123; // 是否是函数 var func = isFunction(structure); if (this[0] &amp;&amp; !func) var dom = $(structure).get(0), // 何时用 clone ？ // 第一，dom.parentNode 说明 dom 在文档结构中，不 clone 就会被移动 // 第二，this.length &gt; 1 说明当前对象有多个元素，每个元素都要添加，所有要clone clone = dom.parentNode || this.length &gt; 1; return this.each(function(index) &#123; // 借用 wrapAll 方法来做包装 $(this).wrapAll( func ? structure.call(this, index) : clone ? dom.cloneNode(true) : dom ); &#125;); &#125;, // 在所有匹配元素外面包一个单独的结构 wrapAll: function(structure) &#123; if (this[0]) &#123; // 先将 structure 插入到文档结构 $(this[0]).before((structure = $(structure))); var children; // drill down to the inmost element // 通过循环，将 structure 重新赋值为当前 structure 的最深处的一个子元素 while ((children = structure.children()).length) structure = children.first(); // 将所有子元素都包裹进 structure $(structure).append(this); &#125; // 返回当前对象 return this; &#125;, wrapInner: function(structure) &#123; // 是否是函数 var func = isFunction(structure); // 返回对象自身，保证链式操作 return this.each(function(index) &#123; var self = $(this), contents = self.contents(), // 是函数，即获取函数执行的返回结果；否则直接用 structure 参数 dom = func ? structure.call(this, index) : structure; // 如果当前元素有内容，则通过内容 wrapAll。无内容，则直接用自身的 append 增加 contents.length ? contents.wrapAll(dom) : self.append(dom); &#125;); &#125;, unwrap: function() &#123; // 通过 this.parent() 获取每个元素的父节点（集合） // 遍历这个父节点的集合 this.parent().each(function() &#123; // 将当前父节点替换为它的子节点 $(this).replaceWith($(this).children()); &#125;); // 返回对象自身，保证链式操作 return this; &#125;, clone: function() &#123; // 通过 this.map 循环对象， // 针对每个元素都返回它的clone 这个 this 和前面的 this 不一样 // 返回新数组（用 $ 封装） return this.map(function() &#123; return this.cloneNode(true); &#125;); &#125;, hide: function() &#123; return this.css(\"display\", \"none\"); &#125;, // 切换显示和隐藏 toggle: function(setting) &#123; /* @setting true : 强制切换为 show false : 强制切换为 hide */ return this.each(function() &#123; var el = $(this); // 条件判断： // 如果 setting === undefined 则看 el.css(\"display\") == \"none\" // 如果 setting !== undefined 则看 !!setting (setting === undefined ? el.css(\"display\") == \"none\" : setting) ? el.show() // 如果 true 则显示 : el.hide(); // 如果 false 则隐藏 &#125;); &#125;, // 借助 previousElementSibling 属性 prev: function(selector) &#123; return $(this.pluck(\"previousElementSibling\")).filter(selector || \"*\"); &#125;, // 借助 nextElementSibling 属性 next: function(selector) &#123; return $(this.pluck(\"nextElementSibling\")).filter(selector || \"*\"); &#125;, html: function(html) &#123; return; // 情况1：有参数，赋值，并返回自身 0 in arguments ? this.each(function(idx) &#123; var originHtml = this.innerHTML; // 传入的 html 参数允许是一个字符串，也允许是一个函数 // 通过 funcArg 函数： // 1.如果 html 是字符串，则返回html // 2.如果 html 是函数，则执行执行函数（传入 idx、originHtml），返回函数执行结果 $(this) .empty() .append(funcArg(this, html, idx, originHtml)); &#125;) : /* 插播： function funcArg(context, arg, idx, payload) &#123; return isFunction(arg) ? arg.call(context, idx, payload) : arg &#125; */ // 情况2：无参数，取值 0 in this ? this[0].innerHTML // 直接取第一个元素的 innerHTML : null; &#125;, text: function(text) &#123; return; // 情况1：有参数，赋值，并返回自身 0 in arguments ? this.each(function(idx) &#123; // funcArg的应用，和html方法中一样 var newText = funcArg(this, text, idx, this.textContent); this.textContent = newText == null ? \"\" : \"\" + newText; &#125;) : // 情况2：无参数，取值 0 in this ? this[0].textContent : null; // 直接借用 textContent 属性 &#125;, attr: function(name, value) &#123; var result; return; // 情况1：无第二个参数，读取值（读取值只能读取第一个元素的值） typeof name == \"string\" &amp;&amp; !(1 in arguments) ? !this.length || this[0].nodeType !== 1 ? undefined : /* 注释： this[0]是一个DOM节点，有『属性』也有『特性』 result = this[0].getAttribute(name) 试图获取 DOM节点属性 name in this[0] 判断是不是js对象的属性 然后，该返回哪一个就返回哪一个 */ !(result = this[0].getAttribute(name)) &amp;&amp; name in this[0] ? this[0][name] : result : // 情况2：有第二个参数，设置值（针对每个元素设置值） this.each(function(idx) &#123; if (this.nodeType !== 1) return; // 传入的参数可能是一个对象集合 // 此时，是不是应该放在『情况1』当中？？？此时，value根本没有用啊？？？ if (isObject(name)) for (key in name) setAttribute(this, key, name[key]); // 传入的不是对象，即设置一个单一的属性。 // 但是，这里的 value 参数可以是一个函数 // funcArg 即处理了 value 是函数和非函数的两种情况 else setAttribute( this, name, funcArg(this, value, idx, this.getAttribute(name)) ); &#125;); &#125;, removeAttr: function(name) &#123; return this.each(function() &#123; this.nodeType === 1 &amp;&amp; name.split(\" \").forEach( function(attribute) &#123; setAttribute(this, attribute); // 将属性设置为空，setAttribute会移除属性 &#125;, this // 改参数将成为 forEach 中函数的this ); &#125;); &#125;, // 读取、设置属性（js对象的属性） prop: function(name, value) &#123; // propMap 中存储的：key是html中的属性名称，value是js对象中的属性名称 // 例如，html中的 \"class\" 在DOM对象中，就需要使用 \"className\" 这个名字读取，同理于：for maxlength cellspacing 等等 name = propMap[name] || name; /* 上文定义： propMap = &#123; 'tabindex': 'tabIndex', 'readonly': 'readOnly', 'for': 'htmlFor', 'class': 'className', 'maxlength': 'maxLength', 'cellspacing': 'cellSpacing', 'cellpadding': 'cellPadding', 'rowspan': 'rowSpan', 'colspan': 'colSpan', 'usemap': 'useMap', 'frameborder': 'frameBorder', 'contenteditable': 'contentEditable' &#125; */ return; // 有第二个参数，设置属性 1 in arguments ? this.each(function(idx) &#123; // 设置属性值，funcArg处理函数或者非函数 this[name] = funcArg(this, value, idx, this[name]); &#125;) : // 无第二个参数，读取属性（读取第一个元素的） this[0] &amp;&amp; this[0][name]; &#125;, // 前面加上 'data-' 通过 attr 设置或者读取 data: function(name, value) &#123; /* 上文定义： capitalRE = /([A-Z])/g, //大写字母 */ // 前面加上 'data-' 将 'A' 替换为 '-a' var attrName = \"data-\" + name.replace(capitalRE, \"-$1\").toLowerCase(); var data = 1 in arguments ? this.attr(attrName, value) : this.attr(attrName); return data !== null ? deserializeValue(data) : undefined; /* 上文定义的，deserializeValue 函数的作用是： // 将字符串变成响应的对象或者值，例如源代码的注释： // \"true\" =&gt; true // \"false\" =&gt; false // \"null\" =&gt; null // \"42\" =&gt; 42 // \"42.5\" =&gt; 42.5 // \"08\" =&gt; \"08\" // JSON =&gt; parse if valid // String =&gt; self */ &#125;, val: function(value) &#123; return; // 有参数，设置值 0 in arguments ? this.each(function(idx) &#123; // 遍历每个元素，直接对 value 属性赋值 this.value = funcArg(this, value, idx, this.value); &#125;) : // 无参数，读取值 this[0] &amp;&amp; // 如果元素是 &lt;select multiple&gt; 多选列表 (this[0].multiple ? // 返回所有选中的option的值的数组 $(this[0]) .find(\"option\") .filter(function() &#123; return this.selected; &#125;) .pluck(\"value\") : /* 上文定义： pluck: function(property)&#123; return $.map(this, function(el)&#123; return el[property] &#125;) &#125;, */ // 如果不是，直接获取 value this[0].value); &#125;, // 获取、设置元素的 offset offset: function(coordinates) &#123; // 如果有 coordinates 参数，设置坐标值，并返回当前对象 if (coordinates) return this.each(function(index) &#123; var $this = $(this), // 支持函数（传入 $this.offset() 做参数）和非函数 coords = funcArg(this, coordinates, index, $this.offset()), // 找到最近的 “relative”, “absolute” or “fixed” 的祖先元素，并获取它的 offset() parentOffset = $this.offsetParent().offset(), // left 和 top 需要去掉定位的祖先元素的 left、top 值 props = &#123; top: coords.top - parentOffset.top, left: coords.left - parentOffset.left &#125;; // static时，设置 top、left是无效的 if ($this.css(\"position\") == \"static\") props[\"position\"] = \"relative\"; // 通过 css 赋值 $this.css(props); &#125;); // 当前对象是空，则返回 null if (!this.length) return null; // 如果没有 coordinates 参数，则返回第一个元素的坐标值 var obj = this[0].getBoundingClientRect(); /* elem.getBoundingClientRect() 返回一个对象， 包含元素的 top bottom left right width height 的值 但是这个 top、bottom、left、right 是相对于浏览器窗口的距离，而不是页面的边界 （注意，elem.getBoundingClientRect()在IE低版本浏览器有2px的兼容问题） window.pageXOffset 和 window.pageYOffset 可获取网页滚动的距离， IE低版本需要用 document.body.scrollLeft 和 document.body.scrollTop 兼容 */ return &#123; left: obj.left + window.pageXOffset, top: obj.top + window.pageYOffset, width: Math.round(obj.width), height: Math.round(obj.height) &#125;; &#125;, // 设置、获取 css css: function(property, value) &#123; // 只有一个参数，获取第一个元素的样式 if (arguments.length &lt; 2) &#123; var computedStyle, element = this[0]; if (!element) return; // 如果第一个元素无值，直接返回。否则继续 // 获取元素的计算后的样式 computedStyle = getComputedStyle(element, \"\"); if (typeof property == \"string\") // 情况1，参数为字符串形式 // 先从elem内联样式获取（element.style），此时需要 camelize(property) 转换，如将 background-color 变为 backgroundColor // 如果未找到，则从css样式获取 computedStyle.getPropertyValue(property) // （重要）注释：elem.style 只能获取元素设置的内联样式、不能获取css样式；而 getComputedStyle 可获取内联、css样式。 return ( element.style[camelize(property)] || computedStyle.getPropertyValue(property) ); else if (isArray(property)) &#123; // 情况2，参数为数组形式（注意，此时 isObject 情况尚未判断） var props = &#123;&#125;; $.each(property, function(_, prop) &#123; props[prop] = element.style[camelize(prop)] || computedStyle.getPropertyValue(prop); &#125;); return props; // 返回一个对象 &#125; &#125; // 其他情况：有两个参数、property是对象 var css = \"\"; if (type(property) == \"string\") &#123; // 情况1，property 是字符串，设置单个样式 if (!value &amp;&amp; value !== 0) // 如果value参数是 '' null undefined 则移除这个css样式 // 注：此计算只适用于内联样式的删除，对 css 样式无效，因为它只通过 this.style.removeProperty 计算，而 this.style 获取不到css样式 this.each(function() &#123; this.style.removeProperty(dasherize(property)); &#125;); // value有正常值，将 css 生成一个字符串（如 'font-size:20px'）等待赋值给内联样式 // maybeAddPx(property, value) 需要增加 px 的增加上 else css = dasherize(property) + \":\" + maybeAddPx(property, value); &#125; else &#123; // 情况2，property 是对象（此时就不管第二个参数是什么了，不用第二个参数），一次性设置多个样式 for (key in property) if (!property[key] &amp;&amp; property[key] !== 0) // 如果对象属性值是 '' null undefined 则移除这个css样式，同理，只针对内联样式 this.each(function() &#123; this.style.removeProperty(dasherize(key)); &#125;); // 否则，给 css 赋值一个字符串，多样式属性用 ; 隔开 else css += dasherize(key) + \":\" + maybeAddPx(key, property[key]) + \";\"; &#125; // 针对每个元素，设置内联样式（this.style.cssText可获取、设置内联样式） // 最后返回自身 return this.each(function() &#123; this.style.cssText += \";\" + css; &#125;); /* 上文定义： // 将 lineHeight 转换为 line-height 格式 function dasherize(str) &#123; return str.replace(/::/g, '/') .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2') .replace(/([a-z\\d])([A-Z])/g, '$1_$2') .replace(/_/g, '-') .toLowerCase() &#125; */ &#125;, // 获取一个元素的索引值（从0开始计数）。当elemen参数没有给出时，返回当前元素在兄弟节点中的位置 index: function(element) &#123; /* 上文定义： $.fn.indexOf: emptyArray.indexOf */ // 其实 this 本身就是一个数组，数组本身就有 indexOf ，为何还要上文的这个赋值呢？ // 因为上文中，this.__proto__ 修改了，不是 Array.prototype 了，也就没有 indexOf 方法了 // 因此要手动赋值，需要将数组常用的方法在重新赋值给 $.fn.indexOf return element ? this.indexOf($(element)[0]) : this.parent() .children() .indexOf(this[0]); &#125;, hasClass: function(name) &#123; if (!name) return false; return emptyArray.some.call( this, function(el) &#123; // this 就是 classRE(name) 的返回值（返回一个正则） // function className(node, value)&#123;...&#125; 获取或者设置elem的className return this.test(className(el)); &#125;, classRE(name) ); // array.some(callback,[ thisObject]); 只要数组中一项符合callback要求，即返回true /* // 上文定义 classCache = &#123;&#125; function classRE(name) &#123; return name in classCache ? classCache[name] : (classCache[name] = new RegExp('(^|\\\\s)' + name + '(\\\\s|$)')) // classCache 存储的数据是这样的： // &#123; // abc: /(^|\\s)abc(\\s|$)/, // 能匹配 'abc' 或 ' abc ' 或 ' abc' 或 'abc ' // xyz: /(^|\\s)abc(\\s|$)/, // ... // &#125; &#125; */ &#125;, addClass: function(name) &#123; if (!name) return this; // 针对所有元素都添加className，最终返回本身 return this.each(function(idx) &#123; // 说明当前元素不是 DOM node if (!(\"className\" in this)) return; // classList 是一开始就定义的空变量 classList = []; // 获取元素的 clasname // 支持传入函数 var cls = className(this), newName = funcArg(this, name, idx, cls); // 把要赋值的值，按照空白分组，遍历 newName.split(/\\s+/g).forEach(function(klass) &#123; // 把当前元素不存在的class，push到classlist中 if (!$(this).hasClass(klass)) classList.push(klass); &#125;, this); // 如果classlist有数据，则为当前元素赋值最新的class值（现有的classname和新的classname拼接） classList.length &amp;&amp; className(this, cls + (cls ? \" \" : \"\") + classList.join(\" \")); &#125;); &#125;, removeClass: function(name) &#123; // 针对所有元素都移除className，最终返回本身 return this.each(function(idx) &#123; // 说明当前元素不是 DOM node if (!(\"className\" in this)) return; // 如果参数空，则移除元素的所有class if (name === undefined) return className(this, \"\"); // 获取现有的classname classList = className(this); // （可以传入函数）遍历新的classname字符串 funcArg(this, name, idx, classList) .split(/\\s+/g) .forEach(function(klass) &#123; // classRE(klass) 返回一个正则，匹配 'classname' 或 ' classname ' 或 ' classname' 或 'classname ' // 针对传入的classname字符串，对每个符合条件的classname，都替换为 ' '（即删除了） classList = classList.replace(classRE(klass), \" \"); &#125;); // 对整理好的classname，重新赋值给当前元素 className(this, classList.trim()); &#125;); &#125;, toggleClass: function(name, when) &#123; // when 参数相当于一个条件： // 如果 when === true 则单纯执行 addClass // 如果 when === false 则单纯执行 removeClass if (!name) return this; return this.each(function(idx) &#123; // name 可接收函数，可以是空白分割开来的多个classname var $this = $(this), names = funcArg(this, name, idx, className(this)); // 用空白分割开多个class names.split(/\\s+/g).forEach(function(klass) &#123; // 如果有 when 参数，则只通过when参数判断，true则只执行addClass，false则只执行removeClass // 如果没有 when 参数，则判断元素有没有该class，有则移除，没有则添加 (when === undefined ? !$this.hasClass(klass) : when) ? $this.addClass(klass) : $this.removeClass(klass); &#125;); &#125;); &#125;, scrollTop: function(value) &#123; if (!this.length) return; // 普通elem有 scrollTop 属性，可以获取或者设置top值 // window对象没有 scrollTop 属性，通过 pageYOffset 获取，通过 scrollTo() 赋值 var hasScrollTop = \"scrollTop\" in this[0]; // value 无值，获取 top if (value === undefined) return hasScrollTop ? this[0].scrollTop : this[0].pageYOffset; // value 有值，设置 top return this.each( hasScrollTop ? function() &#123; this.scrollTop = value; &#125; : function() &#123; this.scrollTo(this.scrollX, value); &#125; ); // window.scrollX 获取横向滚动值 &#125;, scrollLeft: function(value) &#123; if (!this.length) return; var hasScrollLeft = \"scrollLeft\" in this[0]; if (value === undefined) return hasScrollLeft ? this[0].scrollLeft : this[0].pageXOffset; return this.each( hasScrollLeft ? function() &#123; this.scrollLeft = value; &#125; : function() &#123; this.scrollTo(value, this.scrollY); &#125; ); // window.scrollX 获取纵向滚动值 &#125;, position: function() &#123; if (!this.length) return; var elem = this[0], // Get *real* offsetParent offsetParent = this.offsetParent(), // 找到第一个定位过的祖先元素 “relative”, “absolute” or “fixed” // Get correct offsets offset = this.offset(), // 获取自身的offset parentOffset = rootNodeRE.test(offsetParent[0].nodeName) ? &#123; top: 0, left: 0 &#125; : offsetParent.offset(); // 获取定位祖先元素的offset（ body、html直接设置 top:0;left:0 ） // 上文定义： rootNodeRE = /^(?:body|html)$/i, // 去掉当前元素的 margin 宽度 // Subtract element margins // note: when an element has margin: auto the offsetLeft and marginLeft // are the same in Safari causing offset.left to incorrectly be 0 offset.top -= parseFloat($(elem).css(\"margin-top\")) || 0; offset.left -= parseFloat($(elem).css(\"margin-left\")) || 0; // 增加父元素的 border 宽度 // Add offsetParent borders parentOffset.top += parseFloat($(offsetParent[0]).css(\"border-top-width\")) || 0; parentOffset.left += parseFloat($(offsetParent[0]).css(\"border-left-width\")) || 0; // Subtract the two offsets return &#123; top: offset.top - parentOffset.top, left: offset.left - parentOffset.left &#125;; &#125;, offsetParent: function() &#123; // 通过 this.map 遍历当前对象所有元素，进行计算，然后拼接新的数组，并返回。保证链式操作 return this.map(function() &#123; var parent = this.offsetParent || document.body; // elem.offsetParent 可返回最近的改元素最近的已经定位的父元素 while ( parent &amp;&amp; !rootNodeRE.test(parent.nodeName) &amp;&amp; $(parent).css(\"position\") == \"static\" ) // 如果获取的parent不是null、不是body或html、而且position==static // 则继续向上查找 offsetParent、大不了找到 body 为止 parent = parent.offsetParent; // 最后返回改元素 return parent; &#125;); &#125; &#125;; // for now $.fn.detach = $.fn.remove; // Generate the `width` and `height` functions [\"width\", \"height\"].forEach(function(dimension) &#123; // 将 width height 变为 Width Height var dimensionProperty = dimension.replace(/./, function(m) &#123; return m[0].toUpperCase(); &#125;); $.fn[dimension] = function(value) &#123; var offset, el = this[0]; // 情况1，无参数，获取第一个元素的值 if (value === undefined) return isWindow(el) ? el[\"inner\" + dimensionProperty] // window.innerHeight : isDocument(el) ? el.documentElement[\"scroll\" + dimensionProperty] // document.documentElement.scrollHeight : (offset = this.offset()) &amp;&amp; offset[dimension]; // this.offset().width // 情况2，有参数，设置所有元素的值 else return this.each(function(idx) &#123; el = $(this); // 通过 css() 方法设置，支持传入函数 el.css(dimension, funcArg(this, value, idx, el[dimension]())); &#125;); &#125;; &#125;); // 针对当前元素、遍历子元素，都执行 fun 函数 function traverseNode(node, fun) &#123; fun(node); for (var i = 0, len = node.childNodes.length; i &lt; len; i++) traverseNode(node.childNodes[i], fun); &#125; // 上文定义 adjacencyOperators = [ 'after', 'prepend', 'before', 'append' ], // Generate the `after`, `prepend`, `before`, `append`, // `insertAfter`, `insertBefore`, `appendTo`, and `prependTo` methods. adjacencyOperators.forEach(function(operator, operatorIndex) &#123; var inside = operatorIndex % 2; //=&gt; prepend, append $.fn[operator] = function() &#123; // arguments can be nodes, arrays of nodes, Zepto objects and HTML strings var argType, nodes = $.map(arguments, function(arg) &#123; argType = type(arg); return argType == \"object\" || argType == \"array\" || arg == null ? arg : zepto.fragment(arg); &#125;), parent, copyByClone = this.length &gt; 1; if (nodes.length &lt; 1) return this; return this.each(function(_, target) &#123; parent = inside ? target : target.parentNode; // convert all methods to a \"before\" operation target = operatorIndex == 0 ? target.nextSibling : operatorIndex == 1 ? target.firstChild : operatorIndex == 2 ? target : null; var parentInDocument = $.contains(document.documentElement, parent); nodes.forEach(function(node) &#123; if (copyByClone) node = node.cloneNode(true); else if (!parent) return $(node).remove(); parent.insertBefore(node, target); if (parentInDocument) traverseNode(node, function(el) &#123; if ( el.nodeName != null &amp;&amp; el.nodeName.toUpperCase() === \"SCRIPT\" &amp;&amp; (!el.type || el.type === \"text/javascript\") &amp;&amp; !el.src ) window[\"eval\"].call(window, el.innerHTML); &#125;); &#125;); &#125;); &#125;; // after =&gt; insertAfter // prepend =&gt; prependTo // before =&gt; insertBefore // append =&gt; appendTo $.fn[ inside ? operator + \"To\" : \"insert\" + (operatorIndex ? \"Before\" : \"After\") ] = function(html) &#123; $(html)[operator](this); return this; &#125;; &#125;); zepto.Z.prototype = $.fn; // Export internal API functions in the `$.zepto` namespace zepto.uniq = uniq; zepto.deserializeValue = deserializeValue; $.zepto = zepto; return $;&#125;)();window.Zepto = Zepto;window.$ === undefined &amp;&amp; (window.$ = Zepto);","categories":[{"name":"前端框架","slug":"前端框架","permalink":"https://www.yangtao.site/categories/前端框架/"}],"tags":[{"name":"zepto","slug":"zepto","permalink":"https://www.yangtao.site/tags/zepto/"}]},{"title":"Zepto 对象思想与源码分析","slug":"zepto","date":"2020-03-12T09:56:32.000Z","updated":"2020-03-16T04:03:15.930Z","comments":true,"path":"2020/03/12/zepto/","link":"","permalink":"https://www.yangtao.site/2020/03/12/zepto/","excerpt":"zepto 对象思想与源码分析","text":"zepto 对象思想与源码分析 原型对象Array.prototype每一个函数，都有一个 prototype 属性，不管是你自定义的，还是函数内置的。 123var fn = function() &#123;&#125;;console.log(fn.prototype); // &#123;constructor: ƒ&#125;console.log(fn.prototype.constructor === fn); // true 这里的 fn.prototype 打印出一个对象，对象里的 constructor 属性又指回了该函数本身 fn。 即每一个原型对象都有一个 consctructor 属性指向关联的构造函数，比如： 1Array.prototype.constructor === Array; //true 我们接着看： 1console.log(Array.prototype); // [constructor: ƒ, concat: ƒ, copyWithin: ƒ, fill: ƒ, find: ƒ, …] 这里，除了 constructor 属性，还有其他内置的属性，即我们经常使用的操作数组的方法。 __proto__(隐式原型)所有通过函数 new （构造函数）出来的实例对象，都有一个 __proto__属性，指向该对象的 prototype，比如： 12var arr = new Array();arr.__proto__ === Array.prototype; // true 原型链：由相互关联的原型(__proto__)组成的链状结构就是原型链。 举个关于继承 extends 的例子： 12345678910111213141516function Animal() &#123; this.eat = function() &#123; console.log(\"Animal eat\"); &#125;;&#125;function Dog() &#123; this.bark = function() &#123; console.log(\"Dog bark\"); &#125;;&#125;// 绑定原型，实现继承Dog.prototype = new Animal();var dog = new Dog();dog.eat(); // Animal eatdog.bark(); // Dog bark 上面看明白了，那么 ES6 的继承我们也就可以明白原理了，即 class Dog extends Animal 相当于 Dog.prototype = new Animal() 123456789101112131415161718192021class Animal &#123; constructor(name) &#123; this.name = name; &#125; eat() &#123; console.log(\"Animal eat!\" + this.name); &#125;&#125;class Dog extends Animal &#123; constructor(name) &#123; super(name); this.name = name; &#125; bark() &#123; console.log(\"Dog bark!\" + this.name); &#125;&#125;const dog = new Dog(\"哈士奇\");dog.eat();dog.bark(); 接下来，我们就清楚为什么能这样： 当我们要使用一个对象（数组）的某个功能时，如果该对象本身具有这个功能，直接调用，没有的话，那就去自身的__proto__属性中去找 12345678910var obj = &#123; myfn: function() &#123; console.log(\"myfn\"); &#125;&#125;;obj.myfn(); // 'myfn'obj.hasOwnProperty(\"myfn\"); //trueobj.toString(); // \"[object Object]\"obj.hasOwnProperty(\"toString\"); // falseobj.__proto__.hasOwnProperty(\"toString\"); // true hasOwnProperty()就可以得出这个属性是否是属于该对象本身的属性: myfn 是我们自定义的，obj.hasOwnProperty(&#39;myfn&#39;)为 true toString() 我们不是自定义的，却可以使用，查一下是否属于自定义属性，obj.hasOwnProperty(&#39;toString&#39;)，答案为 false 既然不属于自定义属性，那就去自身的__proto__去找，然后去原型对象上查一下，obj.__proto__.hasOwnProperty(&#39;toString&#39;)，哦，原来在这儿 在源码中，我们经常看到Array.prototype.concat，其实就是我们使用的[].concat，[]，因为[].__proto__ === Array.prototype __proto__是可修改的比如，我们新增一个addClass()方法： 123456var arr = [1, 2, 3];arr.__proto__.addClass = function() &#123; console.log(123);&#125;;arr.push(4);arr.addClass(); // 123 但是，这里要注意，如下重写之后，就没有了诸如 push、concat 等方法： 123456arr.__proto__ = &#123; addClass: function() &#123; console.log(123); &#125;&#125;;arr.push(3); //Uncaught TypeError: arr.push is not a function Object.prototype的原型万物皆对象，到最后依旧是对象，最后这个东东是个啥，我们来看一下： 123456789101112131415161718// 构造函数 Personfunction Person() &#123;&#125;// 实例对象 myfn，它的 隐式原型 指向了其构造函数的 原型对象var myfn = new Person();myfn.__proto__ === Person.prototype; //true// 那构造函数 Person 的 隐式原型又指向了谁呢Person.prototype.__proto__ === Object.prototype; //true// Function呐Function.prototype.__proto__ === Object.prototype; //true// 这个呢var fn = function() &#123;&#125;;fn.prototype.__proto__ === Object.prototype; //trueObject.prototype.__proto__ === null; //truetypeof null; //\"object\" 总结： 所有的函数都有一个 prototype属性，该属性指向了一个对象，该对象就是调用该构造函数而创建出来的实例（如 myfn）的原型（如myfn.__proto__）,即：myfn.__proto__ === Person.prototype 所有的对象（除 null）都具有一个__proto__属性，该属性指向该对象的原型，比如：myfn.__proto__ === Person.prototype 原型也是一个对象，根据上条，那原型的原型，就是Object.prototype 最后的 null 对象，可以当做是 什么都没有 盗一张图，我们就更加清楚了（蓝色这条表示的是原型链） 参考资料： js 原型链基础 JavaScript 深入之从原型到原型链 深入理解 javascript 原型和闭包（3）——prototype 原型 Zepto 对象设计主体设计1234567891011121314151617181920212223242526272829303132333435363738394041var Zepto = (function() &#123; var $, zepto = &#123;&#125;; // ...省略N行代码... zepto.Z = function(dom, selector) &#123; dom = dom || []; dom.__proto__ = $.fn; // 关键位置 dom.selector = selector || \"\"; return dom; &#125;; zepto.init = function(selector, context) &#123; var dom; // 针对参数情况，分别对dom赋值 // 最终调用 zepto.Z 返回的数据 return zepto.Z(dom, selector); &#125;; $ = function(selector, context) &#123; return zepto.init(selector, context); &#125;; // 里面有若干个工具函数 $.fn = &#123; forEach: emptyArray.forEach, // ...省略N行代码... concat: function() &#123;&#125; // ...省略N行代码... &#125;; // ...省略N行代码... return $;&#125;)();window.Zepto = Zepto;window.$ === undefined &amp;&amp; (window.$ = Zepto); 自定义模拟123456789101112131415161718192021222324252627282930313233343536373839404142(function(window) &#123; var $, zepto = &#123;&#125;; function Z(dom, selector) &#123; var i, len = dom.length ? dom.length : 0; for (var i = 0; i &lt; dom.length; i++) &#123; this[i] = dom[i]; &#125; this.length = len; this.selector = selector || \"\"; &#125; zepto.Z = function(dom, selector) &#123; return new Z(dom, selector); &#125;; zepto.init = function(selector) &#123; var slice = Array.prototype.slice; var dom = slice.call(document.querySelectorAll(selector)); return zepto.Z(dom, selector); &#125;; $ = function(selector) &#123; return zepto.init(selector); &#125;; $.fn = &#123; css: function(key, value) &#123; console.log(\"css\"); &#125;, html: function(value) &#123; console.log(\"html\"); &#125; &#125;; Z.prototype = $.fn; window.$ = $;&#125;)(window); 流程：$() -&gt; zepto.init() -&gt; zepto.Z() -&gt; new Z() -&gt; Z.prototype = $.fn; 最新版（v1.2.0）模拟123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// 自执行匿名函数(IIFE，立即调用函数表达式)(function(global, factory) &#123; // amd 规范 if (typeof define === \"function\" &amp;&amp; define.amd) &#123; define(function() &#123; return factory(global); &#125;); &#125; else &#123; factory(global); &#125;&#125;)(this, function(window) &#123; var Zepto = (function() &#123; var $; var zepto = &#123;&#125;; // 大Z构造函数 function Z(dom, selector) &#123; var i, len = dom ? dom.length : 0; for (i = 0; i &lt; len; i++) this[i] = dom[i]; this.length = len; this.selector = selector || \"\"; &#125; // zepto.Z() 返回大Z构造函数的实例，方便实例对象的 __proto 就会指向 Z.prototype zepto.Z = function(dom, selector) &#123; return new Z(dom, selector); &#125;; // 解析 DOM，并调用 zepto.Z() zepto.init = function(selector, context) &#123; // 自定义模拟方法，源码并非这样简单 var slice = Array.prototype.slice; var dom = slice.call(document.querySelectorAll(selector)); // create a new Zepto collection from the nodes found return zepto.Z(dom, selector); &#125;; // 第一步初始化 $ = function(selector, context) &#123; return zepto.init(selector, context); &#125;; // 方法属性 $.fn = &#123; constructor: zepto.Z, // 手动绑定 constructor 属性 length: 0, push: \"push method\", css: function() &#123; console.log(\"css\"); return this; // 返回 this，可以链式调用 &#125;, html: function() &#123; console.log(\"html\") return this; &#125; &#125;; $.fn.on = function(event, data, callback) &#123; console.log(\"on method\"); &#125;; $.fn.off = function(event, data, callback) &#123; console.log(\"off method\"); &#125;; $.fn.bind = function(event, data, callback) &#123; return this.on(event, data, callback); &#125;; $.fn.unbind = function(event, callback) &#123; return this.off(event, callback); &#125;; // 最终的方法属性等都指向了 $.fn，这里就是原型的关键使用 zepto.Z.prototype = Z.prototype = $.fn; $.zepto = zepto; return $; &#125;)(); window.Zepto = Zepto; window.$ === undefined &amp;&amp; (window.$ = Zepto);&#125;); amd 规范： 123456789(function(global, factory) &#123; if (typeof define === \"function\" &amp;&amp; define.amd) &#123; define(function() &#123; return factory(global); &#125;); &#125; else &#123; factory(global); &#125;&#125;)(this, function(window) &#123;&#125;) 学习资料 zepto 设计和源码分析 - 视频 zepto 对象思想与源码分析","categories":[{"name":"前端框架","slug":"前端框架","permalink":"https://www.yangtao.site/categories/前端框架/"}],"tags":[{"name":"zepto","slug":"zepto","permalink":"https://www.yangtao.site/tags/zepto/"}]},{"title":"AJAX 请求","slug":"ajax","date":"2020-01-07T07:06:16.000Z","updated":"2020-01-07T09:51:42.474Z","comments":true,"path":"2020/01/07/ajax/","link":"","permalink":"https://www.yangtao.site/2020/01/07/ajax/","excerpt":"关于 http 请求的几种方式","text":"关于 http 请求的几种方式 AJAX具体来说，AJAX 包括以下几个步骤： 创建 XMLHttpRequest 实例 发出 HTTP 请求 接收服务器传回的数据 更新网页数据 起步1234567891011121314151617181920212223242526const MYTHOD = \"GET\";const URL = \"https://api.github.com/search/repositories?q=javascript&amp;sort=stars\";let xhr = null;//处理低版本IE不兼容问题if (window.XMLHttpRequest) &#123; xhr = new XMLHttpRequest();&#125; else &#123; xhr = new ActiveXObject(\"Microsoft.XMLHTTP\");&#125;// 指定回调函数，监听通信状态（readyState属性）的变化xhr.onreadystatechange = function() &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; console.log(xhr.responseText); &#125;&#125;;// 捕获错误xhr.onerror = err =&gt; console.error(\"Error: \", xhr.statusText);// 发出 HTTP 请求xhr.open(MYTHOD, URL, true);xhr.send(null); 设置头信息该方法必须在 open()之后、send()之前调用。如果该方法多次调用，设定同一个字段，则每一次调用的值会被合并成一个单一的值发送。 123xhr.setRequestHeader(\"Content-Type\", \"application/json\");xhr.setRequestHeader(\"Content-Length\", JSON.stringify(data).length);xhr.send(JSON.stringify(data)); Ajax+Promise123456789101112131415161718192021222324252627282930313233343536373839404142434445let ajax = (&#123; method = \"GET\", path, body, headers &#125;) =&gt; &#123; //进行Promise封装 return new Promise((resolve, reject) =&gt; &#123; let request = new XMLHttpRequest(); request.open(method, path, true); //配置 if (method == \"GET\") &#123; request.send(null); &#125; else &#123; for (const key in headers) &#123; //遍历header,设置响应头 let value = headers[key]; request.setRequestHeader(key, value); &#125; request.send(body); &#125; request.onreadystatechange = () =&gt; &#123; if (request.readyState === 4) &#123; if (request.status &gt;= 200 &amp;&amp; request.status &lt; 400) &#123; resolve.call(undefined, request.responseText); &#125; else if (request.status &gt;= 400) &#123; reject.call(undefined, request); &#125; &#125; &#125;; &#125;);&#125;;//使用ajaxajax(&#123; method: \"get\", path: \"https://api.github.com/search/repositories?q=javascript&amp;sort=stars\", headers: &#123; \"content-type\": \"application/json\" &#125;&#125;).then( responseText =&gt; &#123; console.log(responseText); &#125;, request =&gt; &#123; console.log(request); &#125;); jQuery 使用get 方法，返回一个 deferred 对象： 1234567891011121314151617const URL = \"https://api.github.com/search/repositories?q=javascript&amp;sort=stars\";let request = $.get(URL);request .done(function(data) &#123; console.log(data); &#125;) .fail(function(err) &#123; console.log(err); &#125;);// 或者let request = $.ajax(&#123; url: URL, type: \"GET\"&#125;);request.done(data =&gt; console.log(data)).fail(err =&gt; console.log(err)); 使用 promise： 12345678910111213141516171819202122function getData() &#123; return new Promise((resolve, reject) =&gt; &#123; $.ajax(&#123; url: \"https://api.github.com/search/repositories?q=javascript&amp;sort=stars\", type: \"GET\", success: function(data) &#123; resolve(data); &#125;, error: function(err) &#123; resolve(err); &#125; &#125;); &#125;);&#125;getData() .then(function(data) &#123; console.log(data); &#125;) .catch(function(err) &#123; console.log(err); &#125;); Fetch 函数Fetch 提供了 Request 和 Response 对象（以及与网络请求有关的其他内容）的一般定义。 Fetch API 提供了 fetch() 方法，它被定义在 BOM 的 window 对象中，你可以用它来发起对远程资源的请求。 fetch() 方法返回的是一个 Promise 对象，让你能够对请求的返回结果进行检索。 fetch 的配置： Promise fetch(String url [, Object options]); Promise fetch(Request req [, Object options]); 1234567891011const URL = 'https://api.github.com/search/repositories?q=javascript&amp;sort=stars';let req = new Request(URL, &#123; method: \"GET\", cache: \"reload\" &#125;);fetch(req) .then(function(response) &#123; return response.json(); &#125;) .then(function(json) &#123; console.log(json); &#125;).catch(function(err) &#123; console.log(err); &#125; fetch 和 ajax 的主要区别： fetch()返回的 promise 将不会拒绝 http 的错误状态，即使响应是一个 HTTP 404 或者 500 在默认情况下 fetch 不会接受或者发送 cookies Axios基本使用： 123456const URL = \"https://api.github.com/search/repositories?q=javascript&amp;sort=stars\";axios .get(URL) .then(response =&gt; console.log(response)) .catch(err =&gt; console.log(err)); 或者使用 async/await： 12345678async function getData() &#123; try &#123; return await axios.get(URL); &#125; catch (error) &#123; console.error(error); &#125;&#125;getData().then(data =&gt; console.log(data)); 资料 AJAX – JavaScript 标准参考教程(alpha) 原生 javaScript 实现 Ajax 和 jQuery 实现 Ajax 回调、使用 Promise 封装 ajax()、Promise 入门 Fetch axios-易用、简洁且高效的 http 库","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/categories/JavaScript/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://www.yangtao.site/tags/面试/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/tags/JavaScript/"},{"name":"Ajax","slug":"Ajax","permalink":"https://www.yangtao.site/tags/Ajax/"}]},{"title":"JavaScript 类型判断","slug":"code-typeof","date":"2020-01-07T06:42:25.000Z","updated":"2020-01-07T07:00:58.458Z","comments":true,"path":"2020/01/07/code-typeof/","link":"","permalink":"https://www.yangtao.site/2020/01/07/code-typeof/","excerpt":"学习JavaScript 专题之类型判断(上)的文章总结，其实就是照抄，哈哈哈哈…顺便几一句文章里的话：所有这些点，都必须脚踏实地在具体应用场景下去分析、去选择，要让场景说话。","text":"学习JavaScript 专题之类型判断(上)的文章总结，其实就是照抄，哈哈哈哈…顺便几一句文章里的话：所有这些点，都必须脚踏实地在具体应用场景下去分析、去选择，要让场景说话。 typeof最新的 ECMAScript 标准定义了 8 种数据类型： 7 种原始类型: Boolean Null Undefined Number String Symbol BigInt 和 Object 使用 typeof 检测类型如下： 12345678\"Number\"; // number\"String\"; // string\"Boolean\"; // boolean\"Undefined\"; // undefined\"Null\"; // object\"Symbol\"; // symbol\"BigInt\"; // bigint\"Object\"; // object 所以 typeof 能检测出七种基本类型的值，但是，除此之外 Object 下还有很多细分的类型呐，如 Array、Function、Date、RegExp、Error 等。 如果用 typeof 去检测这些类型，返回的都是 object，除了 Function： 123456var date = new Date();var error = new Error();var fn = function() &#123;&#125;;console.log(typeof date); // objectconsole.log(typeof error); // objectconsole.log(typeof fn); // function Object.prototype.toString所有，该如何区分 object 呢？我们用Object.prototype.toString。 规范：当 toString 方法被调用的时候，下面的步骤会被执行： 如果 this 值是 undefined，就返回 [object Undefined] 如果 this 的值是 null，就返回 [object Null] 让 O 成为 ToObject(this) 的结果 让 class 成为 O 的内部属性 [[Class]] 的值 最后返回由 &quot;[object &quot; 和 class 和 &quot;]&quot; 三个部分组成的字符串 通过规范，我们至少知道了调用 Object.prototype.toString 会返回一个由 &quot;[object &quot; 和 class 和 &quot;]&quot; 组成的字符串，而 class 是要判断的对象的内部属性。 我们可以了解到这个 class 值就是识别对象类型的关键！ 正是因为这种特性，我们可以用 Object.prototype.toString 方法识别出更多类型！ 先看下常见的 15 种（ES6 新增：Symbol Set Map，还有 BigInt）： 123456789101112131415161718192021222324252627282930313233343536373839var number = 1; // [object Number]var string = \"123\"; // [object String]var boolean = true; // [object Boolean]var und = undefined; // [object Undefined]var nul = null; // [object Null]var obj = &#123; a: 1 &#125;; // [object Object]var array = [1, 2, 3]; // [object Array]var date = new Date(); // [object Date]var error = new Error(); // [object Error]var reg = /a/g; // [object RegExp]var func = function a() &#123;&#125;; // [object Function]var symb = Symbol(\"test\"); // [object Symbol]var set = new Set(); // [object Set]var map = new Map(); // [object Map]var bigI = BigInt(1); // [object BigInt]function checkType() &#123; for (var i = 0, l = arguments.length; i &lt; l; i++) &#123; console.log(Object.prototype.toString.call(arguments[i])); &#125;&#125;checkType( number, string, boolean, und, nul, obj, array, date, error, reg, func, symb, set, map, bigI); 除了以上 15 种，还有以下 3 种： 12345678console.log(Object.prototype.toString.call(Math)); // [object Math]console.log(Object.prototype.toString.call(JSON)); // [object JSON]var fn = function() &#123; console.log(Object.prototype.toString.call(arguments)); // [object Arguments]&#125;;fn(); type API写一个 type 函数能检测各种类型的值，如果是基本类型，就使用 typeof，引用类型就使用 toString。 此外鉴于 typeof 的结果是小写，我也希望所有的结果都是小写。 12345678910111213141516var class2type = &#123;&#125;;\"Boolean Number String Function Array Date RegExp Object Error Null Undefined\" .split(\" \") .map(function(item) &#123; class2type[\"[object \" + item + \"]\"] = item.toLowerCase(); // e.g. '[object Boolean]': 'boolean' &#125;);function type(obj) &#123; if (obj == null) &#123; return obj + \"\"; // IE6 &#125; return typeof obj === \"object\" || typeof obj === \"function\" ? class2type[Object.prototype.toString.call(obj)] || \"object\" : typeof obj;&#125; 这里class2type[Object.prototype.toString.call(obj)] || &quot;object&quot;的 object，为了 ES6 新增的 Symbol、Map、Set 等类型返回 object。 当然也可以添加进去，返回的就是对应的类型： 12345678910111213141516var class2type = &#123;&#125;;\"Boolean Number String Function Array Date RegExp Object Error Null Undefined Symbol Set Map BigInt\" .split(\" \") .map(function(item) &#123; class2type[\"[object \" + item + \"]\"] = item.toLowerCase(); &#125;);function type(obj) &#123; if (obj == null) &#123; return obj + \"\"; // IE6 &#125; return typeof obj === \"object\" || typeof obj === \"function\" ? class2type[Object.prototype.toString.call(obj)] : typeof obj;&#125; isFunction123function isFunction(obj) &#123; return type(obj) === \"function\";&#125; isArray12345var isArray = Array.isArray || function(obj) &#123; return type(obj) === \"array\"; &#125;; plainObjectplainObject 来自于 jQuery，可以翻译成纯粹的对象，所谓”纯粹的对象”，就是该对象是通过 “{}” 或 “new Object” 创建的，该对象含有零个或者多个键值对。 之所以要判断是不是 plainObject，是为了跟其他的 JavaScript 对象如 null，数组，宿主对象（documents）等作区分，因为这些用 typeof 都会返回 object。 123456789101112131415161718192021222324252627282930313233343536373839404142// 上节中写 type 函数时，用来存放 toString 映射结果的对象var class2type = &#123;&#125;;// 相当于 Object.prototype.toStringvar toString = class2type.toString;// 相当于 Object.prototype.hasOwnPropertyvar hasOwn = class2type.hasOwnProperty;function isPlainObject(obj) &#123; var proto, Ctor; // 排除掉明显不是obj的以及一些宿主对象如Window if (!obj || toString.call(obj) !== \"[object Object]\") &#123; return false; &#125; /** * getPrototypeOf es5 方法，获取 obj 的原型 * 以 new Object 创建的对象为例的话 * obj.__proto__ === Object.prototype */ proto = Object.getPrototypeOf(obj); // 没有原型的对象是纯粹的，Object.create(null) 就在这里返回 true if (!proto) &#123; return true; &#125; /** * 以下判断通过 new Object 方式创建的对象 * 判断 proto 是否有 constructor 属性，如果有就让 Ctor 的值为 proto.constructor * 如果是 Object 函数创建的对象，Ctor 在这里就等于 Object 构造函数 */ Ctor = hasOwn.call(proto, \"constructor\") &amp;&amp; proto.constructor; // 在这里判断 Ctor 构造函数是不是 Object 构造函数，用于区分自定义构造函数和 Object 构造函数 return ( typeof Ctor === \"function\" &amp;&amp; hasOwn.toString.call(Ctor) === hasOwn.toString.call(Object) );&#125; EmptyObjectjQuery 提供了 isEmptyObject 方法来判断是否是空对象，代码简单： 12345678910111213141516function isEmptyObject(obj) &#123; var name; // 判断是否有属性，for 循环一旦执行，就说明有属性，有属性就会返回 false for (name in obj) &#123; return false; &#125; return true;&#125;console.log(isEmptyObject(&#123;&#125;)); // trueconsole.log(isEmptyObject([])); // trueconsole.log(isEmptyObject(null)); // trueconsole.log(isEmptyObject(undefined)); // trueconsole.log(isEmptyObject(1)); // trueconsole.log(isEmptyObject(\"\")); // trueconsole.log(isEmptyObject(true)); // true Window 对象Window 对象作为客户端 JavaScript 的全局对象，它有一个 window 属性指向自身。我们可以利用这个特性判断是否是 Window 对象。 123function isWindow(obj) &#123; return obj !== null &amp;&amp; obj === obj.window;&#125; isArrayLike如果 isArrayLike 返回 true，至少要满足三个条件之一： 是数组 长度为 0 lengths 属性是大于 0 的数字类型，并且 obj[length - 1]必须存在 12345678910111213141516function isArrayLike(obj) &#123; // obj 必须有 length属性 var length = !!obj &amp;&amp; \"length\" in obj &amp;&amp; obj.length; var typeRes = type(obj); // 排除掉函数和 Window 对象 if (typeRes === \"function\" || isWindow(obj)) &#123; return false; &#125; return ( typeRes === \"array\" || length === 0 || (typeof length === \"number\" &amp;&amp; length &gt; 0 &amp;&amp; length - 1 in obj) );&#125; isElement判断是不是 DOM 元素 123456function isElement(obj) &#123; return !!(obj &amp;&amp; obj.nodeType === 1);&#125;var div = document.createElement(\"div\");console.log(isElement(div)); // trueconsole.log(isElement(\"\")); // false 原文地址 JavaScript 专题之类型判断(上) JavaScript 专题之类型判断(下)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/categories/JavaScript/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://www.yangtao.site/tags/面试/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/tags/JavaScript/"}]},{"title":"JavaScript 数组去重的几种方式","slug":"code-unique","date":"2020-01-07T05:14:42.000Z","updated":"2020-01-07T06:37:17.108Z","comments":true,"path":"2020/01/07/code-unique/","link":"","permalink":"https://www.yangtao.site/2020/01/07/code-unique/","excerpt":"数组去重，老生常谈，把学习到的多种方式进行归纳总结","text":"数组去重，老生常谈，把学习到的多种方式进行归纳总结 双层循环第一种： 1234567891011121314function unique(arr) &#123; var result = []; for (var i = 0, arrLen = arr.length; i &lt; arrLen; i++) &#123; for (var j = 0, resLen = result.length; j &lt; resLen; j++) &#123; if (arr[i] === result[j]) &#123; break; &#125; &#125; if (j === result.length) &#123; result.push(arr[i]); &#125; &#125; return result;&#125; 第二种： 12345678910111213function unique(arr) &#123; let arrary = [].concat(arr); // 避免修改原数组，存个副本 for (let i = 0, len = arrary.length; i &lt; len; i++) &#123; for (let j = i + 1; j &lt; len; j++) &#123; if (arrary[i] === arrary[j]) &#123; arrary.splice(j, 1); // splice() 修改原数组，所以需要手动修改长度 len--; j--; &#125; &#125; &#125; return arrary;&#125; indexOf 方法12345678910function unique(arr) &#123; const result = []; for (let i = 0, len = arr.length; i &lt; len; i++) &#123; const current = arr[i]; if (result.indexOf(current) === -1) &#123; result.push(current); &#125; &#125; return result;&#125; filter + indexOf 方法12345678910function unique(arr) &#123; let result = arr.filter(function(item, index, arr) &#123; return arr.indexOf(item) === index; &#125;); return result;&#125;// ES6let unique = arr =&gt; arr.filter((item, index, arr) =&gt; arr.indexOf(item) === index); 如果我们对一个已经排好序的数组去重，这种方法效率肯定高于使用 indexOf： 12345let unique = arr =&gt; arr .concat() .sort() .filter((item, index, arr) =&gt; !index || item !== arr[index - 1]); 不过对于下面这种就会失效： 12const arr = [2, 1, 1, 3, \"1\", 1, \"1\"];//输出 [ 1, '1', 1, '1', 2, 3 ] Object 键值对利用一个空的 Object 对象，我们把数组的值存成 Object 的 key 值，比如 Object[value1] = true，在判断另一个值的时候，如果 Object[value2]存在的话，就说明该值是重复的。 12345678let unique = arr =&gt; &#123; const obj = &#123;&#125;; return arr.filter(item =&gt; obj.hasOwnProperty(typeof item + JSON.stringify(item)) ? false : (obj[typeof item + JSON.stringify(item)] = true) );&#125;; 注意： typeof item + item 是为了区分 1 还是 ‘1’ typeof item + JSON.stringify(item) 是为了区分 {value: 1}, {value: 1} 如： 1234567const arr = [1, \"1\", &#123; value: 1 &#125;, &#123; value: 1 &#125;];let getObjType = arr =&gt; arr.map(item =&gt; typeof item + JSON.stringify(item));getObjType(arr);// [\"number1\", \"string\"1\"\", \"object&#123;\"value\":1&#125;\", \"object&#123;\"value\":1&#125;\"] Set 集合 和 Map 集合ES6 去重方式已经是非常的精简： 12345678910// Setlet unique = arr =&gt; Array.from(new Set(arr))let unique = arr =&gt; [...new Set(arr)]// Maplet unique = arr =&gt; &#123; const seen = new Map(); return arr.filter(item =&gt; !seen.has(item) &amp;&amp; seen.set(item, true));&#125;; 学习资料 JavaScript 专题之数组去重","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/categories/JavaScript/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://www.yangtao.site/tags/面试/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/tags/JavaScript/"}]},{"title":"Sass 日常使用总结","slug":"css-sass","date":"2019-12-31T04:37:40.000Z","updated":"2020-01-02T12:35:28.598Z","comments":true,"path":"2019/12/31/css-sass/","link":"","permalink":"https://www.yangtao.site/2019/12/31/css-sass/","excerpt":"世界上最成熟、最稳定、最强大的专业级CSS扩展语言！ - Sass 官网简单汇总一下 sass 的日常使用，又简单地看了一下 Bootstrap@4 里应用的一个 Demo。","text":"世界上最成熟、最稳定、最强大的专业级CSS扩展语言！ - Sass 官网简单汇总一下 sass 的日常使用，又简单地看了一下 Bootstrap@4 里应用的一个 Demo。 安装我本地结合 gulp+sass 自动化工具使用，主要如下： 1npm install node-sass gulp-sass --save-dev gulpfile.js 文件主要配置如下，详情可以参考这里。 1234567891011const &#123; src, dest, watch &#125; = require(\"gulp\");const sass = require(\"gulp-sass\");sass.compiler = require(\"node-sass\");function scss() &#123; return src(scssGlobSrc) .pipe(sass(&#123; outputStyle: \"expanded\" &#125;).on(\"error\", sass.logError)) .pipe(dest(\"dist/sass\"));&#125;exports.scss = scss; 启动：gulp scss。 如何安装 Sass 四种编译排版123456789/*未编译样式*/.box &#123; width: 300px; height: 400px; &amp;-title &#123; height: 30px; line-height: 30px; &#125;&#125; nested 编译排版格式 123456789101112/*命令行内容*/sass style.scss:style.css --style nested/*编译过后样式*/.box &#123; width: 300px; height: 400px;&#125;.box-title &#123; height: 30px; line-height: 30px;&#125; expanded 编译排版格式 123456789101112/*命令行内容*/sass style.scss:style.css --style expanded/*编译过后样式*/.box &#123; width: 300px; height: 400px;&#125;.box-title &#123; height: 30px; line-height: 30px;&#125; compact 编译排版格式 123456789101112/*命令行内容*/sass style.scss:style.css --style compact/*编译过后样式*/.box &#123; width: 300px; height: 400px;&#125;.box-title &#123; height: 30px; line-height: 30px;&#125; compressed 编译排版格式 123456789101112/*命令行内容*/sass style.scss:style.css --style compressed/*编译过后样式*/.box &#123; width: 300px; height: 400px;&#125;.box-title &#123; height: 30px; line-height: 30px;&#125; 静默注释123456body &#123; // 这种注释内容不会出现在生成的css文件中 color: #333; /* 这种注释内容会出现在生成的css文件中 */ padding: 0;&#125; 12345body &#123; color: #333; /* 这种注释内容会出现在生成的css文件中 */ padding: 0;&#125; 使用变量非常简单明了，变量申明：$color: #4a4a4a;，变量引用：color: $color;，具体例子演示如下： 123456789$bg-color: #f90;$font-color: #444;body &#123; background: $bg-color; color: $font-color;&#125;.selected &#123; border: 1px solid $font-color;&#125; 12345678body &#123; background: #f90; color: #444;&#125;.selected &#123; border: 1px solid #444;&#125; 嵌套 CSS 规则文档：在 Sass 中，你可以像俄罗斯套娃那样在规则块中嵌套规则块。sass 在输出 css 时会帮你把这些嵌套规则处理好，避免你的重复书写。 看个例子，基本就知道什么意思： 12345678910111213ul &#123; li &#123; a &#123; color: $font-color; &amp;:hover &#123; color: red; &#125; &amp;::after &#123; content: \"...\"; &#125; &#125; &#125;&#125; 1234567891011ul li a &#123; color: #444;&#125;ul li a:hover &#123; color: red;&#125;ul li a::after &#123; content: \"...\";&#125; 够简洁，不过有一些嵌套规则，需要稍稍留意，比如： 父选择器的标识符&amp; 群组选择器的嵌套 子组合选择器和同层组合选择器：&gt;、+ 和 ~ 属性嵌套 父选择器的标识符父选择器的标识符&amp;，记住&amp;是爸爸，你可以在爸爸的后边，也可以在爸爸的前边，随你，哈哈哈哈： 1234567891011nav a &#123; color: $font-color; /* Dad after */ &amp;:hover &#123; color: red; &#125; /* Dad before */ .header &amp; &#123; color: #000; &#125;&#125; 12345678910111213nav a &#123; color: #444;&#125;/* Dad after */nav a:hover &#123; color: red;&#125;/* Dad before */.header nav a &#123; color: #000;&#125; Dad 是爸爸们：nav a，什么场景能用到Dad before？想想nav a是通用样式，我想给 header 组件单独nav a的样式，即.header nav a，即.header &amp;。 当然，还可以这样用： 123456789101112131415.main &#123; color: black; &amp;-sidebar &#123; border: 1px solid; &#125;&#125;// css.main &#123; color: black;&#125;.main-sidebar &#123; border: 1px solid;&#125; 群组选择器的嵌套文档例子： 12345678910111213.container &#123; h1, h2, h3 &#123; margin-bottom: 0.8em; &#125;&#125;nav,aside &#123; a &#123; color: blue; &#125;&#125; 12345678910.container h1,.container h2,.container h3 &#123; margin-bottom: 0.8em;&#125;nav a,aside a &#123; color: blue;&#125; 名字就已经告诉咱们这个规则的要点是：群组。大括号{前端的都可以是一个群组，比如.container，比如nav, aside，不论多少。 做为群组的任何一员，有权利获取子嗣，而且还得跟其他群组成员一模一样，若 Ta 有 三个（h1, h2, h3）子嗣，那群组的任何一员也得各自有三个子嗣；Ta 如果只有一个（a）子嗣，即使群组人很多，也得每个成员一人一个。 演练：有三个组件header article footer，我希望字体颜色有默认值，链接例外，并且有 hover 变化。 1234567891011.header,.acticle,.footer &#123; color: $font-color; a &#123; color: #999; &amp;:hover &#123; color: red; &#125; &#125;&#125; 1234567891011121314151617.header,.acticle,.footer &#123; color: #444;&#125;.header a,.acticle a,.footer a &#123; color: #999;&#125;.header a:hover,.acticle a:hover,.footer a:hover &#123; color: red;&#125; 子组合和同层组合子组合选择器 &gt; 和同层组合选择器 +、~，和 CSS 的规则一致。 123456789101112/* 选择article 后的同层所有 article 元素 */article ~ article &#123; border-top: 1px dashed #ccc;&#125;/* 选择nav元素后紧跟的article元素 */nav + article &#123; margin-top: 0;&#125;/* 选择article下的所有命中section选择器的元素 */article &gt; section &#123; background: #eee;&#125; 文档例子： 12345678910111213141516171819article &#123; ~ article &#123; border-top: 1px dashed #ccc; &#125; &gt; section &#123; background: #eee; &#125; dl &gt; &#123; dt &#123; color: #333; &#125; dd &#123; color: #555; &#125; &#125; nav + &amp; &#123; margin-top: 0; &#125;&#125; 12345678910111213141516171819article ~ article &#123; border-top: 1px dashed #ccc;&#125;article &gt; section &#123; background: #eee;&#125;article dl &gt; dt &#123; color: #333;&#125;article dl &gt; dd &#123; color: #555;&#125;nav + article &#123; margin-top: 0;&#125; 嵌套属性 规则：把属性名从中划线-的地方断开，在根属性后边添加一个冒号:，紧跟一个{ }块，把子属性部分写在这个{ }块中。就像 css 选择器嵌套一样，sass 会把你的子属性一一解开，把根属性和子属性部分通过中划线-连接起来，最后生成的效果与你手动一遍遍写的 css 样式一样： 123456789101112131415161718192021222324nav &#123; border: &#123; style: solid; width: 1px; color: #ccc; &#125;&#125;nav &#123; border: 1px solid #ccc &#123; left: 0px; &#125;&#125;// cssnav &#123; border-style: solid; border-width: 1px; border-color: #ccc;&#125;nav &#123; border: 1px solid #ccc; border-left: 0px;&#125; 一句话：我要把border-style里的-打断，拆散左右，并替换成:，重新使用{}嵌套使用，宗旨就是不破不立，有破才有立，把所有重复的东西统统归并，只写关键部位。 @-Rules@import 导入在单独使用 css 的 @import 规则导入文件，是不及 link 的效率，比如加载字体库，有次在项目中就吃过这个亏，那会发誓打死我也不用这个规则。 sass 的@import 规则是在生成 css 文件时就把相关文件导入进来，所以，和 css 的@import没有什么关系，放心食用。 但是由于 sass 兼容原生的 css，所以它也支持原生的 CSS@import，比如导入文件或者 url 是以 .css结尾的。 使用： 1234567891011// 常用方法@import \"header\";@import \"footer\";// 多个导入@import \"rounded-corners\", \"text-shadow\";// 嵌套导入.blue-theme &#123; @import \"blue-theme\";&#125; 如果将文件命名为 _colors.scss，便不会编译_colours.css 文件，但是导入时依然是@import &quot;colors&quot;;。 @media 媒体查询Sass 中 @media 指令与 CSS 中用法一样，不过还允许其在 CSS 规则中嵌套，编译时，@media 将被编译到文件的最外层，包含嵌套的父选择器。 1234567891011121314151617181920.sidebar &#123; width: 300px; @media screen and (orientation: landscape) &#123; width: 500px; &#125;&#125;/* 拼接 and */@media screen &#123; .sidebar &#123; @media (max-width: 1140px) &#123; width: 960px; &#125; &#125; .other &#123; @media (max-width: 640px) &#123; width: 100%; &#125; &#125;&#125; 12345678910111213141516171819202122.sidebar &#123; width: 300px;&#125;@media screen and (orientation: landscape) &#123; .sidebar &#123; width: 500px; &#125;&#125;/* 拼接 and */@media screen and (max-width: 1140px) &#123; .sidebar &#123; width: 960px; &#125;&#125;@media screen and (max-width: 640px) &#123; .other &#123; width: 100%; &#125;&#125; @extend和其他语言一样，就是继承。比如代码中的.error，以及同级.intrusion，都会被继承： 1234567891011.error &#123; border: 1px #f00; background-color: #fdd;&#125;.error.intrusion &#123; background-image: url(\"/image/hacked.png\");&#125;.seriousError &#123; @extend .error; border-width: 3px;&#125; 1234567891011121314.error,.seriousError &#123; border: 1px #f00; background-color: #fdd;&#125;.error.intrusion,.intrusion.seriousError &#123; background-image: url(\"/image/hacked.png\");&#125;.seriousError &#123; border-width: 3px;&#125; 控制指令@if和 JavaScript 的 if 一样： 12345678910$type: monster;p &#123; @if $type == ocean &#123; color: blue; &#125; @else if $type == monster &#123; color: green; &#125; @else &#123; color: black; &#125;&#125; 123p &#123; color: green;&#125; @for区别在于 through 与 to 的含义：through 包含最后一位，而 to 不包含： 12345678910@for $i from 1 to 3 &#123; .list-#&#123;$i&#125; &#123; width: 1em * $i; &#125;&#125;@for $i from 1 through 3 &#123; .item-#&#123;$i&#125; &#123; width: 2rem * $i; &#125;&#125; 12345678910111213141516171819.list-1 &#123; width: 1em;&#125;.list-2 &#123; width: 2em;&#125;.item-1 &#123; width: 2rem;&#125;.item-2 &#123; width: 4rem;&#125;.item-3 &#123; width: 6rem;&#125; @each类似于 JavaScript 的 for...in： 12345@each $kind in small, middle, large &#123; .#&#123;$kind&#125;-icon &#123; background-image: url(\"/images/#&#123;$kind&#125;-icon.png\"); &#125;&#125; 1234567891011.small-icon &#123; background-image: url(\"/images/small-icon.png\");&#125;.middle-icon &#123; background-image: url(\"/images/middle-icon.png\");&#125;.large-icon &#123; background-image: url(\"/images/large-icon.png\");&#125; 混合器混合器使用@mixin标识符定义，通过@include来使用这个混合器，用来解决大段重用的代码。 1234567891011121314151617@mixin clearfix &#123; display: inline-block; &amp;:after &#123; content: \".\"; display: block; height: 0; clear: both; visibility: hidden; &#125; * html &amp; &#123; height: 1px; &#125;&#125;.clearfix &#123; @include clearfix;&#125; 123456789101112131415.clearfix &#123; display: inline-block;&#125;.clearfix:after &#123; content: \".\"; display: block; height: 0; clear: both; visibility: hidden;&#125;* html .clearfix &#123; height: 1px;&#125; 最强大的一点就是如同函数一般，可以传参，不仅可以指定默认值，并且可以使用关键词参数，这样就不用管参数前后顺序了： 1234567891011121314151617@mixin border-value($width: 1px, $color: #333, $style: solid) &#123; border-width: $width; border-color: $color; border-style: $style;&#125;/*不传参*/h1 &#123; @include border-value;&#125;/*传参*/h2 &#123; @include border-value(2px, #666, dashed);&#125;/*关键词传参*/h3 &#123; @include border-value($style: dashed, $width: 3px, $color: #999);&#125; 1234567891011121314151617181920/*不传参*/h1 &#123; border-width: 1px; border-color: #333; border-style: solid;&#125;/*传参*/h2 &#123; border-width: 2px; border-color: #666; border-style: dashed;&#125;/*关键词传参*/h3 &#123; border-width: 3px; border-color: #999; border-style: dashed;&#125; 函数指令与 mixin 相同，也可以传递若干个全局变量给函数作为参数。一个函数可以含有多条语句，需要调用 @return 输出结果。 12345678910111213$grid-width: 40px;$gutter-width: 10px;@function grid-width($n) &#123; @return $n * $grid-width + ($n - 1) * $gutter-width;&#125;.sidebar1 &#123; width: grid-width(5);&#125;.sidebar2 &#123; width: grid-width($n: 10);&#125; 1234567.sidebar1 &#123; width: 240px;&#125;.sidebar2 &#123; width: 490px;&#125; SassScript数据类型SassScript 支持 6 种主要的数据类型： 数字，1, 2, 13, 10px 字符串，有引号字符串与无引号字符串，&quot;foo&quot;, &#39;bar&#39;, baz 颜色，blue, #04a3f9, rgba(255,0,0,0.5) 布尔型，true, false 空值，null 数组 (list)，用空格或逗号作分隔符，1.5em 1em 0 2em, Helvetica, Arial, sans-serif maps, 相当于 JavaScript 的 object，(key1: value1, key2: value2) 运算SassScript 支持数字的加减乘除、取整等运算 (+, -, *, /, %)，关系运算 &lt;, &gt;, &lt;=, &gt;= 也可用于数字运算，相等运算 ==, != 可用于所有数据类型。 插值语句 #{}通过 #{} 插值语句可以在选择器或属性名中使用变量，避免 Sass 运行运算表达式。 Bootstrap@4 Bootstrap v4.4.1 入口文件 bootstrap.scss的引入组件很多，我们就挑一个看看，比如下面是我们最终的 float 内容： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859.float-left &#123; float: left !important;&#125;.float-right &#123; float: right !important;&#125;.float-none &#123; float: none !important;&#125;@media (min-width: 576px) &#123; .float-sm-left &#123; float: left !important; &#125; .float-sm-right &#123; float: right !important; &#125; .float-sm-none &#123; float: none !important; &#125;&#125;@media (min-width: 768px) &#123; .float-md-left &#123; float: left !important; &#125; .float-md-right &#123; float: right !important; &#125; .float-md-none &#123; float: none !important; &#125;&#125;@media (min-width: 992px) &#123; .float-lg-left &#123; float: left !important; &#125; .float-lg-right &#123; float: right !important; &#125; .float-lg-none &#123; float: none !important; &#125;&#125;@media (min-width: 1200px) &#123; .float-xl-left &#123; float: left !important; &#125; .float-xl-right &#123; float: right !important; &#125; .float-xl-none &#123; float: none !important; &#125;&#125; 然后，我们去看看 bootstrap 是如何实现的： 第一步：找路根据 bootstrap.scss里的内容@import &quot;mixins&quot;;，进入当前目录下的_mixins.scss，看到@import &quot;mixins/float&quot;;，所以继续打开mixins 目录下的 _float.scss。 第二步：内容_float.scss所有内容如下： 1234567891011121314151617// stylelint-disable declaration-no-important@each $breakpoint in map-keys($grid-breakpoints) &#123; @include media-breakpoint-up($breakpoint) &#123; $infix: breakpoint-infix($breakpoint, $grid-breakpoints); .float#&#123;$infix&#125;-left &#123; float: left !important; &#125; .float#&#123;$infix&#125;-right &#123; float: right !important; &#125; .float#&#123;$infix&#125;-none &#123; float: none !important; &#125; &#125;&#125; 接着，有三个地方，我不知道是什么，如map-keys()，media-breakpoint-up()，breakpoint-infix()。 第三步：解惑 map-keys() 返回 map 里面所有的 key： 12345678910111213141516171819202122232425262728293031323334$grid-breakpoints: ( xs: 0, sm: 576px, md: 768px, lg: 992px, xl: 1200px) !default;@each $breakpoint in map-keys($grid-breakpoints) &#123; .#&#123;$breakpoint&#125; &#123; color: red; &#125;&#125;// css.xs &#123; color: red;&#125;.sm &#123; color: red;&#125;.md &#123; color: red;&#125;.lg &#123; color: red;&#125;.xl &#123; color: red;&#125; 资料：Sass map 详解 media-breakpoint-up()，自定义函数，主要是根据媒体查询给出不同的结果 123456789101112// Media of at least the minimum breakpoint width. No query for the smallest breakpoint.// Makes the @content apply to the given breakpoint and wider.@mixin media-breakpoint-up($name, $breakpoints: $grid-breakpoints) &#123; $min: breakpoint-min($name, $breakpoints); @if $min &#123; @media (min-width: $min) &#123; @content; &#125; &#125; @else &#123; @content; &#125;&#125; 这里breakpoint-min()也是个函数： 12345678// Minimum breakpoint width. Null for the smallest (first) breakpoint.//// &gt;&gt; breakpoint-min(sm, (xs: 0, sm: 576px, md: 768px, lg: 992px, xl: 1200px))// 576px@function breakpoint-min($name, $breakpoints: $grid-breakpoints) &#123; $min: map-get($breakpoints, $name); @return if($min != 0, $min, null);&#125; 这里的map-get同 map-keys用法，返回 map 里面指定可以的 value： 1234567891011121314$min-num: breakpoint-min(sm, $grid-breakpoints);@media (min-width: $min-num) &#123; p &#123; color: #444; &#125;&#125;// css@media (min-width: 576px) &#123; p &#123; color: #444; &#125;&#125; @content用在mixin里面的，当定义一个mixin后，并且设置了@content之后，、@include的时候可以传入相应的内容到mixin里面： 123456789101112131415161718$color: white;@mixin colors($color: blue) &#123; background-color: $color; @content; border-color: $color;&#125;.colors &#123; @include colors &#123; color: $color; &#125;&#125;// css.colors &#123; background-color: blue; color: white; border-color: blue;&#125; 资料：sass 语法中的@content breakpoint-infix()，自定义函数： 12345678910// Returns a blank string if smallest breakpoint, otherwise returns the name with a dash in front.// Useful for making responsive utilities.//// &gt;&gt; breakpoint-infix(xs, (xs: 0, sm: 576px, md: 768px, lg: 992px, xl: 1200px))// \"\" (Returns a blank string)// &gt;&gt; breakpoint-infix(sm, (xs: 0, sm: 576px, md: 768px, lg: 992px, xl: 1200px))// \"-sm\"@function breakpoint-infix($name, $breakpoints: $grid-breakpoints) &#123; @return if(breakpoint-min($name, $breakpoints) == null, \"\", \"-#&#123;$name&#125;\");&#125; 根据注释我们演示一下： 123456789101112131415161718$min-value-sm: breakpoint-infix(sm, $grid-breakpoints);$min-value-xs: breakpoint-infix(xs, $grid-breakpoints);.float#&#123;$min-value-sm&#125;-left &#123; float: left;&#125;.float#&#123;$min-value-xs&#125;-left &#123; float: left;&#125;// css.float-sm-left &#123; float: left;&#125;.float-left &#123; float: left;&#125; 整合最后，我们把所有关于 float 的内容组合在一起： 12345678910111213141516171819202122232425262728293031323334353637383940414243$grid-breakpoints: ( xs: 0, sm: 576px, md: 768px, lg: 992px, xl: 1200px) !default;@function breakpoint-min($name, $breakpoints: $grid-breakpoints) &#123; $min: map-get($breakpoints, $name); @return if($min != 0, $min, null);&#125;@function breakpoint-infix($name, $breakpoints: $grid-breakpoints) &#123; @return if(breakpoint-min($name, $breakpoints) == null, \"\", \"-#&#123;$name&#125;\");&#125;@mixin media-breakpoint-up($name, $breakpoints: $grid-breakpoints) &#123; $min: breakpoint-min($name, $breakpoints); @if $min &#123; @media (min-width: $min) &#123; @content; &#125; &#125; @else &#123; @content; &#125;&#125;@each $breakpoint in map-keys($grid-breakpoints) &#123; @include media-breakpoint-up($breakpoint) &#123; $infix: breakpoint-infix($breakpoint, $grid-breakpoints); .float#&#123;$infix&#125;-left &#123; float: left !important; &#125; .float#&#123;$infix&#125;-right &#123; float: right !important; &#125; .float#&#123;$infix&#125;-none &#123; float: none !important; &#125; &#125;&#125; 这样直接就可以在环境里跑起来了。","categories":[{"name":"CSS","slug":"CSS","permalink":"https://www.yangtao.site/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://www.yangtao.site/tags/CSS/"},{"name":"SASS","slug":"SASS","permalink":"https://www.yangtao.site/tags/SASS/"}]},{"title":"关于 React 状态管理那些事","slug":"react-state","date":"2019-12-29T07:56:21.000Z","updated":"2020-01-02T12:39:35.162Z","comments":true,"path":"2019/12/29/react-state/","link":"","permalink":"https://www.yangtao.site/2019/12/29/react-state/","excerpt":"目的：采用状态管理的多种方式：实现一个计数器，可以加一，减一，\u001f 置零。","text":"目的：采用状态管理的多种方式：实现一个计数器，可以加一，减一，\u001f 置零。 React state1234567891011121314151617181920212223242526272829303132333435363738import React from \"react\";export default class Counter extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; value: 0 &#125;; &#125; handleClick(actions) &#123; switch (actions) &#123; case \"INCREASE\": return this.setState((state, props) =&gt; (&#123; value: ++state.value &#125;)); case \"DECREASE\": return this.setState((state, props) =&gt; (&#123; value: --state.value &#125;)); default: return this.setState(&#123; value: 0 &#125;); &#125; &#125; render() &#123; return ( &lt;div&gt; &lt;p&gt;&#123;this.state.value&#125;&lt;/p&gt; &lt;button onClick=&#123;() =&gt; this.handleClick(\"INCREASE\")&#125;&gt;+1&lt;/button&gt; &lt;button onClick=&#123;() =&gt; this.handleClick(\"DECREASE\")&#125;&gt;-1&lt;/button&gt; &lt;button onClick=&#123;() =&gt; this.handleClick(\"RESET\")&#125;&gt;0&lt;/button&gt; &lt;/div&gt; ); &#125;&#125; FluxRedux第一步：创建 reducer 可以使用单独的一个 reducer,也可以将多个 reducer 合并为一个 reducer，即：combineReducers() action 发出命令后将 state 放入 reucer 加工函数中，返回新的 state,对 state 进行加工处理 12345678910const reducer = (state = &#123; counter: 0 &#125;, action) =&gt; &#123; switch (action.type) &#123; case \"INCREASE\": return &#123; counter: state.counter + 1 &#125;; case \"DECREASE\": return &#123; counter: state.counter - 1 &#125;; default: return state; &#125;&#125;; 第二步：创建 action 用户是接触不到 state 的，只能有 view 触发，所以，这个 action 可以理解为指令，需要发出多少动作就有多少指令 action 是一个对象，必须有一个叫 type 的参数，定义 action 类型 1234const actions = &#123; increase: () =&gt; (&#123; type: \"INCREASE\" &#125;), decrease: () =&gt; (&#123; type: \"DECREASE\" &#125;)&#125;; 第三步：创建的 store，使用 createStore 方法 store 可以理解为有多个加工机器的总工厂 提供 subscribe，dispatch，getState 这些方法。 12345678const store = createStore(reducer);store.subscribe(() =&gt; console.log(store.getState()));store.dispatch(actions.increase()); // &#123;counter: 1&#125;store.dispatch(actions.increase()); // &#123;counter: 2&#125;store.dispatch(actions.increase()); // &#123;counter: 3&#125;store.dispatch(actions.decrease()); // &#123;counter: 2&#125; 具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import React from \"react\";import &#123; createStore &#125; from \"redux\";const reducer = (state = &#123; counter: 0 &#125;, action = &#123;&#125;) =&gt; &#123; const &#123; type &#125; = action; const &#123; counter &#125; = state; switch (type) &#123; case \"INCREASE\": return &#123; counter: counter + 1 &#125;; case \"DECREASE\": return &#123; counter: counter - 1 &#125;; default: return &#123; counter: 0 &#125;; &#125;&#125;;const store = createStore(reducer);export default class CounterRedux extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; counter: 0 &#125;; this.unsubscribe = null; &#125; componentDidMount() &#123; this.unsubscribe = store.subscribe(() =&gt; &#123; this.setState(&#123; counter: store.getState().counter &#125;); &#125;); &#125; componentWillUnmount() &#123; // 取消订阅 this.unsubscribe(); &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;&#123;this.state.counter&#125;&lt;/h1&gt; &lt;button onClick=&#123;() =&gt; store.dispatch(&#123; type: \"INCREASE\" &#125;)&#125;&gt;+1&lt;/button&gt; &lt;button onClick=&#123;() =&gt; store.dispatch(&#123; type: \"DECREASE\" &#125;)&#125;&gt;-1&lt;/button&gt; &lt;button onClick=&#123;() =&gt; store.dispatch(&#123; type: \"RESET\" &#125;)&#125;&gt;0&lt;/button&gt; &lt;/div&gt; ); &#125;&#125; action 可以单独出来： 1234567const actions = &#123; increase: () =&gt; (&#123; type: \"INCREASE\" &#125;), decrease: () =&gt; (&#123; type: \"DECREASE\" &#125;), reset: () =&gt; (&#123; type: \"RESET\" &#125;)&#125;;// 触发&lt;button onClick=&#123;() =&gt; store.dispatch(actions.increase())&#125;&gt;+1&lt;/button&gt;; 主要是为了展示 redux 的一个工作流程，并没有把状态挂载在最顶层，详细完整版可以参考阮一峰老师的代码：Redux Counter Example。 Redux 的工作流程图，阮一峰博客文章摘录: React-ReduxRedux 是一款状态管理库，并且提供了 react-redux 库来与 React 亲密配合，这两者的关系如下图： 继续实现计数器，完整 Demo 可以看这里。 src 目录下大体结构： 123456789├── actions│ └── counter.jsx├── components│ └── app.jsx├── reducers│ └── counter.jsx└── store └── app.jsx├── index.jsx 首先，看入口文件 index.js: 12345678910111213141516import React from \"react\";import ReactDOM from \"react-dom\";import &#123; Provider &#125; from \"react-redux\";import &#123; createStore &#125; from \"redux\";import reducer from \"./reducers/counter.jsx\";import App from \"./store/app.jsx\";const store = createStore(reducer);ReactDOM.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt;, document.getElementById(\"root\")); Provider 组件，其实就是 Context 实现的，提供一个状态供跨组件使用，只需要把 store 给他传过去，所有的子组件就可以通过 props 属性拿到状态值。 123456789101112let Context = React.createContext();class Provider extends Component &#123; // 将React-redux中的Provide包装了react提供的API生成的Context.Provider //&lt;Provider store=&#123;xxxx&#125;&gt;&lt;/Provider&gt;，将store挂载在contex上 render() &#123; return ( &lt;Context.Provider value=&#123;&#123; store: this.props.store &#125;&#125;&gt; &#123;this.props.children&#125; //子组件 &lt;/Context.Provider&gt; ); &#125;&#125; Reducer 函数，它接受 Action 和当前 State 作为参数，返回一个新的 State，内容和之前的几乎差不多： 1import reducer from \"./reducers/counter.jsx\"; 1234567891011121314// ./reducers/counter.jsxexport default function reducer(state = &#123; counter: 0 &#125;, action = &#123;&#125;) &#123; const &#123; counter &#125; = state; const &#123; type &#125; = action; switch (type) &#123; case \"INCREASE\": return &#123; counter: counter + 1 &#125;; case \"DECREASE\": return &#123; counter: counter - 1 &#125;; default: return &#123; counter: 0 &#125;; &#125;&#125; React-Redux 的核心之一 connect 方法，用于从 UI 组件生成容器组件。connect 方法接受两个参数：mapStateToProps 和 mapDispatchToProps。它们定义了 UI 组件的业务逻辑。前者负责输入逻辑，即将 state 映射到 UI 组件的参数（props），后者负责输出逻辑，即将用户对 UI 组件的操作映射成 Action。 1import App from \"./store/app.jsx\"; 1234567891011121314151617181920// ./store/app.jsximport &#123; connect &#125; from \"react-redux\";import App from \"./../components/app.jsx\";import &#123; increaseAction, decreaseAction, resetAction&#125; from \"./../actions/counter.jsx\";// mapStateToProps用户自己定义需要的状态const mapStateToProps = state =&gt; (&#123; counter: state.counter &#125;);const mapDispatchToProps = dispatch =&gt; (&#123; onIncreaseHandle: () =&gt; dispatch(increaseAction), onDecreaseHandle: () =&gt; dispatch(decreaseAction), onResetHandle: () =&gt; dispatch(resetAction)&#125;);export default connect(mapStateToProps, mapDispatchToProps)(App); Action 的 type 属性： 1234// ./../actions/counter.jsxexport const increaseAction = &#123; type: \"INCREASE\" &#125;;export const decreaseAction = &#123; type: \"DECREASE\" &#125;;export const resetAction = &#123; type: \"RESET\" &#125;; 接着，我们看一下熟悉的 App 组件应该怎么写： 1234567891011121314151617181920212223// import App from \"./../components/app.jsx\";import React from \"react\";class App extends React.Component &#123; render() &#123; let &#123; counter, onIncreaseHandle, onDecreaseHandle, onResetHandle &#125; = this.props; return ( &lt;div&gt; &lt;h1&gt;&#123;counter&#125;&lt;/h1&gt; &lt;button onClick=&#123;onIncreaseHandle&#125;&gt;+1&lt;/button&gt; &lt;button onClick=&#123;onDecreaseHandle&#125;&gt;-1&lt;/button&gt; &lt;button onClick=&#123;onResetHandle&#125;&gt;0&lt;/button&gt; &lt;/div&gt; ); &#125;&#125;export default App; 前期做了许多工作，这里如同从父组件里获取 props 属性般获取、触发等行为，所有 store 里的 state 都通过 connect 方法给处理了： 1connect(mapStateToProps, mapDispatchToProps)(App); 到这里，计数器基本的功能都好了，我的 Demo，阮一峰老师的 Demo，以及讲解的文章，Redux 入门教程（三）：React-Redux 的用法，让 react 用起来更得心应手——（react-redux）。 React Hooks参考资料 Redux 入门教程（一）：基本用法 Redux 入门教程（三）：React-Redux 的用法 让 react 用起来更得心应手——（react-redux）","categories":[{"name":"前端框架","slug":"前端框架","permalink":"https://www.yangtao.site/categories/前端框架/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://www.yangtao.site/tags/面试/"},{"name":"react","slug":"react","permalink":"https://www.yangtao.site/tags/react/"}]},{"title":"JS 异步处理的几种方式·请求篇","slug":"async-method-2","date":"2019-12-29T07:49:41.000Z","updated":"2020-01-02T12:37:46.797Z","comments":true,"path":"2019/12/29/async-method-2/","link":"","permalink":"https://www.yangtao.site/2019/12/29/async-method-2/","excerpt":"","text":"学习资料 ES6 系列之我们来聊聊 Promise ES6 系列之异步处理实战 ES6 系列 - 冴羽的博客","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/categories/JavaScript/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://www.yangtao.site/tags/面试/"},{"name":"ES6","slug":"ES6","permalink":"https://www.yangtao.site/tags/ES6/"}]},{"title":"JS 异步处理的几种方式·红灯篇","slug":"async-method-1","date":"2019-12-29T07:44:22.000Z","updated":"2020-01-02T12:36:53.975Z","comments":true,"path":"2019/12/29/async-method-1/","link":"","permalink":"https://www.yangtao.site/2019/12/29/async-method-1/","excerpt":"题目：红灯三秒亮一次，绿灯一秒亮一次，黄灯两秒亮一次，不断交替循环","text":"题目：红灯三秒亮一次，绿灯一秒亮一次，黄灯两秒亮一次，不断交替循环 先定义下红绿灯： 123456789function red() &#123; console.log(\"red\");&#125;function green() &#123; console.log(\"green\");&#125;function yellow() &#123; console.log(\"yellow\");&#125; 异步编程的语法目标，就是怎样让它更像同步编程,有以下几种： 回调函数实现 事件监听 event 发布订阅 Publish/Subscribe Promise 和 Generator Async/await 一、回调函数这是最常见的一种方式，把函数作为参数送入，然后回调。 第一版：简单明了 123456789101112131415function step() &#123; console.log(\"wait for about 3 seconds...\"); setTimeout(() =&gt; &#123; red(); setTimeout(() =&gt; &#123; green(); setTimeout(() =&gt; &#123; yellow(); step(); &#125;, 2000); &#125;, 1000); &#125;, 3000);&#125;step(); 第二版：封装定时器 123456789101112131415161718192021var light = (timmer, cb) =&gt; &#123; setTimeout(() =&gt; &#123; cb(); &#125;, timmer);&#125;;function step(cb) &#123; light(3000, () =&gt; &#123; red(); light(1000, () =&gt; &#123; green(); light(2000, () =&gt; &#123; yellow(); step(); &#125;); &#125;); &#125;); typeof cb === \"function\" &amp;&amp; cb();&#125;step(() =&gt; console.log(\"wait for about 3 seconds...\")); 二、事件监听采用事件驱动模式。任务的执行不取决于代码的顺序，而取决于某个事件是否发生。 第一版：监听一个事件，然后触发这个事件，并且执行事件里的回调函数 12345678910111213141516// 引入 Node events 模块const events = require(\"events\");const emitter = new events.EventEmitter();// 监听emitter.on(\"lightEvent\", str =&gt; console.log(str));// 触发emitter.emit(\"lightEvent\", \"red\");emitter.emit(\"lightEvent\", \"green\");emitter.emit(\"lightEvent\", \"yellow\");// 输出// red// green// yellow 第二版：加个顺序执行 12345678910111213141516171819202122232425262728// 引入 Node events 模块const events = require(\"events\");const emitter = new events.EventEmitter();const lightHandler = (timmer, cb) =&gt; &#123; setTimeout(() =&gt; &#123; cb(); &#125;, timmer);&#125;;// 监听emitter.on(\"lightEvent\", str =&gt; console.log(str));// 触发function step() &#123; lightHandler(3000, () =&gt; &#123; emitter.emit(\"lightEvent\", \"red\"); lightHandler(1000, () =&gt; &#123; emitter.emit(\"lightEvent\", \"green\"); lightHandler(2000, () =&gt; &#123; emitter.emit(\"lightEvent\", \"yellow\"); step(); &#125;); &#125;); &#125;);&#125;step(); 依旧是回调执行，我们继续远征吧。 三、发布/订阅 “事件”，完全可以理解成”信号”。 我们假定，存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”（publish）一个信号，其他任务可以向信号中心”订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式”（publish-subscribe pattern），又称”观察者模式”（observer pattern）。 - 阮一峰 订阅者（Subscriber）把自己想订阅的事件注册（Subscribe）到调度中心（Event Channel），当发布者（Publisher）发布该事件（Publish Event）到调度中心，也就是该事件触发时，由调度中心统一调度（Fire Event）订阅者注册到调度中心的处理代码。 第一版： 1234567891011121314151617181920212223242526272829const publisher = &#123; // 缓存列表 lists: &#123;&#125;, // 订阅 subscribe: function(event, handler) &#123; (this.lists[event] || (this.lists[event] = [])).push(handler); &#125;, // 发布 publish: function() &#123; const event = [].shift.call(arguments); const events = this.lists[event]; if (!events || events.length === 0) &#123; return false; &#125; events.forEach(item =&gt; &#123; item.apply(this, arguments); &#125;); &#125;&#125;;// 订阅publisher.subscribe(\"lightEvent\", red);publisher.subscribe(\"lightEvent\", green);publisher.subscribe(\"lightEvent\", yellow);// 发布publisher.publish(\"lightEvent\"); 第二版： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465const publisher = &#123; // 缓存列表 lists: &#123;&#125;, // 订阅 subscribe: function(event, handler) &#123; (this.lists[event] || (this.lists[event] = [])).push(handler); &#125;, // 取消订阅 unsubscribe: function(event, handler) &#123; const events = this.lists[event]; if (!events) &#123; return false; &#125; if (!handler) &#123; events &amp;&amp; (events.length = 0); &#125; else &#123; events.forEach((item, i) =&gt; &#123; if (item === handler) &#123; events.splice(i, 1); &#125; &#125;); &#125; &#125;, // 发布 publish: function() &#123; const event = [].shift.call(arguments); const events = this.lists[event]; if (!events || events.length === 0) &#123; return false; &#125; events.forEach(item =&gt; &#123; item.apply(this, arguments); &#125;); &#125;&#125;;const lightHandler = (timmer, cb) =&gt; &#123; setTimeout(() =&gt; &#123; cb(); &#125;, timmer);&#125;;const colorHandler = color =&gt; console.log(color);// 订阅publisher.subscribe(\"redEvent\", colorHandler);publisher.subscribe(\"greenEvent\", colorHandler);publisher.subscribe(\"yellowEvent\", colorHandler);function step() &#123; lightHandler(3000, () =&gt; &#123; publisher.publish(\"redEvent\", \"red\"); lightHandler(1000, () =&gt; &#123; publisher.publish(\"greenEvent\", \"green\"); lightHandler(2000, () =&gt; &#123; publisher.publish(\"yellowEvent\", \"yellow\"); step(); &#125;); &#125;); &#125;);&#125;step(); 三、Promise直接上代码： 123456789101112131415161718192021222324252627var light = (timmer, cb) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; cb(); resolve(); &#125;, timmer); &#125;);&#125;;var step = () =&gt; &#123; Promise.resolve() .then(() =&gt; &#123; return light(3000, red); &#125;) .then(() =&gt; &#123; return light(1000, green); &#125;) .then(() =&gt; &#123; return light(2000, yellow); &#125;) .then(() =&gt; &#123; step(); &#125;) .catch(err =&gt; console.log(err));&#125;;step(); 四、GeneratorPromise 的写法减少了好多回调，但是仍有回调的存在，这次尝试使用 Generator，看是否能够避免回调。 12345678910111213141516171819202122232425262728293031const light = (timmer, cb) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; cb(); resolve(); &#125;, timmer); &#125;);&#125;;function* gen() &#123; yield light(3000, red); yield light(1000, green); yield light(3000, yellow);&#125;const iterator = gen();const step = (gen, iterator) =&gt; &#123; const s = iterator.next(); // 返回 &#123; value: Promise &#123; &lt;pending&gt; &#125;, done: false &#125; if (s.done) &#123; step(gen, gen()); &#125; else &#123; // value 返回 Promise 对象 s.value.then(() =&gt; &#123; step(gen, iterator); &#125;); &#125;&#125;;step(gen, iterator); 五、Async/await有了 Generator 做铺垫，async/await 就比较容易理解了： 1234567891011121314151617const light = (timmer, cb) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; cb(); resolve(); &#125;, timmer); &#125;);&#125;;async function step() &#123; await light(3000, red); await light(1000, green); await light(2000, yellow); step();&#125;step(); 同步写法，容易理解，和我们的线性思考方式一致，async/await是 ES2017 的方案。 学习资料 一道关于 Promise 应用的面试题 ES6 系列之我们来聊聊 Promise Javascript 异步编程的 4 种方法 JavaScript | 异步处理 nodejs 事件的监听与事件的触发 JavaScript 发布-订阅模式 JavaScript 实现与使用发布/订阅模式详解","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/categories/JavaScript/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://www.yangtao.site/tags/面试/"},{"name":"ES6","slug":"ES6","permalink":"https://www.yangtao.site/tags/ES6/"}]},{"title":"探一下 NodeList 和 HTMLCollection","slug":"html-nodelist","date":"2019-12-03T10:09:36.000Z","updated":"2019-12-03T10:13:32.294Z","comments":true,"path":"2019/12/03/html-nodelist/","link":"","permalink":"https://www.yangtao.site/2019/12/03/html-nodelist/","excerpt":"主要区别是，NodeList 可以包含各种类型的节点，HTMLCollection 只能包含 HTML 元素节点。","text":"主要区别是，NodeList 可以包含各种类型的节点，HTMLCollection 只能包含 HTML 元素节点。 NodeList 接口NodeList 实例是一个类似数组的对象，它的成员是节点对象。通过以下方法可以得到 NodeList 实例。 Node.childNodes document.querySelectorAll() 等节点搜索方法 NodeList 实例很像数组，可以使用 length 属性和 forEach 方法。但是，它不是数组，不能使用 pop 或 push 之类数组特有的方法。 如果 NodeList 实例要使用数组方法，可以将其转为真正的数组。 除了使用 forEach 方法遍历 NodeList 实例，还可以使用 for 循环。 NodeList.prototype.length，length 属性返回 NodeList 实例包含的节点数量 NodeList.prototype.forEach()，遍历 NodeList 的所有成员 NodeList.prototype.item()，item 方法接受一个整数值作为参数，表示成员的位置，返回该位置上的成员。 下面三个方法，都返回一个 ES6 的遍历器对象，for...of 可获取每一个成员信息： NodeList.prototype.keys()，返回键名的遍历器 NodeList.prototype.values()，返回键值的遍历器 NodeList.prototype.entries()，返回的遍历器 HTMLCollection 接口HTMLCollection 是一个节点对象的集合，只能包含元素节点（element），不能包含其他类型的节点。 它的返回值是一个类似数组的对象，但是与 NodeList 接口不同，HTMLCollection 没有 forEach 方法，只能使用 for 循环遍历。 返回 HTMLCollection 实例的，主要是一些 Document 对象的集合属性，比如 document.links、document.forms、document.images 等。 HTMLCollection.prototype.length HTMLCollection.prototype.item() HTMLCollection.prototype.namedItem()，参数是一个字符串，表示 id 属性或 name 属性的值，返回对应的元素节点。如果没有对应的节点，则返回 null。 对比共同点： 类数组对象，有 length 属性 共同的方法：item，可以通过 item(index) 或者 item(id) 来访问返回结果中的元素 实时变动的（live），document 上的更改会反映到相关对象上（例外：document.querySelectorAll 返回的 NodeList 不是实时的） 区别： NodeList 可以包含任何节点类型，HTMLCollection 只包含元素节点（elementNode），elementNode 就是 HTML 中的标签 HTMLCollection 比 NodeList 多一项方法：namedItem，可以通过传递 id 或 name 属性来获取节点信息 参考资料： NodeList 接口，HTMLCollection 接口 HTMLCollection vs. NodeList","categories":[{"name":"Html","slug":"Html","permalink":"https://www.yangtao.site/categories/Html/"}],"tags":[{"name":"Html","slug":"Html","permalink":"https://www.yangtao.site/tags/Html/"}]},{"title":"将 Hexo 和 Vuepress 静态资源推送至 Ubuntu","slug":"ubuntu-aliyun","date":"2019-11-27T15:50:05.000Z","updated":"2019-11-27T15:51:26.920Z","comments":true,"path":"2019/11/27/ubuntu-aliyun/","link":"","permalink":"https://www.yangtao.site/2019/11/27/ubuntu-aliyun/","excerpt":"由于已经开通的 Hexo 和 Vuepress 博客，都挂在 github 的免费服务器上，加载速度不堪忍睹，所以打算挂在阿里云的服务器上，过程可以用举步维艰来形容。","text":"由于已经开通的 Hexo 和 Vuepress 博客，都挂在 github 的免费服务器上，加载速度不堪忍睹，所以打算挂在阿里云的服务器上，过程可以用举步维艰来形容。 使用 ssh 远程登录 Ubuntu 常用命令： 123456789101112131415# 更新源列表apt-get update# 安装 SSHapt-get install openssh-server# 查看 SSH 服务是否启动ps -e | grep ssh# 停止、重启service ssh stopservice ssh start# 查看 ipifconfig 使用 ssh 登录： 1ssh root@47.101.33.81 由于之前我远程登录过 CentOS，所以换成 Ubuntu 之后，再次远程登录，就会出现如下无法连接信息： 1234567891011121314~ ❯❯❯ ssh root@47.101.33.81@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!Someone could be eavesdropping on you right now (man-in-the-middle attack)!It is also possible that a host key has just been changed.The fingerprint for the ECDSA key sent by the remote host isSHA256:neXCznmpgVyF/0YSiDxOjD/8A1+4ND2D9+fZjUozbzc.Please contact your system administrator.Add correct host key in /Users/yangtao/.ssh/known_hosts to get rid of this message.Offending ECDSA key in /Users/yangtao/.ssh/known_hosts:5ECDSA host key for 47.101.33.81 has changed and you have requested strict checking.Host key verification failed. 所以，根据提示，我就进入目录下，删除了之前保留的信息： 1~ ❯❯❯ vim /Users/yangtao/.ssh/known_hosts 然后，保存，再次登录，就会重新设置，也就远程登录成功。 在 Ubuntu 18.04 上安装和配置 Nginx安装 Nginx我习惯 fish，可以预装一下： 1234apt install fishroot@istaotao:~# fishWelcome to fish, the friendly interactive shell 注：如果遇到权限问题，需要 sudo，如：sudo apt install fish。 Nginx 的软件包在 Ubuntu 默认软件仓库中可用。 安装非常简单，只需键入以下命令： 12apt updateapt install nginx 检查 Nginx 服务的状态： 1systemctl status nginx 查看版本： 12root@istaotao ~# nginx -vnginx version: nginx/1.14.0 (Ubuntu) 然后访问公网 ip，或者域名，就可以看到欢迎界面，如果长时间没有响应，说明你的服务器应该没有开启 80 端口。 参考：阿里云 ubuntu nginx 无法访问，求解答 使用 systemctl 管理 Nginx 服务您可以像任何其他 systemd 单位一样管理 Nginx 服务： 1234567891011121314151617181920# 要停止Nginx服务，请运行：systemctl stop nginx# 要再次启动，请键入：systemctl start nginx# 重新启动Nginx服务：systemctl restart nginx# 在进行一些配置更改后重新加载Nginx服务：systemctl reload nginx# 如果你想禁用Nginx服务在启动时启动：systemctl disable nginx# 并重新启用它：systemctl enable nginx# 检查Web服务器是否在运行systemctl status nginx 也可以使用 service 管理 Nginx 服务： 1234567891011# 停止Nginx服务，请运行：service nginx stop# 要再次启动，请键入：service nginx start#重新启动Nginx服务：service nginx restart#在进行一些配置更改后重新加载Nginx服务：service nginx reload 其他命令获得应用程序配置文件的列表：ufw app list，查看状态：ufw status 123456root@istaotao ~# ufw app listAvailable applications: Nginx Full Nginx HTTP Nginx HTTPS OpenSSH Nginx 文件和目录说明nginx 服务器配置文件： /etc/nginx Nginx 配置目录。所有的 Nginx 配置文件都驻留在这里。 /etc/nginx/nginx.conf 主要的 Nginx 配置文件。 这可以修改，以更改 Nginx 全局配置。 /etc/nginx/sites-available/ 可存储每个站点服务器块的目录。 除非将 Nginx 链接到sites-enabled了sites-enabled目录，否则 Nginx 不会使用此目录中的配置文件。 通常，所有服务器块配置都在此目录中完成，然后通过链接到其他目录启用。 /etc/nginx/sites-enabled/ 存储启用的每个站点服务器块的目录。 通常，这些是通过链接到 sites-available 目录中的配置文件创建的。 /etc/nginx/snippets 这个目录包含可以包含在 Nginx 配置其他地方的配置片段。 可重复配置的片段可以重构为片段。 nginx 服务器日志文件： /var/log/nginx/access.log 除非 Nginx 配置为其他方式，否则每个对您的 Web 服务器的请求都会记录在此日志文件中。 /var/log/nginx/error.log 任何 Nginx 错误都会记录在这个日志中。 虚拟站点的设置Ubuntu 18.04 上的 Nginx 默认启用了一个服务器模块，该模块被配置为在/var/www/html目录下提供文档内容。 接下来，我们模拟一个虚拟网点。 创建example.com目录，使用-p标志创建任何必需的父目录： 1sudo mkdir -p /var/www/example.com/html 使用\\$USER 环境变量分配目录的所有权： 1sudo chown -R $USER:$USER /var/www/example.com/html/ 修改目录的权限： 1sudo chmod -R 755 /var/www/example.com/html/ 创建一个 index.html 页面： 1/var/www/example.com/html/index.html 如： 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;Welcome to Example.com!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Success! The example.com server block is working!&lt;/h1&gt; &lt;/body&gt;&lt;/html&gt; 在不直接修改默认配置文件的情况下，可以在/etc/nginx/sites-available/上创建一个新文件example.com，并将如下内容复制到example.com： 12345678910111213server &#123; listen 80; listen [::]:80; root /var/www/example.com/html; index index.html index.htm index.nginx-debian.html; server_name example.com www.example.com; location / &#123; try_files $uri $uri/ =404; &#125;&#125; 操作方法： 123cd /etc/nginx/sites-available/touch example.comvim example.com 常规复制完毕之后，按:之后，接着按wq，vim 就可以保存退出了。 创建一个软链接，连到默认启动sites-enabled目录来启用该文件，该目录是 Nginx 在启动过程中读取的： 1sudo ln -s /etc/nginx/sites-available/example.com /etc/nginx/sites-enabled/ 现在启用两个服务器模块并将其配置为基于listen和server_name指令响应请求： example.com ：将响应example.com和www.example.com请求。 default ：将响应端口80上与其他两个块不匹配的任何请求。 为了避免添加额外的服务器名称可能导致的哈希桶内存问题，有必要调整/etc/nginx/nginx.conf文件中的单个值。 修改配置文件： 1sudo vim /etc/nginx/nginx.conf 找到server_names_hash_bucket_size 64指令并删除 # 符号以取消注释该行： 接下来，测试以确保您的 Nginx 文件中没有语法错误： 1234sudo nginx -tnginx: the configuration file /etc/nginx/nginx.conf syntax is oknginx: configuration file /etc/nginx/nginx.conf test is successful 重启 nginx： 1sudo systemctl restart nginx 然后，需要在本地 hosts 文件添加对应 host： 12# ip 换成自己的阿里云 ip47.101.33.81 www.example.com 这样，不出意外的话，就可以通过 http://example.com来访问刚刚设置的内容，而访问http://47.101.33.81，依旧是默认的内容。 hexo 部署到服务器上整个流程就是本地将 *.md 渲染成静态文件，然后 Git 推送到服务器的 repository,服务器再通过 git-hooks 同步网站根目录。 服务器配置主要使用 git hooks 来实现自动化部署。以下步骤为其他博客完整内容，但是我是直接在 root 下操作的，所以关于权限等问题，是直接略过的，等后期熟悉了再加上。 第一步安装 git： 1sudo apt-get install git 第二步创建一个 git 用户，用来运行 git 服务： 1sudo adduser git 虽说现在的仓库只有我们自己在使用，新建一个 git 用户显得不是很有必要，但是为了安全起见，还是建议使用单独的 git 用户来专门运行 git 服务。 第三步创建证书登录，把自己电脑的公钥，也就是 ~/.ssh/id_rsa.pub 文件里的内容添加到服务器的 /home/git/.ssh/authorized_keys 文件中，添加公钥之后可以防止每次 push 都输入密码。 如果你之前没有生成过公钥，则可能就没有 id_rsa.pub 文件，具体的生成方法，可以Generating a new SSH key and adding it to the ssh-agent。 第四步初始化 Git 仓库，我是将其放在 /var/repo/hexo.git 目录下的 123sudo mkdir /var/repocd /var/reposudo git init --bare hexo.git 使用 --bare 参数，Git 就会创建一个裸仓库，裸仓库没有工作区，我们不会在裸仓库上进行操作，它只为共享而存在。 第五步配置 git hooks，关于 hooks 的详情内容可以自定义 Git - Git 钩子。 我们这里要使用的是 post-receive 的 hook，这个 hook 会在整个 git 操作过程完结以后被运行。 在 hexo.git/hooks 目录下新建一个 post-receive 文件： 12cd /var/repo/blog.git/hooksvim post-receive 在 post-receive 文件中写入如下内容： 12#!/bin/shgit --work-tree=/var/www/hexo --git-dir=/var/repo/hexo.git checkout -f 注意，/var/www/hexo 要换成你自己的部署目录，一般可能都是 /var/www/html。上面那句 git 命令可以在我们每次 push 完之后，把部署目录更新到博客的最新生成状态。这样便可以完成达到自动部署的目的了。 不要忘记设置这个文件的可执行权限： 1chmod +x post-receive 第六步改变 hexo.git 目录的拥有者为 git 用户： 1sudo chown -R git:git blog.git 第七步禁用 git 用户的 shell 登录权限。 出于安全考虑，我们要让 git 用户不能通过 shell 登录。可以编辑 /etc/passwd 来实现，在 /etc/passwd 中找到类似下面的一行： 1git:x:1001:1001:,,,:/home/git:/bin/bash 将其改为： 1git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell 这样 git 用户可以通过 ssh 正常使用 git，但是无法登录 sehll。 第八步修改 nginx 配置文件： 12345678vim /etc/nginx/sites-enabled/default# 修改默认目录为自己的目录root /var/www/hexo/;# 保存退出Esc:wq 至此，服务器端的配置就完成了。 本地配置修改 Hexo 博客站点配置文件 _config.yml, 如下修改: 1234deploy: type: git repo: root@47.101.33.81:/var/repo/hexo.git branch: master repo 格式：用户名@域名或 IP 地址:/var/repo/hexo.git，如： 12345678# root 域名root@istaotao.com:/var/repo/hexo.git# root iproot@47.101.33.81:/var/repo/hexo.git# git 域名git@istaotao.com:/var/repo/hexo.git 然后就是 hexo 的常规操作了： 12345# 清楚缓存hexo clean# 构建并部署hexo g -d 可以多部署几次，然后去 /var/www/hexo 看是否已经有对应内容，如果推送完之后，提示已无更新内容可提交，可以改写东西，重新构建部署等步骤，多试几次。 到这里，基本完成 Hexo 推送到 ubuntu 的任务, 通过服务器 IP 或者域名应该就可以看到博客的内容了。 vuepress 部署到服务器上有了部署 Hexo 的经验，再部署 vuepress，就简单多了。 我的想法是：hexo 做首页，vuepress 做子页内容，比如：http:yangtao.site/vuepress。所以，建立 git hooks 就应该可以了。 服务端配置第一步：修改 nginx 配置文件： 1vim /etc/nginx/sites-enabled/default 找到 location / {，然后在其后面，输入一段： 123456789101112# 找到如下location / &#123; # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. try_files $uri $uri/ =404;&#125;# 输入如下location /vuepress &#123; root /var/www/; try_files $uri $uri/ =404;&#125; 然后在var/www下新建 vuepress 目录： 12cd /var/www/mkdir vuepress 这样，对用要访问的目录已经创建好了。 注：以上操作都是在 root 权限下操作的，如果是其他用户，记得该加 sudo 的加 sudo，该修改文件权限就修改。 第二步：建立 git hooks 如同建立 hexo.git 一样： 初始化： 12cd /var/repogit init --bare vuepress.git 建立 post-receive: 12cd vuepress.git/hooks/touch post-receive 并写入： 12#!/bin/shgit --work-tree=/var/www/vuepress --git-dir=/var/repo/vuepress.git checkout -f 设置这个文件的可执行权限： 1chmod +x post-receive 好了，服务端的配置差不多就这些。 本地配置具体的可以参考官方部署方法。 第一步：根目录下创建执行脚本deploy.sh: 1234567891011121314151617181920212223242526#!/usr/bin/env sh# 确保脚本抛出遇到的错误set -e# 生成静态文件npm run build# 进入生成的文件夹cd docs/.vuepress/dist# 如果是发布到自定义域名# echo 'www.example.com' &gt; CNAMEgit initgit add -Agit commit -m 'deploy'# 如果发布到 https://&lt;USERNAME&gt;.github.io# git push -f git@github.com:&lt;USERNAME&gt;/&lt;USERNAME&gt;.github.io.git master# 如果发布到 https://&lt;USERNAME&gt;.github.io/&lt;REPO&gt;# git push -f git@github.com:&lt;USERNAME&gt;/&lt;REPO&gt;.git master:gh-pagesgit push -f root@47.101.33.81:/var/repo/vuepress.git mastercd - 第二步：修改config.js的基准 url 123const config = &#123; base: \"/vuepress/\" // 基准 URL&#125;; 这样，访问 http://47.101.33.81/vuepress，就可以正常访问,这里非常关键，如果是根目录，直接去掉 vuepress，重新构建部署。 第三步：部署线上 123456sh deploy.sh# 开始自动构建、部署...# 输入服务端密码...# ...# success 注意：可以多部署几次，访问资源如有问题，估计是第二步出问题了，可以排查哪里出错了。 好了，截止到现在，访问http://47.101.33.81，访问的是 hexo 的博客资源，而访问http://47.101.33.81/vuepress，访问的是 vuepress 的博客资源。 主要是 nginx 的配置文件，以及 git hooks 的建立，还有本地部署文件的建设，一个简单的个人网站算是颤颤巍巍地站起来了。 资料学习资料 在 Ubuntu Server 下搭建 LAMP 环境 - 让你理解 LAMP 环境各个组件之间的关系与作用，并能掌握从无到有的在 Ubuntu Server 操作系统下搭建 LAMP 环境、配置虚拟主机、数据库远程维护等常见的服务器搭建维护技能 优雅玩转 Vim - 本课程系统提炼 vim 的精华、通过抛砖引玉把它展现到你的面前，更能让你的工作如虎添翼、事半功倍。 玩转 Vim 从放弃到爱不释手 - 本课程从 vim 最基础的操作和概念开始讲起，带领大家学会使用和配置 vim，安装强大的 vim 插件，真正掌握编辑器之神 vim 的使用。 项目上线流程 - 主要讲解了一个项目想要发布到公网的流程，包括服务器的购买、以及域名的购买，以及需要注意的事项。 Linux 达人养成计划 I - 课程以 CentOS 操作系统为例，为你带来 Linux 的简介、系统安装和常用命令等内容。让您在轻松的氛围中感受到 Linux 之美。 参考资料 Nginx 使用及配置 在 Ubuntu 18.04 上安装和配置 Nginx Ubuntu18.04 搭建 nginx 服务器 阿里云 Ubuntu 16.04 系统下安装 Nginx Linux 系统下如何查看及修改文件读写权限 vim 基本操作 阿里云 ubuntu nginx 无法访问，求解答 Hexo 个人博客部署到 CentOS 个人服务器 Hexo 部署在阿里云服务器上 通过 Git 将 Hexo 博客部署到服务器 使用 Git Hook 自动部署 Hexo 到个人 VPS 超详细动手搭建一个 Vuepress 站点及开启 PWA 与自动部署","categories":[{"name":"服务端","slug":"服务端","permalink":"https://www.yangtao.site/categories/服务端/"}],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://www.yangtao.site/tags/Ubuntu/"}]},{"title":"学习冴羽的 JS 深入系列·下篇","slug":"js-series-3","date":"2019-11-27T13:05:40.000Z","updated":"2019-11-27T13:08:12.537Z","comments":true,"path":"2019/11/27/js-series-3/","link":"","permalink":"https://www.yangtao.site/2019/11/27/js-series-3/","excerpt":"主要是讲述了创建对象、继承的多种方式及其各自的优缺点","text":"主要是讲述了创建对象、继承的多种方式及其各自的优缺点 创建对象的多种方式以及优缺点这篇文章更像是笔记，因为《JavaScript 高级程序设计》写得真是太好了！ 工厂模式1234567891011function createPerson(name) &#123; var o = new Object(); o.name = name; o.getName = function() &#123; console.log(this.name); &#125;; return o;&#125;var person1 = createPerson(\"kevin\"); 缺点：对象无法识别，因为所有的实例都指向一个原型 构造函数模式12345678function Person(name) &#123; this.name = name; this.getName = function() &#123; console.log(this.name); &#125;;&#125;var person1 = new Person(\"kevin\"); 优点：实例可以识别为一个特定的类型 缺点：每次创建实例时，每个方法都要被创建一次 构造函数模式优化 12345678910function Person(name) &#123; this.name = name; this.getName = getName;&#125;function getName() &#123; console.log(this.name);&#125;var person1 = new Person(\"kevin\"); 优点：解决了每个方法都要被重新创建的问题 缺点：全局命名变量太多 原型模式12345678function Person(name) &#123;&#125;Person.prototype.name = \"keivn\";Person.prototype.getName = function() &#123; console.log(this.name);&#125;;var person1 = new Person(); 优点：方法不会重新创建 缺点：1. 所有的属性和方法都共享； 2. 不能初始化参数； 原型模式优化 1 12345678910function Person(name) &#123;&#125;Person.prototype = &#123; name: \"kevin\", getName: function() &#123; console.log(this.name); &#125;&#125;;var person1 = new Person(); 优点：封装性好了一点 缺点：重写了原型，丢失了 constructor 属性 原型模式优化 2 1234567891011function Person(name) &#123;&#125;Person.prototype = &#123; constructor: Person, name: \"kevin\", getName: function() &#123; console.log(this.name); &#125;&#125;;var person1 = new Person(); 优点：实例可以通过 constructor 属性找到所属构造函数 缺点：原型模式该有的缺点还是有 组合模式构造函数模式与原型模式双剑合璧。 123456789101112function Person(name) &#123; this.name = name;&#125;Person.prototype = &#123; constructor: Person, getName: function() &#123; console.log(this.name); &#125;&#125;;var person1 = new Person(); 优点：该共享的共享，该私有的私有，使用最广泛的方式 缺点：有的人就是希望全部都写在一起，即更好的封装性 动态原型模式 12345678910function Person(name) &#123; this.name = name; if (typeof this.getName != \"function\") &#123; Person.prototype.getName = function() &#123; console.log(this.name); &#125;; &#125;&#125;var person1 = new Person(); 注意：使用动态原型模式时，不能用对象字面量重写原型 解释下为什么： 1234567891011121314151617181920function Person(name) &#123; this.name = name; if (typeof this.getName != \"function\") &#123; Person.prototype = &#123; constructor: Person, getName: function() &#123; console.log(this.name); &#125; &#125;; &#125;&#125;var person1 = new Person(\"kevin\");var person2 = new Person(\"daisy\");// 报错 并没有该方法person1.getName();// 注释掉上面的代码，这句是可以执行的。person2.getName(); 为了解释这个问题，假设开始执行var person1 = new Person(&#39;kevin&#39;)。 如果对 new 和 apply 的底层执行过程不是很熟悉，可以阅读底部相关链接中的文章。 我们回顾下 new 的实现步骤： 首先新建一个对象，然后将对象的原型指向 Person.prototype，然后 Person.apply(obj)返回这个对象。 注意这个时候，回顾下 apply 的实现步骤，会执行 obj.Person 方法，这个时候就会执行 if 语句里的内容，注意构造函数的 prototype 属性指向了实例的原型，使用字面量方式直接覆盖 Person.prototype，并不会更改实例的原型的值，person1 依然是指向了以前的原型，而不是 Person.prototype。而之前的原型是没有 getName 方法的，所以就报错了！ 如果你就是想用字面量方式写代码，可以尝试下这种： 12345678910111213141516171819function Person(name) &#123; this.name = name; if (typeof this.getName != \"function\") &#123; Person.prototype = &#123; constructor: Person, getName: function() &#123; console.log(this.name); &#125; &#125;; return new Person(name); &#125;&#125;var person1 = new Person(\"kevin\");var person2 = new Person(\"daisy\");person1.getName(); // kevinperson2.getName(); // daisy 寄生构造函数模式12345678910111213function Person(name) &#123; var o = new Object(); o.name = name; o.getName = function() &#123; console.log(this.name); &#125;; return o;&#125;var person1 = new Person(\"kevin\");console.log(person1 instanceof Person); // falseconsole.log(person1 instanceof Object); // true 寄生构造函数模式，我个人认为应该这样读：寄生-构造函数-模式，也就是说寄生在构造函数的一种方法。 也就是说打着构造函数的幌子挂羊头卖狗肉，你看创建的实例使用 instanceof 都无法指向构造函数！ 这样方法可以在特殊情况下使用。比如我们想创建一个具有额外方法的特殊数组，但是又不想直接修改 Array 构造函数，我们可以这样写： 123456789101112131415161718192021function SpecialArray() &#123; var values = new Array(); for (var i = 0, len = arguments.length; i &lt; len; i++) &#123; values.push(arguments[i]); &#125; values.toPipedString = function() &#123; return this.join(\"|\"); &#125;; return values;&#125;var colors = new SpecialArray(\"red\", \"blue\", \"green\");var colors2 = SpecialArray(\"red2\", \"blue2\", \"green2\");console.log(colors);console.log(colors.toPipedString()); // red|blue|greenconsole.log(colors2);console.log(colors2.toPipedString()); // red2|blue2|green2 你会发现，其实所谓的寄生构造函数模式就是比工厂模式在创建对象的时候，多使用了一个 new，实际上两者的结果是一样的。 但是作者可能是希望能像使用普通 Array 一样使用 SpecialArray，虽然把 SpecialArray 当成函数也一样能用，但是这并不是作者的本意，也变得不优雅。 在可以使用其他模式的情况下，不要使用这种模式。 但是值得一提的是，上面例子中的循环： 123for (var i = 0, len = arguments.length; i &lt; len; i++) &#123; values.push(arguments[i]);&#125; 可以替换成： 1values.push.apply(values, arguments); 稳妥构造函数模式1234567891011121314151617function person(name) &#123; var o = new Object(); o.sayName = function() &#123; console.log(name); &#125;; return o;&#125;var person1 = person(\"kevin\");person1.sayName(); // kevinperson1.name = \"daisy\";person1.sayName(); // kevinconsole.log(person1.name); // daisy 所谓稳妥对象，指的是没有公共属性，而且其方法也不引用 this 的对象。 与寄生构造函数模式有两点不同： 新创建的实例方法不引用 this 不使用 new 操作符调用构造函数 稳妥对象最适合在一些安全的环境中。 稳妥构造函数模式也跟工厂模式一样，无法识别对象所属类型。 原文链接：JavaScript 深入之创建对象的多种方式以及优缺点 继承的多种方式和优缺点原型链继承123456789101112function Parent() &#123; this.name = 'Yang';&#125;Parent.prototype.getName = function() &#123; return this.name;&#125;function Child() &#123; &#125;Child.prototype = new Parent();var myself = new Child();myself.getName(); // 'Yang' 问题： 引用类型的属性被所有实例共享 在创建 Child 的实例时，不能向Parent传参 借用构造函数(经典继承)12345678910function Parent(name) &#123; this.name = name;&#125;function Child(name) &#123; Parent.call(this, name);&#125;var myself1 = new Child('Yang');var myself2 = new Child('Wang');console.log(myself1.name) // 'Yang'console.log(myself2.name) // 'Wang' 优点： 避免了引用类型的属性被所有实例共享 可以在 Child 中向 Parent 传参 缺点： 方法都在构造函数中定义，每次创建实例都会创建一遍方法 组合继承原型链继承和经典继承双剑合璧。 12345678910111213141516171819202122232425262728function Parent(name) &#123; this.name = name; this.colors = ['red', 'blue', 'green'];&#125;Parent.prototype.getName = function() &#123; return this.name;&#125;function Child(name, age) &#123; Parent.call(this, name); this.age = age;&#125;Child.prototype = new Parent();Child.prototype.constructor = Child;var child1 = new Child('yang', 27);child1.colors.push('white');console.log(child1.name); // \"yang\"console.log(child1.age); // 27console.log(child1.colors); // [\"red\", \"blue\", \"green\", \"white\"]var child2 = new Child('ming', 20);console.log(child2.name); // \"ming\"console.log(child2.age); // 20console.log(child2.colors); // [\"red\", \"blue\", \"green\"]child2.getName(); // \"ming\" 优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。 原型式继承就是 ES5 [Object.create](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create) 的模拟实现，将传入的对象作为创建的对象的原型。 12345function createObj(proto) &#123; function F() &#123;&#125; F.prototype = proto; return new F();&#125; 缺点：包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。 寄生式继承创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象。 1234567function createObj(o) &#123; var clone = Object.create(o); clone.sayName = function() &#123; console.log('hi'); &#125;; return clone;&#125; 缺点：跟借用构造函数模式一样，每次创建对象都会创建一遍方法。 寄生组合式继承组合继承最大的缺点是会调用两次父构造函数。 设置子类型实例的原型的时候：Child.prototype = new Parent(); 创建子类型实例的时候：Parent.call(this, name); 123456789101112function object(proto) &#123; function F() &#123;&#125; F.prototype = proto; return new F();&#125;function prototype(child, parent) &#123; var prototype = object(parent.prototype); child.prototype.constructor = child; child.prototype = prototype;&#125;prototype(Child, Parent); 引用《JavaScript高级程序设计》中对寄生组合式继承的夸赞就是： 这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。 原文链接：JavaScript深入之继承的多种方式和优缺点","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/tags/JavaScript/"}]},{"title":"学习冴羽的 JS 深入系列·中篇","slug":"js-series-2","date":"2019-11-27T13:03:24.000Z","updated":"2019-12-02T14:11:48.889Z","comments":true,"path":"2019/11/27/js-series-2/","link":"","permalink":"https://www.yangtao.site/2019/11/27/js-series-2/","excerpt":"主要实现 call、apply、new、bind 等实现思路","text":"主要实现 call、apply、new、bind 等实现思路 call 和 apply 的模拟实现callcall()在使用一个指定的 this 值和若干个指定的参数值的前提下，调用某个函数或方法。该方法的语法和作用与 apply() 方法类似，只有一个区别，就是 call() 方法接受的是一个参数列表，而 apply() 方法接受的是一个包含多个参数的数组。 使用 call 方法调用函数并且指定上下文的 ‘this’ 123456789var value = 1;var obj = &#123; value: 2&#125;;function foo() &#123; console.log(this.value);&#125;foo(); // 1foo.call(obj); // 2 使用 call 方法调用父构造函数 123456789function Person(name, age) &#123; this.name = name; this.age = age;&#125;function Tao(name, age, job) &#123; Person.call(this, name, age); this.job = job;&#125;var tao = new Tao(\"yangtao\", 27, \"Teacher\"); 所以我们模拟的步骤可以分为： 将函数设为对象的属性 执行该函数 删除该函数 123456789101112131415// 类似于：var foo = &#123; value: 1, bar: function() &#123; return this.value; &#125;&#125;;foo.bar(); // 1// 第一步foo.fn = bar;// 第二步foo.fn();// 第三步delete foo.fn; 第一版：绑定 this 123456789101112131415161718192021222324Function.prototype.mycall = function(context) &#123; context.fn = this; context.fn(); delete context.fn;&#125;;// 测试一下var foo = &#123; value: 1&#125;;function bar() &#123; console.log(this.value);&#125;bar.mycall(foo); // 1// 如下所示var foo = &#123; value: 1, bar: function() &#123; console.log(this.value); &#125;&#125;;foo.bar(); 第二版：给定参数 12345678910Function.prototype.mycall = function(context, name, age) &#123; context.fn = this; context.fn(); var args = []; for (var i = 1, l = arguments.length; i &lt; l; i++) &#123; args.push(\"arguments[\" + i + \"]\"); &#125; eval(\"context.fn(\" + args + \")\"); delete context.fn;&#125;; 第三版：传参为 null 和返回结果 123456789101112131415Function.prototype.mycall = function(context) &#123; var context = context || window; //获取调用call的函数，用this可以获取 context.fn = this; var args = []; // [\"arguments[1]\", \"arguments[2]\"] for (var i = 1, l = arguments.length; i &lt; l; i++) &#123; args.push(\"arguments[\" + i + \"]\"); &#125; // 把传给call的参数传递给了context.fn函数 // context.fn(args.join(',')); // context.fn(...args) var result = eval(\"context.fn(\" + args + \")\"); delete context.fn; return result;&#125;; 第四版：考虑 context，以及 context.fn 的可能性 12345678910111213141516171819202122232425262728293031Function.prototype.mycall = function(context) &#123; // 这一步如果不强制是 object 类型，可以省略 if (typeof context != \"object\") &#123; throw new Error(\"Arguments error\"); &#125; var context = context || window; var args = [], reslut; if (\"fn\" in context &amp;&amp; context.hasOwnProperty(\"fn\")) &#123; var fn = context.fn; var fnFlag = true; &#125; context.fn = this; for (var i = 1, l = arguments.length; i &lt; l; i++) &#123; args.push(\"arguments[\" + i + \"]\"); &#125; result = eval(\"context.fn(\" + args + \")\"); if (fnFlag) &#123; context.fn = fn; &#125; else &#123; delete context.fn; &#125; return result;&#125;; applyapply()同call()，只不过将多个参数值，以数组的形式传入而已。 用 apply 将数组添加到另一个数组： 1234var arr = [\"a\", \"b\"];var arr2 = [1, 2];arr.push.apply(arr, arr2);console.log(arr); // [\"a\", \"b\", 1, 2] 使用 apply 和内置函数： 1234567var nums = [1, 10, 3, 6, 2];var max = Math.max.apply(null, nums); // 10var min = Math.min.apply(null, nums); // 1// ES6 写法：var max = Math.max(...nums); // 10var min = Math.min(...nums); // 1 12345678910111213141516171819Function.prototype.myapply = function(context, arr) &#123; var context = context || window; var reslut; context.fn = this; if (!arr) &#123; reslut = context.fn(); &#125; else &#123; var args = []; for (var i = 0, l = arr.length; i &lt; l; i++) &#123; args.push(\"arr[\" + i + \"]\"); &#125; eval(\"context.fn(\" + args + \")\"); &#125; delete context.fn; return reslut;&#125;; 原文链接：JavaScript 深入之 call 和 apply 的模拟实现 bind 的模拟实现 bind()方法会创建一个新函数。当这个新函数被调用，bind()第一个参数将作为它运行时的 this，之后的一系列参数将会在传递的实参前传入，作为它的参数。 — 来自于 MDN 创建绑定函数 1234567891011var value = 1;var obj = &#123; value: 2, getValue: function() &#123; return this.value; &#125;&#125;;var getV = obj.getValue;getV(); // 1var getV2 = obj.getValue.bind(obj);getV2(); // 2 配合 setTimeout 12345678910111213var value = 1;function Fn() &#123; this.value = 2;&#125;Fn.prototype.getValue = function() &#123; // setTimeout(this.msg, 1000); // 1 setTimeout(this.msg.bind(this), 1000); //2&#125;;Fn.prototype.msg = function() &#123; console.log(\"value: \", this.value);&#125;;var myFn = new Fn();myFn.getValue(); 由此我们可以首先得出 bind 函数的两个特点： 返回一个函数 可以传入参数 第一版：返回函数 1234567891011121314Function.prototype.mybind = function(context) &#123; var self = this; return function() &#123; return self.apply(context); &#125;;&#125;;var obj = &#123; value: 1&#125;;function foo() &#123; return this.value;&#125;var bindFoo = foo.mybind(obj);bindFoo(); //1 第二版：传参 1234567891011121314151617181920212223Function.prototype.mybind = function(context) &#123; var self = this; // 获取除了第一个参数的剩余参数 var args = Array.prototype.slice.call(arguments, 1); return function() &#123; // 这里获取的是返回函数调用时传入的参数 var bindArgs = Array.prototype.slice.call(arguments); return self.apply(context, args.concat(bindArgs)); &#125;;&#125;;var obj = &#123; value: 1&#125;;function foo(name, age) &#123; console.log(this.value); console.log(name); console.log(age);&#125;var bindFoo = foo.mybind(obj, \"yang\");bindFoo(27);// 1// yang// 27 第三版：构造函数效果 bind 还有一个特点，就是:一个绑定函数也能使用 new 操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。 也就是说，当 bind 返回的函数作为构造函数的时候，bind 时指定的 this 值会失效，但传入的参数依然生效。 所以我们可以通过修改返回的函数的原型来实现： 123456789101112131415161718Function.prototype.mybind = function(context) &#123; var self = this; var args = Array.prototype.slice.call(arguments, 1); var fBound = function() &#123; var bindArgs = Array.prototype.slice.call(arguments); // 当作为构造函数时，this 指向实例，此时结果为 true，将绑定函数的 this 指向该实例，可以让实例获得来自绑定函数的值 // 以上面的是 demo 为例，如果改成 `this instanceof fBound ? null : context`，实例只是一个空对象，将 null 改成 this ，实例会具有 habit 属性 // 当作为普通函数时，this 指向 window，此时结果为 false，将绑定函数的 this 指向 context return self.apply( this instanceof fBound ? this : context, args.concat(bindArgs) ); &#125;; // 修改返回函数的 prototype 为绑定函数的 prototype，实例就可以继承绑定函数的原型中的值 fBound.prototype = this.prototype; return fBound;&#125;; 优化： 1234567891011121314151617181920212223Function.prototype.mybind = function(context) &#123; if (typeof this !== \"function\") &#123; throw new Error( \"Function.prototype.bind - what is trying to be bound is not callable\" ); &#125; var self = this; var args = Array.prototype.slice.call(arguments, 1); var fNOP = function() &#123;&#125;; var fBound = function() &#123; var bindArgs = Array.prototype.slice.call(arguments); return self.apply( this instanceof fNOP ? this : context, args.concat(bindArgs) ); &#125;; fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound;&#125;; 那别忘了做个兼容： 123Function.prototype.bind = Function.prototype.bind || function () &#123; ……&#125;; 原文链接：JavaScript 深入之 bind 的模拟实现 new 的模拟实现new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一。 12345678910111213141516function Person(name, age) &#123; this.name = name; this.age = age; this.habit = \"Games\";&#125;Person.prototype.getName = function() &#123; console.log(\"I am \" + this.name);&#125;;var person1 = new Person(\"Yang\", \"27\");console.log(person1.name); // Yangconsole.log(person1.habit); // Gamesperson1.getName(); // I am Yang 由上可知，实例 person1 可以： 访问到 Person 构造函数里的属性 访问到 Person.prototype 中的属性 初步实现分析： 因为 new 的结果是一个新对象，所以在模拟实现的时候，我们也要建立一个新对象，这个新对象会具有构造函数里的属性。 实例的 __proto__ 属性会指向构造函数的 prototype，也正是因为建立起这样的关系，实例可以访问原型上的属性。 1234567891011121314151617function objectFactory() &#123; // 用new Object() 的方式新建了一个对象 obj var obj = new Object(); // 取出第一个参数，就是我们要传入的构造函数 // 此外因为 shift 会修改原数组，所以 arguments 会被去除第一个参数 var Constructor = [].shift.call(arguments); // 将 obj 的原型指向构造函数，这样 obj 就可以访问到构造函数原型中的属性 obj.__proto__ = Constructor.prototype; // 使用 apply，改变构造函数 this 的指向到新建的对象，这样 obj 就可以访问到构造函数中的属性 Constructor.apply(obj, arguments); // 返回 obj return obj;&#125; 返回值效果实现需要判断返回的值是不是一个对象，如果是一个对象，我们就返回这个对象，如果没有，我们该返回什么就返回什么 12345678910function objectFactory() &#123; var obj = new Object(); var Constructor = [].shift.call(arguments); obj.__proto__ = Constructor.prototype; var ret = Constructor.apply(obj, arguments); return typeof ret === \"object\" ? ret : obj;&#125; 原文链接：JavaScript 深入之 new 的模拟实现 类数组对象与 arguments类数组对象从读写、获取长度、遍历三个方面看，和数组貌似是一样的，但是无法直接使用数组的方法，需要借助 call 或 apply： 12345678910var likeArr = &#123; 0: \"a\", 1: \"b\", 2: \"c\", length: 3&#125;;Array.prototype.slice.call(likeArr, 0); // [\"a\", \"b\", \"c\"]Array.prototype.join.call(likeArr, \"&amp;\"); // \"a&amp;b&amp;c\"Array.prototype.map.call(likeArr, item =&gt; item.toUpperCase()); // [\"A\", \"B\", \"C\"] 类数组转数组12345678// sliceArray.prototype.slice.call(likeArr);// ES6Array.from(likeArr);// applyArray.prototype.concat.apply([], likeArr);// splice，会改变 linkeArrArray.prototype.splice.call(likeArr, 0); ArgumentsArguments 对象只定义在函数体中，包括了函数的参数和其他属性。在函数体中，arguments 指代该函数的 Arguments 对象。 Arguments 对象的 length 属性，表示实参的长度。 Arguments 对象的 callee 属性，通过它可以调用函数自身。 将参数从一个函数传递到另一个函数： 123456789// 使用 apply 将 foo 的参数传递给 barfunction foo() &#123; bar.apply(this, arguments);&#125;function bar(a, b, c) &#123; console.log(a, b, c);&#125;foo(1, 2, 3); 使用 ES6 的...运算符，我们可以轻松转成数组。 12345function func(...arguments) &#123; console.log(arguments); // [1, 2, 3]&#125;func(1, 2, 3); arguments 的应用其实很多，如果要总结这些场景的话，暂时能想到的包括： 参数不定长 函数柯里化 递归调用 函数重载 原文链接：JavaScript 深入之类数组对象与 arguments","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/tags/JavaScript/"}]},{"title":"学习冴羽的 JS 深入系列·上篇","slug":"js-series-1","date":"2019-11-27T12:59:31.000Z","updated":"2020-04-01T05:39:11.433Z","comments":true,"path":"2019/11/27/js-series-1/","link":"","permalink":"https://www.yangtao.site/2019/11/27/js-series-1/","excerpt":"主要讲述什么是原型，什么是原型链，以及分别总结执行上下文的三个重要属性：变量对象、作用域链、this，还有闭包等难以理解的知识点。","text":"主要讲述什么是原型，什么是原型链，以及分别总结执行上下文的三个重要属性：变量对象、作用域链、this，还有闭包等难以理解的知识点。 从原型到原型链图示总结prototype：每一个函数都有一个prototype属性，该属性指向了一个对象，此对象为调用该函数而创建的实例的原型 __proto__：每一个对象（除 null）都具有一个属性：__proto__，这个属性指向该对象的原型 constructor：每个原型都有一个constructor属性指向关联的构造函数 Object：原型对象是通过 Object 构造函数生成的，最后Object.prototype.__proto__ = null 原型链：由相互关联的原型(proto)组成的链状结构就是原型链，即图中蓝色的这条线 代码总结每个函数都有一个 prototype 属性 1234567function Person() &#123;&#125;Person.prototype.name = \"Jake\";var person1 = new Person();var person2 = new Person();person1.name; // 'Jake'person2.name; // 'Jake' 每一个 JavaScript 对象(除了 null )都具有的一个属性，叫proto，这个属性会指向该对象的原型。 构造函数的 prototype 属性，指向了调用该构造函数而创建的实例的原型 person.proto 1person.__proto__ === Person.prototype; // true 每个原型都有一个 constructor 属性指向关联的构造函数 1Person.prototype.constructor === Person; // true 原型对象就是通过 Object 构造函数生成的 1Person.prototype.__proto__ === Object.prototype; // true Object.prototype.proto 的值为 null，即 Object.prototype 没有原型，终止查找 1Object.prototype.__proto__; // null 原文地址：JavaScript 深入之从原型到原型链 词法作用域和动态作用域javascript 采用的是词法作用域(lexical scoping)，函数的作用域是在函数定义的时候就决定了，而不是调用的时候才决定 词法作用域，即静态作用域，函数的作用域在函数定义的时候就决定了 动态作用域，函数的作用域是在函数调用的时候才决定 123456789var scope = \"global scope\";function checkscope() &#123; var scope = \"local scope\"; function f() &#123; return scope; &#125; return f();&#125;checkscope(); // \"local scope\" 123456789var scope = \"global scope\";function checkscope() &#123; var scope = \"local scope\"; function f() &#123; return scope; &#125; return f;&#125;checkscope()(); // \"local scope\" 因为 JavaScript 采用的是词法作用域，函数的作用域基于函数创建的位置。 而引用《JavaScript 权威指南》的回答就是： JavaScript 函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的。嵌套的函数 f() 定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管何时何地执行函数 f()，这种绑定在执行 f() 时依然有效。 原文链接：JavaScript 深入之词法作用域和动态作用域 执行上下文栈JavaScript 的可执行代码(executable code)的类型有哪些： 全局代码 函数代码 eval 代码 函数那么多，如何管理创建的那么多执行上下文呢？ 所以 JavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文。 当执行一个函数的时候，就会创建一个执行上下文(execution context)，并且压入执行上下文栈(Execution context stack, ESC) 当函数执行完毕的时候，会将函数的执行上下文栈中弹出。 其实，这里就会联想到 push pop 栈堆(后进先出-LIFO)。 模拟执行上下文栈： 12345// 执行上下文栈是一个数组 ECStack，整个应用程序结束的时候，才会被清空ECStack = [ // 程序结束之前， ECStack 最底部永远有个 globalContext globalContext // 全局执行上下文]; 运行如下代码： 12345678910111213function fun3() &#123; console.log(\"fun3\");&#125;function fun2() &#123; fun3();&#125;function fun1() &#123; fun2();&#125;fun1(); 伪代码模拟执行：(根据 push pop 原理，后进先出) 1234567ECStack.push(&lt;fun1&gt; functionContext); // 压入fun1上下文，发现了 fun2 被调用ECStack.push(&lt;fun2&gt; functionContext); // 继续压入fun2上下文，发现了 fun3 被调用ECStack.push(&lt;fun3&gt; functionContext); // 继续压入fun3上下文，并执行 fun3ECStack.pop(); // fun3 执行结束，并弹出ECStack.pop(); // fun2 执行结束，并弹出ECStack.pop(); // fun1 执行结束，并弹出// javascript接着执行下面的代码，但是ECStack底层永远有个globalContext 原文链接：JavaScript 深入之执行上下文栈 变量对象1、全局上下文的变量对象初始化：全局对象 2、函数上下文的变量对象初始化：只包括Arguments对象 3、进入执行上下文时：给变量对象添加形参、函数声明、变量声明等初始的属性值 4、代码执行阶段：再次修改变量对象的属性值 执行过程执行上下文过程可分为：进入执行上下文和代码执行（分析-执行） 123456789function foo(a) &#123; var b = 2; function c() &#123;&#125; var d = function() &#123;&#125;; b = 3;&#125;foo(1); 进入执行上下文过程： 12345678910AO = &#123; arguments: &#123; 0: 1, length: 1 &#125;, a: 1, b: undefined, c: reference function c() &#123;&#125;, d: undefined&#125; 代码执行阶段： 12345678910AO = &#123; arguments: &#123; 0: 1, length: 1 &#125;, a: 1, b: 3, c: reference function c() &#123;&#125;, d: reference to FunctionExpression \"d\"&#125; 总结：未进入执行阶段之前，变量对象(VO)中的属性都不能访问！但是进入执行阶段之后，变量对象(VO)转变为了活动对象(AO)，里面的属性都能被访问了，然后开始进行执行阶段的操作。它们其实都是同一个对象，只是处于执行上下文的不同生命周期。 最后，函数是“第一等公民”，记住这个，变量名称和函数名称相同的声明，优先执行函数声明。 原文链接：JavaScript 深入之变量对象 作用域对于每个执行上下文，都有三个重要属性： 变量对象(Variable object，VO) 作用域链(Scope chain) this 下面让我们以一个函数的创建和激活两个时期来讲解作用域链是如何创建和变化的。 函数创建由上节内容可知：函数的作用域在函数定义的时候就决定了。 这是因为函数有一个内部属性 [[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解 [[scope]] 就是所有父变量对象的层级链，但是注意：[[scope]] 并不代表完整的作用域链！ 如： 123456789101112function foo() &#123; function bar() &#123;&#125;&#125;// 各自的 [[scope]]:foo.[[scope]] = [ globalContext.VO];bar.[[scope]] = [ fooContext.AO // 保存父变量 globalContext.VO] 函数激活当函数激活时，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用链的前端。 这时候执行上下文的作用域链，我们命名为 Scope： 1Scope = [AO].concat([[Scope]]); 至此，作用域链创建完毕。 综合分析以下面的例子为例，结合着之前讲的变量对象和执行上下文栈，我们来总结一下函数执行上下文中作用域链和变量对象的创建过程： 123456var scope = \"global scope\";function checkscope() &#123; var scope2 = \"local scope\"; return scope2;&#125;checkscope(); 执行过程如下： 1.checkscope 函数被创建，保存作用域链到 内部属性[[scope]] 123checkscope.[[scope]] = [ globalContext.VO]; 2.执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈 1ECStack = [checkscopeContext, globalContext]; 3.checkscope 函数并不立刻执行，开始做准备工作，第一步：复制函数[[scope]]属性创建作用域链 123checkscopeContext = &#123; Scope: checkscope.[[scope]],&#125; 4.第二步：用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明 123456789checkscopeContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125;, scope2: undefined &#125;， Scope: checkscope.[[scope]],&#125; 5.第三步：将活动对象压入 checkscope 作用域链顶端 123456789checkscopeContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125;, scope2: undefined &#125;, Scope: [AO, [[Scope]]]&#125;; 6.准备工作做完，开始执行函数，随着函数的执行，修改 AO 的属性值 123456789checkscopeContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125;, scope2: \"local scope\" &#125;, Scope: [AO, [[Scope]]]&#125;; 7.查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出 1ECStack = [globalContext]; 原文链接：JavaScript 深入之作用域链 从 ECMAScript 规范解读 this 作者曰：在写文章之初，我就面临着这些问题，最后还是放弃从多个情形下给大家讲解 this 指向的思路，而是追根溯源的从 ECMASciript 规范讲解 this 的指向，尽管从这个角度写起来和读起来都比较吃力，但是一旦多读几遍，明白原理，绝对会给你一个全新的视角看待 this 。 12345678910111213141516171819var value = 1;var foo = &#123; value: 2, bar: function() &#123; return this.value; &#125;&#125;;//示例1console.log(foo.bar());//示例2console.log(foo.bar());//示例3console.log((foo.bar = foo.bar)());//示例4console.log((false || foo.bar)());//示例5console.log((foo.bar, foo.bar)()); 作者主要从 ECMASciript 规范讲解 this 的指向，讲解了示例 3 中是如何获取 this 指向的，每次阅读都会有不同的收获，也正如作者所说，希望能打开 this 新世界的大门。 原文链接：JavaScript 深入之从 ECMAScript 规范解读 this 补充下我们使用场景下的 this 指向，如： 1234567var object = &#123;&#125;;var obj = &#123; a: 1, b: function() &#123; console.log(this); &#125;&#125;; 作为对象调用时，指向该对象 obj.b(); ，this 指向 obj 作为函数调用，var b = obj.b; b(); ，this 指向全局 window 作为构造函数调用， var b = new Fun(); ，this 指向当前实例对象 作为 call、apply 调用， obj.b.apply(object, []); ，this 指向当前的 object 作为 bind 调用，var foo = obj.b.bind(object);foo()，this 永久被绑定到了 object 作为箭头函数使用，this 与封闭词法环境的 this 保持一致 作为DOM 事件处理函数，this 指向触发事件的元素 在严格模式下，如果 this 没有被执行环境（execution context）定义，那它将保持为 undefined。 执行上下文对于每个执行上下文，都有三个重要属性： 变量对象(Variable object，VO) 作用域链(Scope chain) this 分析第一段代码123456789var scope = \"global scope\";function checkscope() &#123; var scope = \"local scope\"; function f() &#123; return scope; &#125; return f();&#125;checkscope(); 1.执行全局代码，创建全局执行上下文，全局上下文被压入执行上下文栈 1ECStack = [globalContext]; 2.全局上下文初始化 12345globalContext = &#123; VO: [global], Scope: [globalContext.VO], this: globalContext.VO&#125;; 初始化的同时，checkscope 函数被创建，保存作用域链到函数的内部属性[[scope]] 1checkscope.[[scope]] = [globalContext.VO] 3.执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈 1ECStack = [checkscope, globalContext]; 4.checkscope 函数执行上下文初始化： 复制函数 [[scope]] 属性创建作用域链， 用 arguments 创建活动对象， 初始化活动对象，即加入形参、函数声明、变量声明， 将活动对象压入 checkscope 作用域链顶端。 同时 f 函数被创建，保存作用域链到 f 函数的内部属性[[scope]]. 1234567891011checkscopeContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125;, scope: undefined, f: reference to function f()&#123;&#125; &#125;, Scope: [AO, globalContext.VO], this: undefined&#125; 5.执行 f 函数，创建 f 函数执行上下文，f 函数执行上下文被压入执行上下文栈 1ECStack = [fContext, checkscope, globalContext]; 6.f 函数执行上下文初始化 123456789fContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125; &#125;, Scope: [AO, checkscopeContext.AO, globalContext.VO], this: undefined&#125;; 7.f 函数执行，沿着作用域链查找 scope 值，返回 scope 值，这里之所以能够访问到scope 8.f 函数执行完毕，f 函数上下文从执行上下文栈中弹出 9.checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出 1ECStack = [globalContext]; 分析第二段代码123456789var scope = \"global scope\";function checkscope() &#123; var scope = \"local scope\"; function f() &#123; return scope; &#125; return f;&#125;checkscope()(); 1.执行全局代码，创建全局执行上下文，全局上下文被压入执行上下文栈，并初始化全局上下文 123456ECStack = [globalContext];globalContext = &#123; VO: [global], Scope: [globalContext.VO], this: globalContext.VO&#125;; 初始化的同时，checkscope 函数被创建，保存作用域链到函数的内部属性[[scope]]： 1checkscope.[[scope]] = [globalContext.VO]; 2.执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈，并初始化函数上下文 123456789101112ECStack = [checkscopeContext, globalContext];checkscopeContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125;, scope: undefined, f: reference to function f()&#123;&#125; &#125;, Scope: [AO, globalContext.VO], this: undefined&#125; 同时 f 函数被创建，保存作用域链到 f 函数的内部属性[[scope]]： 1f.[[scope]] = [AO, checkscopeContext.AO, globalContext.VO]; 3.checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出 1ECStack = [globalContext]; 4.执行 f 函数，创建 f 函数执行上下文，并压入执行上下文栈，将其初始化 12345678910ECStack = [fContext;, globalContext];fContext = &#123; AO: &#123; arguments: &#123; length: 0 &#125; &#125;, Scope: [AO, checkscopeContext.AO, globalContext.VO], this: undefined&#125;; 5.f 函数执行，沿着作用域链查找 scope 值，返回 scope 值。正是因为 checkscope 函数执行上下文初始化时，f 函数同时被创建，保存作用域链到 f 函数的内部属性[[scope]]，所以即使checkscope函数执行完毕，被弹出执行上下文栈，但是checkscopeContext.AO 依然存在于 f 函数维护的[scope]]： 123fContext = &#123; Scope: [AO, checkscopeContext.AO, globalContext.VO],&#125; 所以，闭包的概念产生了，定义： 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回） 在代码中引用了自由变量 6.f 函数执行完毕，f 函数上下文从执行上下文栈中弹出 1ECStack = [globalContext]; 原文链接：JavaScript 深入之执行上下文 闭包MDN 对闭包的定义为： 闭包是指那些能够访问自由变量的函数。 那什么是自由变量呢？ 自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。 由此，我们可以看出闭包共有两部分组成： 闭包 = 函数 + 函数能够访问的自由变量 ECMAScript中，闭包指的是： 从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。 从实践角度：以下函数才算是闭包： 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回） 在代码中引用了自由变量 闭包是指那些能够访问自由变量的函数。 自由变量是指在函数中使用的，但既不是参数也不是函数的局部变量的变量。 那么，闭包 = 函数 + 函数能够访问的自由变量。 看这道刷题必刷，面试必考的闭包题： 1234567891011var data = [];for (var i = 0; i &lt; 3; i++) &#123; data[i] = function() &#123; console.log(i); &#125;;&#125;data[0]();data[1]();data[2](); 执行data[0]()，data[1]()，data[2]()时，i=3,所以都打印 3 让我们改成闭包看看： 123456789var data = [];for (var i = 0; i &lt; 3; i++) &#123; data[i] = (function(i) &#123; return function() &#123; console.log(i); &#125;; &#125;)(i);&#125; 原文链接：JavaScript 深入之闭包 参数按值传递ECMAScript 中所有函数的参数都是按值传递的。 — 《JavaScript 高级程序设计-第三版》 即，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制给另一个变量一样。 但是通俗地理解，参数如果是基本类型是按值传递，参数如果是引用类型就按共享传递。 共享传递是指，在传递对象的时候，传递对象的引用的副本。 例子一： 1234567var value = 1;function foo(v) &#123; v = 2; console.log(v); //2&#125;foo(value);console.log(value); // 1 内存分布如下： 改变前： \b 栈内存 栈内存 堆内存 value 1 v 1 改变后： \b 栈内存 栈内存 堆内存 value 1 v 2 例子二： 123456789var obj = &#123; value: 1&#125;;function foo(o) &#123; o.value = 2; console.log(o.value); //2&#125;foo(obj);console.log(obj.value); // 2 内存分布如下： 改变前： \b 栈内存 栈内存 堆内存 obj，o 指针地址 {value: 1} 改变后： \b 栈内存 栈内存 堆内存 obj，o 指针地址 {value: 2} 例子三： 123456789var obj = &#123; value: 1&#125;;function foo(o) &#123; o = 2; console.log(o); //2&#125;foo(obj);console.log(obj.value); // 1 内存分布如下： 改变前： \b 栈内存 栈内存 堆内存 obj，o 指针地址 {value: 1} 改变后： \b 栈内存 栈内存 堆内存 obj 指针地址 {value: 1} o 2 以上解释来自：sunsl516 commented on 2 Jun 2017. 原文链接：JavaScript 深入之参数按值传递","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/tags/JavaScript/"}]},{"title":"常见的 web 攻击方式","slug":"web-safety","date":"2019-11-12T14:57:11.000Z","updated":"2019-12-03T10:22:15.596Z","comments":true,"path":"2019/11/12/web-safety/","link":"","permalink":"https://www.yangtao.site/2019/11/12/web-safety/","excerpt":"SQL 注入 SQL 注入（SQLi）是一种注入攻击，，可以执行恶意 SQL 语句。它通过将任意 SQL 代码插入数据库查询，使攻击者能够完全控制 Web 应用程序后面的数据库服务器。","text":"SQL 注入 SQL 注入（SQLi）是一种注入攻击，，可以执行恶意 SQL 语句。它通过将任意 SQL 代码插入数据库查询，使攻击者能够完全控制 Web 应用程序后面的数据库服务器。 犯罪分子可能会利用它来未经授权访问用户的敏感数据：客户信息，个人数据，商业机密，知识产权等。SQL 注入攻击是最古老，最流行，最危险的 Web 应用程序漏洞之一。 如何防止 SQL 注入攻击？ 不要使用动态 SQL避免将用户提供的输入直接放入 SQL 语句中；最好使用准备好的语句和参数化查询，这样更安全。 不要将敏感数据保留在纯文本中加密存储在数据库中的私有/机密数据；这样可以提供了另一级保护，以防攻击者成功地排出敏感数据。 限制数据库权限和特权将数据库用户的功能设置为最低要求；这将限制攻击者在设法获取访问权限时可以执行的操作。 避免直接向用户显示数据库错误攻击者可以使用这些错误消息来获取有关数据库的信息。 对访问数据库的 Web 应用程序使用 Web 应用程序防火墙（WAF）这为面向 Web 的应用程序提供了保护，它可以帮助识别 SQL 注入尝试；根据设置，它还可以帮助防止 SQL 注入尝试到达应用程序（以及数据库）。 定期测试与数据库交互的 Web 应用程序这样做可以帮助捕获可能允许 SQL 注入的新错误或回归。 将数据库更新为最新的可用修补程序 原文：什么是 SQL 注入？如何防止 SQL 注入攻击？ 比如 node 博客里使用 mysql.escape()来防止注入： 12345const sql = ` select username, realname from users where username=$&#123;mysql.escape( username )&#125; and password=$&#123;mysql.escape(password)&#125;;`; XSS XSS（Cross Site Script，跨站脚本攻击）是向网页中注入恶意脚本（CSS 代码、JavaScript 代码等），用户浏览网页时在用户浏览器中执行恶意脚本的一种攻击方式。如盗取用户 cookie，破坏页面结构、重定向到其他网站等。 防范 XSS（永远不要相信用户的输入，必须对输入的数据作过滤处理）主要有两方面： 消毒：对危险字符进行转义 HttpOnly：防范 XSS 攻击者窃取 Cookie 数据 比如 node 博客里：新建文章的时候，标题里输入&lt;script&gt;alert(&#39;我是一段js代码&#39;)&lt;/script&gt;，然后点击提交，就会直接弹出来。 node 使用 xss： 1234const title = xss(blogData.title);// title// &amp;lt;script&amp;gt;alert('我是一段js代码')&amp;lt;/script&amp;gt; CSRF 攻击 CSRF 攻击（Cross Site Request Forgery，跨站请求伪造）是攻击者通过跨站请求，以合法的用户身份进行非法操作（如转账或发帖等）。 这里先说一下，http 是无状态的。服务器端和浏览器端的身份判断一般是通过 cookie。 后端会根据请求者传递的 cookie 信息判断请求者的身份。 攻击者的请求只要是带上了目标用户的 cookie，就可以合法请求。 跨站：请求来源很可能来自其他网站，也有可能来自本站 伪造：请求并非用户的意愿 实现：利用跨域标签 img iframe 等在 b 网站发送往 a 网站 get 请求，会带上 a 网站的 cookie，由此可见对于数据修改的请求最好不要用 get。 如果你在 a 站登录了，又访问了恶意网站 b，而 b 上面有一个恶意 img 标签的 get 请求，那你的数据可能就被删除了。 而跨域的 ajax 请求因为同源策略，不会带上 cookie，但是也能请求到结果，后端会处理这个请求，不过因为没有携带 cookie 信息，后端拿 不到登录状态，很多操作不会成功。跨域请求的结果也会发到客户端，不过由于同源策略的限制，浏览器读取不到这个响应结果。 伪造 form 表单提交。那么，post 请求就安全了吗？form 表单是跨域的。并且可以提交 post 请求。我们在 b 网站伪造一个 form 表单自动提交到 a 网站。 预防：最好的办法是带 token，任何请求都带上 token，这样伪站可以发请求，但是无法拿到 token，后端收到的就不带 token 就可以判定非法了。 原文：常见的 web 攻击方式及预防 密码加密 文档：crypto（加密） crypto 模块提供了加密功能，包括对 OpenSSL 的哈希、HMAC、加密、解密、签名、以及验证功能的一整套封装。 12345678910const crypto = require(\"crypto\");const secret = \"abcdefg\";const hash = crypto .createHmac(\"sha256\", secret) .update(\"I love cupcakes\") .digest(\"hex\");console.log(hash);// 打印:// c0fa1bc00531bd78ef38c628449c5102aeabd49b5dc3a2a516ea6ea959d6658e MD5md5：不是一种加密算法，是用来做文件校验的 作用：让大容量信息在数字签名软件签署私人秘钥前被”压缩”成一种保密格式，也就是把一个任意长度的字节串变换成一定长度的十六进制数字串（32个字符） 123456789101112131415const crypto = require('crypto')const SECRET_KEY = 'WJiol_8776#'// md5 加密function md5(content) &#123; return crypto.createHash('md5').update(content).digest('hex')&#125;// 加密函数function genPassword(password) &#123; return md5(`password=$&#123;password&#125;&amp;key=$&#123;SECRET_KEY&#125;`)&#125;console.log(genPassword('123456'))// 4d4994bde299f6168c65f24c852897b7 HMAC进一步提升MD5加密安全性：是一个”秘钥”，对明文进行加密，并做”两次散列”，但使用它得到的还是32个字符 利用哈希算法，以一个秘钥和一个信息为输入，生成一个消息摘要作为输出 1234567891011const crypto = require('crypto')const SECRET_KEY = 'WJiol_8776#'// Hmac 加密function hmac(content) &#123; return crypto.createHmac('md5', SECRET_KEY).update(content).digest('hex')&#125;console.log('hamc: ', hmac('123456'))// 7d37b577bcd2a492820846e475b933f9 参考资料 sql 攻击 SQL 注入和 XSS 攻击 什么是 SQL 注入？如何防止 SQL 注入攻击？ 什么是 XSS 攻击？什么是 SQL 注入攻击？什么是 CSRF 攻击？ 如何预防 SQL 注入和 XSS 攻击 - 代码讲解更直观 前端加密 JS 库–CryptoJS 使用指南 nodeJS：MD5加密","categories":[{"name":"Web","slug":"Web","permalink":"https://www.yangtao.site/categories/Web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://www.yangtao.site/tags/web/"}]},{"title":"当复制一个对象的副本所导致的“Object大案”","slug":"js-object","date":"2019-10-05T01:30:42.000Z","updated":"2019-11-11T07:46:05.525Z","comments":true,"path":"2019/10/05/js-object/","link":"","permalink":"https://www.yangtao.site/2019/10/05/js-object/","excerpt":"用 forEach 来复制一个对象的副本","text":"用 forEach 来复制一个对象的副本 用 forEach 来复制一个对象的副本1234567891011121314151617181920// 对象复制函数function copy(obj) &#123; var copy = Object.create(Object.getPrototypeOf(obj)); var propNames = Object.getOwnPropertyNames(obj); propNames.forEach(function(name) &#123; var desc = Object.getOwnPropertyDescriptor(obj, name); Object.defineProperty(copy, name, desc); &#125;); return copy;&#125;var copyObj1 = &#123; a: 1, b: 2&#125;;var copyObj2 = copy(copyObj1);console.log(copyObj2); // &#123; a: 1, b: 2 &#125;console.log(copyObj2 === copyObj1); // false Object.create Object.create(proto[, propertiesObject])方法创建一个新对象，使用现有的对象来提供新创建的对象的proto Object.getPrototypeOfObject.getOwnPropertyNamesObject.getOwnPropertyDescriptorObject.defineProperty总结123456789101112131415161718function copy(obj) &#123; // Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__ // Object.getPrototypeOf(object)方法返回指定对象的原型（内部[[Prototype]]属性的值 var copy = Object.create(Object.getPrototypeOf(obj)); // Object.getOwnPropertyNames(obj)方法返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性但不包括Symbol值作为名称的属性）组成的数组 var propNames = Object.getOwnPropertyNames(obj); propNames.forEach(function(name) &#123; // Object.getOwnPropertyDescriptor(obj, prop)方法返回指定对象上一个自有属性对应的属性描述符。 // （自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性） var desc = Object.getOwnPropertyDescriptor(obj, name); // Object.defineProperty(obj, prop, descriptor)方法会直接在一个对象上定义一个新属性， // 或者修改一个对象的现有属性， 并返回这个对象 Object.defineProperty(copy, name, desc); &#125;); return copy;&#125; 资料 Array.prototype.forEach() 是如何使用 ECMAScript 5 Object.* 元属性（meta property ）函数工作 for…of Array.prototype.some() Array.prototype.every() Object.create() Object.keys() Object.defineProperty() Object.getOwnPropertyDescriptor() Object.getOwnPropertyNames() Object.getPrototypeOf()","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/tags/JavaScript/"}]},{"title":"Git 提交的正确姿势：Commit message 编写指南","slug":"git-commit","date":"2019-09-26T10:12:30.000Z","updated":"2019-11-13T03:57:43.331Z","comments":true,"path":"2019/09/26/git-commit/","link":"","permalink":"https://www.yangtao.site/2019/09/26/git-commit/","excerpt":"HeaderHeader 部分只有一行，包括三个字段：type（必需）、scope（可选）和 subject（必需） feat：新功能（feature） fix：修补 bug docs：文档（documentation） style： 格式（不影响代码运行的变动） refactor：重构（即不是新增功能，也不是修改 bug 的代码变动） test：增加测试 chore：构建过程或辅助工具的变动","text":"HeaderHeader 部分只有一行，包括三个字段：type（必需）、scope（可选）和 subject（必需） feat：新功能（feature） fix：修补 bug docs：文档（documentation） style： 格式（不影响代码运行的变动） refactor：重构（即不是新增功能，也不是修改 bug 的代码变动） test：增加测试 chore：构建过程或辅助工具的变动 提交信息规范我们对项目的 git 提交信息格式进行统一格式约定，每条提交信息由 type+subject 组成，这将提升项目日志的可读性。 type 用于表述此次提交信息的意义，首写字母大写，包括但不局限于如下类型： Build：基础构建系统或依赖库的变化 Ci：CI 构建系统及其脚本变化 Docs：文档内容变化 Feat：新功能 Fix：Bug 修复 Perf：性能优化 Refactor：重构（即不是新增功能，也不是修改 Bug 的代码变动） Style：格式（不影响代码运行的变动） Revert：代码回滚 Release：版本发布 subject 用于简要描述修改变更的内容，如 Update code highlighting in readme.md。 句尾不要使用符号。 使用现在时、祈使句语气。 标签规范为了方便维护人员和用户能够快速找到他们想要查看的问题，我们使用“标签”功能对 Pull requests 和 Issues 进行分类。 如果您不确定某个标签的含义，或者不知道将哪些标签应用于 PR 或 issue，千万别错过这个。 Issue 的标签： 类型 Bug: 检测到需要进行确认的 Bug Feature Request: 提出了新功能请求的 Issue Question: 提出疑问的 Issue Meta: 表明使用条款变更的 Issue Support: 被标记为支持请求的 Issue Polls: 发起投票的 Issue 结果 Duplicate: 重复提及的 Issue Irrelevant: 与 NexT 主题无关的 Issue Expected Behavior: 与预期行为相符的 Issue Need More Info: 需要更多信息的 Issue Need Verify: 需要开发人员或用户确认 Bug 或解决方法的 Issue Verified: 已经被确认的 Issue Can&#39;t Reproduce: 无法复现的 Issue Solved: 已经解决的 Issue Stale: 由于长期无人回应被封存的 Issue Pull Request 的标签： Breaking Change: 产生重大变动的 Pull Request Bug Fix: 修复相关 Bug 的 Pull Request New Feature: 添加了新功能的 Pull Request Feature: 为现有功能提供选项或加成的 Pull Request i18n: 更新了翻译的 Pull Request Work in Progress: 仍在进行改动和完善的 Pull Request Skip Release: 无需在 Release Note 中展现的 Pull Request 两者兼有： Roadmap: 与 NexT 主题发展相关的 Issue 或者 Pull Request Help Wanted: 需要帮助的 Issue 或者 Pull Request Discussion: 需要进行讨论的 Issue 或者 Pull Request Improvement: 需要改进的 Issue 或者改进了 NexT 主题的 Pull Request Performance: 提出性能问题的 Issue 或者提高了 NexT 主题性能的 Pull Request Hexo: 与 Hexo 和 Hexo 插件相关的 Issue 或者 Pull Request Template Engine: 与模版引擎相关的 Issue 或者 Pull Request CSS: 与 NexT 主题 CSS 文件相关的 Issue 或者 Pull Request Fonts: 与 NexT 主题字体相关的 Issue 或者 Pull Request PJAX: 与 PJAX 相关的 Issue 或者 Pull Request 3rd Party Plugin: 与第三方插件和服务相关的 Issue 或者 Pull Request Docs: 与文档说明相关的 Issue 或者 Pull Request Configurations: 与 NexT 主题设置相关的 Issue 或者 Pull Request 资料 Git 提交的正确姿势：Commit message 编写指南 Next 主题贡献规范","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://www.yangtao.site/categories/开发工具/"}],"tags":[{"name":"git","slug":"git","permalink":"https://www.yangtao.site/tags/git/"}]},{"title":"前端性能优化","slug":"web-speed","date":"2019-09-06T11:21:19.000Z","updated":"2019-12-03T10:21:19.040Z","comments":true,"path":"2019/09/06/web-speed/","link":"","permalink":"https://www.yangtao.site/2019/09/06/web-speed/","excerpt":"重定向 → 拉取缓存 →DNS 查询 → 建立 TCP 链接 → 发起请求 → 接收响应 → 处理 HTML 元素 → 元素加载完成","text":"重定向 → 拉取缓存 →DNS 查询 → 建立 TCP 链接 → 发起请求 → 接收响应 → 处理 HTML 元素 → 元素加载完成 网络传输性能优化浏览器缓存 缓存一般分为强缓存和协商缓存，主要区别是：使用本地缓存的时候，是否需要向服务器验证本地缓存是否依旧有效。 强缓存主要通过 http 请求头中的 Cache-Control 和 Expire 两个字段控制 一般，我们会设置 Cache-Control 的值为“public, max-age=xxx”，表示在 xxx 秒内再次访问该资源，均使用本地的缓存，不再向服务器发起请求。 协商缓存每次都向服务器验证一下缓存的有效性 前端缓存方案 HTML：使用协商缓存 CSS JS Image：使用强缓存，文件名带上 hash 值 浏览器默认的缓存是放在内存内的，但我们知道，内存里的缓存会因为进程的结束或者说浏览器的关闭而被清除，而存在硬盘里的缓存才能够被长期保留下去。很多时候，我们在 network 面板中各请求的 size 项里，会看到两种不同的状态：from memory cache 和 from disk cache，前者指缓存来自内存，后者指缓存来自硬盘。而控制缓存存放位置的，不是别人，就是我们在服务器上设置的 Etag 字段。在浏览器接收到服务器响应后，会检测响应头部（Header），如果有 Etag 字段，那么浏览器就会将本次缓存写入硬盘中。 资源打包压缩 网络性能优化措施归结为三大方面：减少请求数、减小请求资源体积、提升网络传输速率 1gulp grunt webpack parcel 图片资源优化 不要在 HTML 里缩放图像 使用雪碧图（CSS Sprite）- webpack-spritesmith 使用字体图标（iconfont）- icomoon 使用 WebP - 图片压缩体积大约只有 JPEG 的 2/3，并能节省大量的服务器带宽资源和数据空间 网络传输性能检测工具 Page Speed | PageSpeed Insights 使用 CDN页面渲染性能优化浏览器渲染过程（webkit） 《Webkit 技术内幕》 浏览器的解释器，是包括在渲染引擎内的，我们常说的 Chrome（现在使用的是 Blink 引擎）和 Safari 使用的 Webkit 引擎，Firefox 使用的 Gecko 引擎，指的就是渲染引擎。而在渲染引擎内，还包括着我们的 HTML 解释器（渲染时用于构造 DOM 树）、CSS 解释器（渲染时用于合成 CSS 规则）还有我们的 JS 解释器。不过后来，由于 JS 的使用越来越重要，工作越来越繁杂，所以 JS 解释器也渐渐独立出来，成为了单独的 JS 引擎，就像众所周知的 V8 引擎，我们经常接触的 Node.js 也是用的它。 DOM 渲染层与 GPU 硬件加速 ① 浏览器会先获取 DOM 树并依据样式将其分割成多个独立的渲染层 ②CPU 将每个层绘制进绘图中 ③ 将位图作为纹理上传至 GPU（显卡）绘制 ④GPU 将所有的渲染层缓存（如果下次上传的渲染层没有发生变化，GPU 就不需要对其进行重绘）并复合多个渲染层最终形成我们的图像 重排和重绘不论是重排还是重绘，都会阻塞浏览器。要提高网页性能，就要降低重排和重绘的频率和成本，近可能少地触发重新渲染。 重排是由 CPU 处理的，而重绘是由 GPU 处理的，CPU 的处理效率远不及 GPU，并且重排一定会引发重绘，而重绘不一定会引发重排。所以在性能优化工作中，我们更应当着重减少重排的发生。 重排 reflow渲染层内的元素布局发生修改，都会导致页面重写排列。 比如：窗口的尺寸发生变化、删除或添加 DOM 元素；修改了影响元素盒子大小的 css 属性（width height padding…） 重绘 repaint绘制，所有对元素的视觉表现属性的修改，都会引起重绘。 优化策略 CSS 属性读写分离 通过切换 class 或者 style.csstext 属性去批量操作元素样式 DOM 元素离线更新 将没用的元素设为不可见：visibility: hidden，减少重绘的压力 压缩 DOM 的深度：少用 DOM 完成页面样式，多使用伪元素或者 box-shadow 取代。 图片在渲染前指定大小：因为 img 元素是内联元素，所以在加载图片后会改变宽高，严重的情况会导致整个页面重排，所以最好在渲染前就指定其大小，或者让其脱离文档流。 对页面中可能发生大量重排重绘的元素单独触发渲染层，使用 GPU 分担 CPU 压力。（慎重） JS 阻塞性能负载均衡Node.js 处理 IO 密集型请求 Node.js : 我只需要一个店小二 node 的核心是事件驱动，通过 loop 去异步处理用户请求，相对于传统的后端服务，他们都是将用户的每个请求分配到异步队列中进行处理。 事件驱动的优势：在高并发 IO 时，不会造成堵塞。 Frond-End(Browser) Back-End(Java Server) pm2 实现 Node.js“多线程” 使用 Node.js 的优势和劣势都有哪些？ pm2。这是它的官网：pm2.keymetrics.io/ 它是一款 node.js 进程管理器，具体的功能，就是能在你的计算机里的每一个内核都启动一个 node.js 服务。 也就是说如果你的电脑或者服务器是多核处理器（现在也少见单核了吧），它就能启动多个 node.js 服务，并且它能够自动控制负载均衡，会自动将用户的请求分发至压力小的服务进程上处理。 nginx 搭建反向代理资料 前端缓存最佳实践 网站性能优化实战——从 12.67s 到 1.06s 的故事 你应该知道的前端——缓存 《大型网站性能监测、分析与优化》 【原】雅虎前端优化的 35 条军规","categories":[{"name":"Web","slug":"Web","permalink":"https://www.yangtao.site/categories/Web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://www.yangtao.site/tags/web/"}]},{"title":"MacOS如何使用 tree 生成目录结构","slug":"tool-tree","date":"2019-09-02T07:01:37.000Z","updated":"2019-11-11T07:09:18.291Z","comments":true,"path":"2019/09/02/tool-tree/","link":"","permalink":"https://www.yangtao.site/2019/09/02/tool-tree/","excerpt":"Homebrew安装homebrew官网 Homebrew介绍和使用","text":"Homebrew安装homebrew官网 Homebrew介绍和使用 根据官网的方法安装1/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\" 比如我的：123456789==&gt; This script will install:/usr/local/bin/brew/usr/local/share/doc/homebrew/usr/local/share/man/man1/brew.1/usr/local/share/zsh/site-functions/_brew/usr/local/etc/bash_completion.d/brew/usr/local/HomebrewPress RETURN to continue or any other key to abort 一路按照提示操作即可，不出意外的话，就安装成功了:1234➜ ~ brew -vHomebrew 2.1.9Homebrew/homebrew-core (git revision c8ff; last commit 2019-08-01)Homebrew/homebrew-cask (git revision 04bff; last commit 2019-08-02) Tree 安装1brew install tree 常用命令：1234567891011121314151617181920# 下载brew install tree# 显示某个文件夹下的所有文件tree -a# 只显示文件夹tree -d# 显示项目的层级，如三级tree -L 3 # 过滤，如除node_modules文件tree -I \"node_modules\"# 输出tree &gt; tree.md# Helptree --help 最后，我的输出：tree -I &quot;node_modules&quot; &gt; tree.md查看 tree.md 的内容如下：123456789101112131415161718192021222324252627282930313233343536373839.├── README.md├── dist├── package.json├── src│ ├── app.scss│ ├── font-awesome│ │ ├── fonts│ │ │ ├── FontAwesome.otf│ │ │ ├── fontawesome-webfont.eot│ │ │ ├── fontawesome-webfont.svg│ │ │ ├── fontawesome-webfont.ttf│ │ │ ├── fontawesome-webfont.woff│ │ │ └── fontawesome-webfont.woff2│ │ └── scss│ │ ├── _animated.scss│ │ ├── _bordered-pulled.scss│ │ ├── _core.scss│ │ ├── _fixed-width.scss│ │ ├── _icons.scss│ │ ├── _larger.scss│ │ ├── _list.scss│ │ ├── _mixins.scss│ │ ├── _path.scss│ │ ├── _rotated-flipped.scss│ │ ├── _screen-reader.scss│ │ ├── _stacked.scss│ │ ├── _variables.scss│ │ └── font-awesome.scss│ ├── index.html│ ├── index.js│ ├── index.jsx│ ├── react.png│ └── style.css├── tree.md├── webpack.config.js└── yarn.lock5 directories, 31 files tree命令行参数 命令行参数 含义 -a 显示所有文件和目录。 -A 使用ASNI绘图字符显示树状图而非以ASCII字符组合。 -C 在文件和目录清单加上色彩，便于区分各种类型。 -d 显示目录名称而非内容。 -D 列出文件或目录的更改时间。 -f 在每个文件或目录之前，显示完整的相对路径名称。 -F 在末尾追加描述性字符，如 ls -F -g 列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码。 -i 不以阶梯状列出文件或目录名称。 -I 不显示符合范本样式的文件或目录名称。 -l 如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录。 -n 不在文件和目录清单加上色彩。 -N 直接列出文件和目录名称，包括控制字符。 -p 列出权限标示。 -P 只显示符合范本样式的文件或目录名称。 -q 用”?”号取代控制字符，列出文件和目录名称。 -s 列出文件或目录大小。 -t 用文件和目录的更改时间排序。 -u 列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码。 -x 将范围局限在现行的文件系统中，若指定目录下的某些子目录，其存放于另一个文件系统上，则将该子目录予以排除在寻找范围外。 参考资料 mac tree命令 Mac使用tree生成目录结构","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://www.yangtao.site/categories/开发工具/"}],"tags":[{"name":"MacOS","slug":"MacOS","permalink":"https://www.yangtao.site/tags/MacOS/"},{"name":"终端","slug":"终端","permalink":"https://www.yangtao.site/tags/终端/"}]},{"title":"学习 React 的一些记录日志","slug":"react-doc","date":"2019-08-24T10:15:52.000Z","updated":"2019-11-11T07:34:04.745Z","comments":true,"path":"2019/08/24/react-doc/","link":"","permalink":"https://www.yangtao.site/2019/08/24/react-doc/","excerpt":"学习 React 的一些记录日志","text":"学习 React 的一些记录日志 Video Course初级 基于实例的 react16 傻瓜课程 — 用一系列有趣的、简洁明快的实例由浅入深的阐述了 React 的特色，概念和基本使用 react16.4 快速上手 — 通过 Todolist 功能的实现，给大家讲解了 React 组件间的通信方式 中级 react 16 实现订单列表及评价功能 — 介绍了从项目创建、到组件划分、再到组件及页面逻辑实现的开发流程 react 组件 — 比较详细地讲解组件和生命周期 高级 react响应用户输入 — 学习如何让数据逻辑与 UI 的结合使用、react 的事件处理机制以及 react 对 DOM 模型的操作 react知识点综合运用实例 — 综合实例操作 react高级教程之高阶组件 — 高阶组件的应用：代理和继承 Document React 官方文档 Ant Design of React — antd 是基于 Ant Design 设计体系的 React UI 组件库，主要用于研发企业级中后台产品。 Ant Design Pro — 是一个企业级中后台前端/设计解决方案 Ant Design Mobile of React — 是 Ant Design 的移动规范的 React 实现，服务于蚂蚁及口碑无线业务 webpack 官方文档 React 与 webpack Learning Materials 《react 入门教程》 《react 入门实例教程》 — 阮一峰 《typescript 热门教程》 《6 周学习计划，攻克 javascript 难关(react/redux/es6 etc.)》 My Learning入门学习 React 的几个例子 Demo 地址，戳我 ReactDOM.render() Use Array in JSX 组件 this.props.children PropTypes 获取真实的 DOM 节点 this.state 表单 组件的生命周期 使用 Promise 获取 Github 的数据 Todo List 井字棋（Tic Tac Toe） Nextjs — 配合 React 打造静态化和服务端渲染应用Nextjs Demo1: 学习官方文档 123cd nextjs/01-hello-nextnpm installnpm run dev My Project 学习「井字游戏」 学习体验 Ant Design of React","categories":[{"name":"前端框架","slug":"前端框架","permalink":"https://www.yangtao.site/categories/前端框架/"}],"tags":[{"name":"react","slug":"react","permalink":"https://www.yangtao.site/tags/react/"}]},{"title":"入门 Webpack@3 的配置过程","slug":"webpack-v3","date":"2019-08-05T12:13:10.000Z","updated":"2019-11-11T07:33:17.062Z","comments":true,"path":"2019/08/05/webpack-v3/","link":"","permalink":"https://www.yangtao.site/2019/08/05/webpack-v3/","excerpt":"入门 Webpack@3 的配置过程","text":"入门 Webpack@3 的配置过程 Webpack webpack 指南 React 的 Webpack 配置 PS： 文章结尾有完整实例启动方法：Github地址 本次配置练习主要是针对 webpack-v3，切换分支至 webpack@3-react ，每一次 Commits，基本上对应着相应的文件配置，可以对照着瞅瞅。 开始安装配置 Webpack准备环境： 12345678➜ happymmall git:(webpack@3-react) ✗ node -vv11.13.0➜ happymmall git:(webpack@3-react) ✗ npm -v6.10.1➜ happymmall git:(webpack@3-react) ✗ git --versiongit version 2.17.2 (Apple Git-113)➜ happymmall git:(webpack@3-react) ✗ yarn -v1.17.3 安装 yarn12345678910# homebrew 安装brew install yarn# npm/cnpm 安装npm install cnpm -gcnpm install yarn -g# 测试是否安装成功➜ ~ yarn --version1.17.3 常用命令： 12345yarn init # 初始化yarn add [package] # 添加依赖包yarn add [package] --dev # 添加到 devDependenciesyarn remove [package] # 删除依赖包yarn install # 安装所有依赖包 安装 webpack@312yarn inityarn add webpack@3.10.0 --dev 根目录新建 webpack.config.js,并新建 src/index.js 12345678910111213// webpack.config.jsconst path = require(\"path\");module.exports = &#123; entry: \"./src/index.js\", output: &#123; path: path.resolve(__dirname, \"dist\"), filename: \"app.js\" &#125;&#125;;// index.jsconsole.log(\"Hello, world\"); 运行：node_modules/.bin/webpack: 1234567➜ happymmall git:(webpack@3-react) ✗ node_modules/.bin/webpackHash: 62e68b9cc366c7b50ac6Version: webpack 3.10.0Time: 34ms Asset Size Chunks Chunk Namesapp.js 2.5 kB 0 [emitted] main [0] ./src/index.js 28 bytes &#123;0&#125; [built] 打开 dist/app.js，搜索 Hello: 123456/***/ (function(module, exports) &#123;console.log('Hello, world');/***/ &#125;)/******/ ]); 一个简单的文件就此打包成功，开心吧… 配置 HMTL 模板文档：HtmlWebpackPlugin 简化了 HTML 文件的创建，以便为你的 webpack 包提供服务。这对于在文件名中包含每次会随着编译而发生变化哈希的 webpack bundle 尤其有用。 安装 html-webpack-plugin 1yarn add html-webpack-plugin@2.30.1 --dev 新建：src/index.html, 并初始化一个 html 内容，然后配置： 123456789101112131415const path = require(\"path\");const HtmlWebpackPlugin = require(\"html-webpack-plugin\");module.exports = &#123; entry: \"./src/index.js\", output: &#123; path: path.resolve(__dirname, \"dist\"), filename: \"app.js\" &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: \"./src/index.html\" &#125;) ]&#125;; 接着跑一下：node_modules/.bin/webpack，不出意外的话，dist 下会出现一个 index.html，打开查看就会发现，不仅有我们自己指定的内容，还把app.js也自动引入了，这波操作够可以。 Babel 处理脚本文档：babel-loader 安装 babel 1yarn add babel-loader@7.1.2 babel-core@6.26.0 babel-preset-env@1.6.1 --dev 设置 config 文件： 1234567891011121314module: &#123; rules: [ &#123; test: /\\.js$/, exclude: /(node_modules)/, // 忽略此文件 use: &#123; loader: \"babel-loader\", options: &#123; presets: [\"env\"] &#125; &#125; &#125; ];&#125; 然后修改 src/index.js: 123456789101112class People &#123; constructor(name) &#123; this.name = \"people\"; &#125;&#125;class Man extends People &#123; constructor(name) &#123; super(name); this.age = 27; &#125;&#125; 运行：node_modules/.bin/webpack，然后再去dist/app.js，就会发现已经转译成功： 1234567891011121314151617181920var People = function People(name) &#123; _classCallCheck(this, People); this.name = \"people\";&#125;;var Man = (function(_People) &#123; _inherits(Man, _People); function Man(name) &#123; _classCallCheck(this, Man); var _this = _possibleConstructorReturn( this, (Man.__proto__ || Object.getPrototypeOf(Man)).call(this, name) ); _this.age = 27; return _this; &#125; return Man;&#125;)(People); 配置 React安装： 12yarn add babel-preset-react@6.24.1 --devyarn add react@16.2.0 react-dom@16.2.0 设置： 1234567891011121314151617module: &#123; rules: [ &#123; test: /\\.jsx$/, exclude: /(node_modules)/, use: &#123; loader: \"babel-loader\", options: &#123; presets: [\"env\", \"react\"] &#125; &#125; &#125; ];&#125;// 这时候的入口文件也需要更改下测试entry: './src/index.jsx', 然后修改 src/index.js 为 src/index.jsx: 1234import React from \"react\";import ReactDOM from \"react-dom\";ReactDOM.render(&lt;h1&gt;Hello, React.&lt;/h1&gt;, document.getElementById(\"root\")); 运行：node_modules/.bin/webpack，然后再去dist/app.js，查找如下： 1234567// ..._reactDom2.default.render( _react2.default.createElement(\"h1\", null, \"Hello, React.\"), document.getElementById(\"root\"));// ... 那么，表示解析 .jsx 成功。 解析 CSS安装： 1yarn add style-loader@0.19.1 css-loader@0.28.8 --dev 设置： 1234&#123; test: /\\.css$/, use: ['style-loader', 'css-loader']&#125; 在 index.jsx 里添加：import &#39;./style.css&#39;;，在style.css添加一些： 1234body &#123; color: red; font-size: 16px;&#125; 接着跑一下：node_modules/.bin/webpack，再接着去 dist 下的 app.js 找找： 12// moduleexports.push([module.i, \"body &#123;\\n color: red;\\n font-size: 16px;\\n&#125;\", \"\"]); 嗯，已经被解析并添加到 app.js 文件中。但是，我们有时候需要大量的 css 文件，并需要 js 解析，那就需要个插件单独处理：ExtractTextWebpackPlugin: 1yarn add extract-text-webpack-plugin@3.0.2 --dev 设置： 12345678910111213141516171819plugins: [ new HtmlWebpackPlugin(&#123; template: \"./src/index.html\" &#125;), // Add new ExtractTextWebpackPlugin(\"styles.css\"),],module: &#123; rules: [ // Add &#123; test: /\\.css$/, use: ExtractTextWebpackPlugin.extract(&#123; fallback: \"style-loader\", use: \"css-loader\" &#125;) &#125; ]&#125; 然后跑一下，dist 下就会出现我们设置的 styles.css 文件，并且会自动添加至 index.html: 1&lt;link href=\"style.css\" rel=\"stylesheet\" /&gt; 解析 scss安装: sass-loader node-sass 1yarn add sass-loader@6.0.6 node-sass@4.7.2 --dev 设置： 1234567&#123; test: /\\.scss$/, use: ExtractTextWebpackPlugin.extract(&#123; fallback: \"style-loader\", use: [\"css-loader\", \"sass-loader\"] &#125;)&#125; 这时候，我们去 src 下新建一个 app.scss: 12345body &#123; h1 &#123; color: blue; &#125;&#125; 并且在 index.jsx 中引入： 12import \"./style.css\";import \"./app.scss\"; 接着，跑一下看看，刷~的一声，打开 dist 下的 styles.css，看看是不是我们引入的内容： 1234567body &#123; color: red; font-size: 16px;&#125;body h1 &#123; color: blue;&#125; 测试通过，完美！ 处理图片资源安装：url-loader 1yarn add file-loader@1.1.6 url-loader@0.6.2 --dev 设置： 1234567891011&#123; test: /\\.(png|jpg|gif)$/, use: [ &#123; loader: 'url-loader', options: &#123; limit: 8192 &#125; &#125; ]&#125; 同样的 src 下找张图片，测试下是否通过，在 index.jsx 里添加： 123456789import ImgSrc from \"./react.png\";ReactDOM.render( &lt;div&gt; &lt;h1&gt;Hello, React.&lt;/h1&gt; &lt;img src=&#123;ImgSrc&#125; alt=\"react\" /&gt; &lt;/div&gt;, document.getElementById(\"root\")); 然后跑一下，发现：如果图片大于 limit 的设置（8kb=8192/1024kb）就会出现在 dist 目录下，否则会以 base64 格式直接引入使用。 处理 fonts 字体先下载个Font Awesome试试水： 1yarn add font-awesome 设置： 1234567891011&#123; test: /\\.(woff|woff2|eot|ttf|otf|svg)$/, use: [ &#123; loader: 'url-loader', options: &#123; limit: 8192 &#125; &#125; ]&#125; 然后按照以下几个步骤来试水： 复制 font-awesome/ 目录到你的项目中 只保留 fonts 文件 和 scss 文件里的内容，其他可以删除 最后去你的主文件：app.scss 添加它： 12$fa-font-path: \"./font-awesome/fonts\";@import \"./font-awesome/scss/font-awesome.scss\"; 接着我们跑一下：node_modules/.bin/webpack，dist 下瞬间就会出现一堆文件，表示测试通过。 公共模块CommonsChunkPlugin插件，是一个可选的用于建立一个独立文件(又称作 chunk)的功能，这个文件包括多个入口 chunk 的公共模块。 先访问缓存中的公共代码，加快浏览器的访问速度。 设置： 123456const webpack = require(\"webpack\");// ...new webpack.optimize.CommonsChunkPlugin(&#123; name: 'commons', // 公共 chunk 的名称 filename: 'js/base.js' // 公共 chunk 的文件名&#125;), 使用 webpack-dev-serverwebpack-dev-server 为你提供了一个简单的 web server，并且具有 live reloading(实时重新加载) 功能。 安装： 1yarn add webpack-dev-server@2.9.7 --dev 修改配置文件，告诉 dev server，从什么位置查找文件： 1234devServer: &#123; contentBase: './dist', port: 8082&#125; 接着去 package.json里添加一个可以直接运行 dev server 的 script： 1234\"scripts\": &#123; \"start\": \"webpack-dev-server --open\", \"build\": \"webpack\"&#125;, 这样就不用每次都去访问 node_modules/.bin/webpack 了，直接启动： 1234# 启动 dev servernpm start# 打包构建npm run build 清理 /dist 文件夹需求：每次 build 的时候，发现 /dist 下的文件一直会堆砌，能不能每次构建的时候，只生成项目中真正在使用的文件？ 方法：在每次构建前清理 /dist 文件夹，这样只会生成用到的文件。 使用 clean-webpack-plugin 插件来进行清理: 1yarn add clean-webpack-plugin --dev 设置： 123const &#123; CleanWebpackPlugin &#125; = require(\"clean-webpack-plugin\");new CleanWebpackPlugin(); 模块热替换 HMR需求：在开发环境下，可不可以每次保存之后，不用刷新浏览器，就自动更新了呢？ 方法：模块热替换(hot module replacement 或 HMR)，只更新改动的文件。 设置： 12345678910const webpack = require(\"webpack\");plugins: [ new webpack.HotModuleReplacementPlugin()],devServer: &#123; contentBase: './dist', hot: true, // 开启 port: 8082&#125; 这样，重启服务，然后修改 index.jsx 文件，就会发现自动更新了，妈妈再也不用担心我的 F5 了… 启动 Serverwebpack-dev-middleware 是一个封装器(wrapper)，它可以把 webpack 处理过的文件发送到一个 server。 安装： 12yarn add webpack-dev-middleware@2.0.6 --devyarn add express --dev 根目录新建一个 server.js: 1234567891011121314151617181920const express = require(\"express\");const webpack = require(\"webpack\");const webpackDevMiddleware = require(\"webpack-dev-middleware\");const app = express();const config = require(\"./webpack.config.js\");const compiler = webpack(config);// 告诉 express 使用 webpack-dev-middleware，// 以及将 webpack.config.js 配置文件作为基础配置app.use( webpackDevMiddleware(compiler, &#123; publicPath: config.output.publicPath &#125;));// 使用配置文件的端口号app.listen(config.devServer.port, function() &#123; console.log(`Example app listening on port $&#123;config.devServer.port&#125;!\\n`);&#125;); 我们将会在 server 脚本使用 publicPath，以确保文件资源能够正确地 serve 在 http://localhost:8082 下： 12345output: &#123; path: path.resolve(__dirname, \"dist\"), filename: \"app.js\", publicPath: '/'&#125;, 接着，添加一个 npm script： 1\"server\": \"node server.js\" 跑一下：npm run server，访问 http://localhost:8082/，完美运行。 最后的配置文件webpack.config.js: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374const path = require(\"path\");const webpack = require(\"webpack\");const HtmlWebpackPlugin = require(\"html-webpack-plugin\");const ExtractTextWebpackPlugin = require(\"extract-text-webpack-plugin\");const &#123; CleanWebpackPlugin &#125; = require(\"clean-webpack-plugin\");module.exports = &#123; entry: \"./src/index.jsx\", output: &#123; path: path.resolve(__dirname, \"dist\"), filename: \"app.js\", publicPath: \"/\" &#125;, devServer: &#123; contentBase: \"./dist\", hot: true, port: 8082 &#125;, plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin(&#123; template: \"./src/index.html\" &#125;), new ExtractTextWebpackPlugin(\"styles.css\"), new webpack.optimize.CommonsChunkPlugin(&#123; name: \"commons\", filename: \"js/base.js\" &#125;), new webpack.HotModuleReplacementPlugin() ], module: &#123; rules: [ &#123; test: /\\.(js|jsx)$/, exclude: /(node_modules)/, use: &#123; loader: \"babel-loader\", options: &#123; presets: [\"env\", \"react\"] &#125; &#125; &#125;, &#123; test: /\\.(sc|c)ss$/, use: ExtractTextWebpackPlugin.extract(&#123; fallback: \"style-loader\", use: [\"css-loader\", \"sass-loader\"] &#125;) &#125;, &#123; test: /\\.(png|jpg|gif)$/, use: [ &#123; loader: \"url-loader\", options: &#123; limit: 8192 &#125; &#125; ] &#125;, &#123; test: /\\.(woff|woff2|eot|ttf|otf|svg)$/, use: [ &#123; loader: \"url-loader\", options: &#123; limit: 8192 &#125; &#125; ] &#125; ] &#125;&#125;; 项目目录结构关于 tree 的使用总结：MacOS 如何使用 tree 生成目录结构 常用命令： 1234567891011121314151617181920212223# 下载brew install tree# 显示某个文件夹下的所有文件tree -a# 只显示文件夹tree -d# 显示项目的层级，如三级tree -L 3# 过滤，如除node_modules文件tree -I \"node_modules\"# 输出tree &gt; tree.md# Helptree --help# 最后，我的输出：tree -I \"node_modules\" &gt; tree.md tree.md 的内容为： 12345678910111213141516171819202122232425262728293031323334353637383940.├── README.md├── dist├── package.json├── server.js├── src│ ├── app.scss│ ├── font-awesome│ │ ├── fonts│ │ │ ├── FontAwesome.otf│ │ │ ├── fontawesome-webfont.eot│ │ │ ├── fontawesome-webfont.svg│ │ │ ├── fontawesome-webfont.ttf│ │ │ ├── fontawesome-webfont.woff│ │ │ └── fontawesome-webfont.woff2│ │ └── scss│ │ ├── \\_animated.scss│ │ ├── \\_bordered-pulled.scss│ │ ├── \\_core.scss│ │ ├── \\_fixed-width.scss│ │ ├── \\_icons.scss│ │ ├── \\_larger.scss│ │ ├── \\_list.scss│ │ ├── \\_mixins.scss│ │ ├── \\_path.scss│ │ ├── \\_rotated-flipped.scss│ │ ├── \\_screen-reader.scss│ │ ├── \\_stacked.scss│ │ ├── \\_variables.scss│ │ └── font-awesome.scss│ ├── index.html│ ├── index.js│ ├── index.jsx│ ├── react.png│ └── style.css├── tree.md├── webpack.config.js└── yarn.lock5 directories, 32 files 项目启动 项目里的每一次 Commits，基本上对应着相应的文件配置，可以对照着瞅瞅。 克隆一份项目 1git clone https://github.com/yangtao2o/happymmall.git 进入目录 1cd happymmall 切换分支至 webpack@3-react 1➜ happymmall git:(master) git checkout webpack@3-react 下载依赖包 1➜ happymmall git:(webpack@3-react) yarn install 启动 1➜ happymmall git:(webpack@3-react) npm start","categories":[{"name":"前端框架","slug":"前端框架","permalink":"https://www.yangtao.site/categories/前端框架/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://www.yangtao.site/tags/webpack/"}]},{"title":"入门学习 React 一些实例","slug":"react-demo","date":"2019-08-02T01:10:59.000Z","updated":"2019-11-11T07:26:35.177Z","comments":true,"path":"2019/08/02/react-demo/","link":"","permalink":"https://www.yangtao.site/2019/08/02/react-demo/","excerpt":"这是几个入门学习 React 的小 Demo，帮助自己学习了解 React 的运行机制，结合 React官方文档，会更佳噢…","text":"这是几个入门学习 React 的小 Demo，帮助自己学习了解 React 的运行机制，结合 React官方文档，会更佳噢… DEMO 目录 ReactDOM.render() Use Array in JSX 组件 this.props.children PropTypes 获取真实的 DOM 节点 this.state 表单 组件的生命周期 使用 Promise 获取 Github 的数据 Todo List 井字棋（Tic Tac Toe） 引入资源 With babel-standalone 123456789&lt;div id=\"output\"&gt;&lt;/div&gt;&lt;!-- Load Babel --&gt;&lt;!-- v6 &lt;script src=\"https://unpkg.com/babel-standalone@6/babel.min.js\"&gt;&lt;/script&gt; --&gt;&lt;script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"&gt;&lt;/script&gt;&lt;!-- Your custom script here --&gt;&lt;script type=\"text/babel\"&gt;const getMessage = () =&gt; \"Hello World\";document.getElementById('output').innerHTML = getMessage();&lt;/script&gt; Demo01: ReactDOM.render()Demo / Source 初始化咱先 Hello 一下，使用 jsx 语法，碰到代码块使用（{ }）包起来，碰到 html 标签，就使用（&lt; /&gt;）: 123456789var names = [\"AAA\", \"BBB\", \"CCC\"];ReactDOM.render( &lt;div&gt; &#123;names.map(function(name) &#123; return &lt;h2&gt;Hello, &#123;name&#125;!&lt;/h2&gt;; &#125;)&#125; &lt;/div&gt;, document.getElementById(\"example\")); Demo02: Use Array in JSXDemo / Source 如果 JavaScript 的变量是个数组，会展开这个数组的所有项. 12var arr = [&lt;h1 key=\"h1\"&gt;Hello,&lt;/h1&gt;, &lt;h2 key=\"h2\"&gt;React is awesome!&lt;/h2&gt;];ReactDOM.render(&lt;div&gt;&#123;arr&#125;&lt;/div&gt;, document.getElementById(\"example\")); Demo03: 组件Demo / Source 变量 HelloMsg 是一个组件类。模板插入 时，会自动生成 HelloMsg 的一个实例。所有组件类都必须有自己的 render 方法，用于输出组件。 123456789class HelloMsg extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125;ReactDOM.render( &lt;HelloMsg name=\"Dataozi\" /&gt;, document.getElementById(\"example\")); Demo04: this.props.childrenDemo / Source this.props 对象的属性与组件的属性一一对应，但是有一个例外，就是 this.props.children 属性。 ps: 注意大小写 React.Children、React.Component 12345678910111213141516171819class NotesList extends React.Component &#123; render() &#123; return ( &lt;ol&gt; &#123;React.Children.map(this.props.children, function(child) &#123; return &lt;li&gt;&#123;child&#125;&lt;/li&gt;; &#125;)&#125; &lt;/ol&gt; ); &#125;&#125;ReactDOM.render( &lt;NotesList&gt; &lt;span&gt;Hello&lt;/span&gt; &lt;span&gt;World&lt;/span&gt; &lt;span&gt;React&lt;/span&gt; &lt;/NotesList&gt;, document.getElementById(\"example\")); Demo05: PropTypesDemo / Source 使用 PropTypes 进行类型检查 React 内置了一些类型检查的功能。要在组件的 props 上进行类型检查，你只需配置特定的 propTypes 属性: 12345678910111213141516171819202122var data = &#123; tilte: \"Hello\", age: 19, isStudent: true&#125;;class MyTitle extends React.Component &#123; static propTypes = &#123; tilte: PropTypes.string, age: PropTypes.number, isStudent: PropTypes.bool &#125;; render() &#123; return ( &lt;div&gt; &lt;h1&gt;&#123;this.props.data.tilte&#125;&lt;/h1&gt; &lt;h2&gt;&#123;this.props.data.age&#125;&lt;/h2&gt; &lt;h3&gt;&#123;this.props.data.isStudent ? \"Yes\" : \"No\"&#125;&lt;/h3&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render(&lt;MyTitle data=&#123;data&#125; /&gt;, document.getElementById(\"root\")); 还可以通过配置特定的 defaultProps 属性来定义 props 的默认值： 1234567891011class DefaultTitle extends React.Component &#123; render() &#123; return &lt;h4&gt;&#123;this.props.title&#125;&lt;/h4&gt;; &#125;&#125;//指定 props 的默认值：DefaultTitle.defaultProps = &#123; title: \"Hello React!\"&#125;;ReactDOM.render(&lt;DefaultTitle /&gt;, document.getElementById(\"root2\")); Demo06: 获取真实的 DOM 节点Demo / Source Refs and the DOM Refs 提供了一种方式，允许我们访问 DOM 节点或在 render 方法中创建的 React 元素。 创建 Refs: Refs 是由React.createRef()创建的，并通过 ref 属性附加到 React 元素（比如 input） 访问 Refs: 当 ref 被传递给 render 中的元素时，对该节点的引用可以在 ref 的 current 属性中被访问，this.myTextFocus.current.focus(); 你不能在函数组件上使用 ref 属性，因为它们没有实例 组件 MyComponent 的子节点有一个文本输入框，用于获取用户的输入。这时就必须获取真实的 DOM 节点，虚拟 DOM 是拿不到用户输入的。 123456789101112131415161718192021222324class MyComponent extends React.Component &#123; constructor(props) &#123; super(props); // 创建一个 ref 来存储 myTextFocus 的 DOM 元素 this.myTextFocus = React.createRef(); this.handerClick = this.handerClick.bind(this); &#125; handerClick() &#123; // 直接使用原生 API 使 text 输入框获得焦点 // 通过 \"current\" 来访问 DOM 节点 this.myTextFocus.current.focus(); &#125; render() &#123; // 告诉 React 我们想把 &lt;input&gt; ref 关联到 // 构造器里创建的 `myTextFocus` 上 return ( &lt;div&gt; &lt;input type=\"text\" ref=&#123;this.myTextFocus&#125; /&gt; &lt;input type=\"button\" value=\"点击聚焦\" onClick=&#123;this.handerClick&#125; /&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render(&lt;MyComponent /&gt;, document.getElementById(\"root\")); Demo07: this.stateDemo / Source State &amp; 生命周期 学习如何封装真正可复用的 Clock 组件。它将设置自己的计时器并每秒更新一次。 1234567891011121314151617181920212223242526272829303132class Clock extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; date: new Date() &#125;; //为 this.state 赋初值 &#125; componentDidMount() &#123; // Clock初次被渲染到DOM时，为\u001f其挂载一个计时器 this.timerID = setInterval(() =&gt; this.tick(), 1000); &#125; componentWillUnmount() &#123; // Clock被删除时，卸载其计时器 clearInterval(this.timerID); &#125; tick() &#123; // 使用 this.setState() 来时刻更新组件 state this.setState(&#123; date: new Date() &#125;); &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, React!&lt;/h1&gt; &lt;h2&gt;现在是北京时间：&#123;this.state.date.toLocaleTimeString()&#125;&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render(&lt;Clock /&gt;, document.getElementById(\"root\")); Demo08: 表单Demo / Source 表单 受控组件：渲染表单的 React 组件还控制着用户输入过程中表单发生的操作，被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”。 即：表单数据是由 React 组件来管理的。 123456789101112131415161718192021222324252627282930313233343536class NameForm extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; // 唯一数据源 value: \"\" &#125;; this.handleChange = this.handleChange.bind(this); this.handleSubmit = this.handleSubmit.bind(this); &#125; handleChange(event) &#123; this.setState(&#123; value: event.target.value // 显示的值将随着用户输入而更新 &#125;); &#125; handleSubmit(event) &#123; if (this.state.value) &#123; alert(\"接受到的name值是：\" + this.state.value); &#125; event.preventDefault(); &#125; render() &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;input type=\"text\" value=&#123;this.state.value&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;input type=\"submit\" value=\"提交\" /&gt; &lt;/form&gt; ); &#125;&#125;ReactDOM.render(&lt;NameForm /&gt;, document.getElementById(\"root\")); 非受控组件：表单数据将交由 DOM 节点来处理，即使用 ref 来从 DOM 节点中获取表单数据 Demo / Source 123456789101112131415161718192021class NameForm extends React.Component &#123; constructor(props) &#123; super(props); this.input = React.createRef(); this.handleSubmit = this.handleSubmit.bind(this); &#125; handleSubmit(event) &#123; alert(\"接受到的name值是：\" + this.input.current.value); event.preventDefault(); &#125; render() &#123; return ( &lt;form onSubmit=&#123;this.handleSubmit&#125;&gt; &lt;input type=\"text\" ref=&#123;this.input&#125; /&gt; &lt;input type=\"submit\" value=\"提交\" /&gt; &lt;/form&gt; ); &#125;&#125;ReactDOM.render(&lt;NameForm /&gt;, document.getElementById(\"root\")); Demo09: 组件的生命周期Demo / Source 组件的生命周期 生命周期图谱速查表 React 的生命周期 — Ant Design 语雀 主要路线顺序：挂载 - 更新 - 卸载 - 错误处理 挂载 当组件实例被创建并插入 DOM 中时，其生命周期调用如下： consctructor() — React 组件的构造函数，不初始化 state 或不进行方法绑定，则不需要 static getDerivedStateFromProps() — 不常用 render() — 唯一必须实现的方法，并且应该是纯函数 componentDidMount() — 依赖于 DOM 节点的初始化应该在这里 更新 当组件的 props 或 state 发生变化时，会触发更新： static getDerivedStateFromProps() shouldComponentUpdate() render() getSnapshotBeforeUpdate() — 不常用 componentDidUpdate() — 在更新后会被立即调用 卸载 当组件从 DOM 中移除时： componentWillUnmount() — 会在组件卸载及销毁之前直接调用 错误处理 当渲染过程，生命周期，或子组件的构造函数中抛出错误时： static getDerivedStateFromError() componentDidCatch() 过期的生命周期方法： UNSAFE_componentWillMount() — 挂载前调用，目前使用 constructor()初始化 state UNSAFE_componentWillReceiveProps() UNSAFE_componentWillUpdate() 12345678910111213141516171819202122232425262728293031323334353637383940class Hello extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; fontSize: 12, opacity: 0.01 &#125;; &#125; componentDidMount() &#123; this.timerID = setInterval(() =&gt; &#123; let opacity = this.state.opacity; let fontSize = this.state.fontSize; opacity += 0.02; fontSize += 1; if (opacity &gt;= 1) &#123; opacity = 0.01; &#125; if (fontSize &gt;= 63) &#123; fontSize = 12; &#125; this.setState(&#123; fontSize, opacity &#125;); &#125;, 100); &#125; componentWillUnmount() &#123; clearInterval(this.timerID); &#125; render() &#123; return ( &lt;h1 style=&#123;&#123; opacity: this.state.opacity, fontSize: this.state.fontSize &#125;&#125; &gt; Hello, &#123;this.props.name&#125; &lt;/h1&gt; ); &#125;&#125;ReactDOM.render(&lt;Hello name=\"React\" /&gt;, document.getElementById(\"root\")); Demo10: 使用 Promise 获取 Github 的数据Demo / Source 12345678ReactDOM.render( &lt;ReportList promise=&#123;$.getJSON( \"https://api.github.com/search/repositories?q=javascript&amp;sort=stars\" )&#125; /&gt;, document.getElementById(\"root\")); 从 Github 的 API 抓取数据，然后将 Promise 对象作为属性，传给 ReportList 组件。 如果 Promise 对象正在抓取数据（pending 状态），组件显示”loading…”； 如果 Promise 对象报错（rejected 状态），组件显示报错信息； 如果 Promise 对象抓取数据成功（fulfilled 状态），组件显示获取的数据。 在这里查看完整 Demo/源码 — 谷歌浏览器有时候会报跨域的问题，可以使用火狐等浏览器试看 接下来来几个混合实战吧Demo11: Todo ListDemo / Source React todo list 主要练习使用 props 和 state，使用 state 保存现有的待办事项列表及用户的一些操作（删除、完成）等。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class TodoApp extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; items: [] &#125;; this.addItem = this.addItem.bind(this); this.deleteItem = this.deleteItem.bind(this); this.doneItem = this.doneItem.bind(this); &#125; addItem(item) &#123; const newItem = &#123; text: item.text, id: Date.now(), done: false &#125;; this.setState(&#123; items: this.state.items.concat(newItem) &#125;); &#125; deleteItem(index) &#123; this.state.items.splice(index, 1); this.setState(&#123; items: this.state.items &#125;); &#125; doneItem(index) &#123; const items = this.state.items; const todo = items[index]; items.splice(index, 1); todo.done = !todo.done; todo.done ? items.unshift(todo) : items.push(todo); this.setState(&#123; items &#125;); &#125; render() &#123; return ( &lt;div className=\"container\"&gt; &lt;h1&gt;TODO&lt;/h1&gt; &lt;TodoList items=&#123;this.state.items&#125; deleteClick=&#123;this.deleteItem&#125; doneClick=&#123;this.doneItem&#125; /&gt; &lt;TodoForm addItem=&#123;this.addItem&#125; items=&#123;this.state.items&#125; /&gt; &lt;/div&gt; ); &#125;&#125; Demo12: 井字棋（Tic Tac Toe）Demo / Source Tic Tac Toe 井字棋游戏教程文档 React 的井字过三关 tic-tac-toe(三连棋)游戏的功能 能够判定玩家何时获胜 能够记录游戏进程 允许玩家查看游戏的历史记录，也可以查看任意一个历史版本的游戏棋盘状态 在游戏历史记录列表显示每一步棋的坐标，格式为 (列号, 行号) 在历史记录列表中加粗显示当前选择的项目 当无人获胜时，显示一个平局的消息 使用两个循环来渲染出棋盘的格子，而不是在代码里写死（hardcode） 添加一个可以升序或降序显示历史记录的按钮 每当有人获胜时，高亮显示连成一线的 3 颗棋子 学习资料 React 入门实例教程 — 阮一峰 react-demos","categories":[{"name":"前端框架","slug":"前端框架","permalink":"https://www.yangtao.site/categories/前端框架/"}],"tags":[{"name":"react","slug":"react","permalink":"https://www.yangtao.site/tags/react/"}]},{"title":"Nodejs 日常杂记","slug":"node-learning","date":"2019-07-10T12:30:38.000Z","updated":"2019-11-11T06:55:33.178Z","comments":true,"path":"2019/07/10/node-learning/","link":"","permalink":"https://www.yangtao.site/2019/07/10/node-learning/","excerpt":"Node.js® is a JavaScript runtime built on Chrome&#39;s V8 JavaScript engine. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient. Node.js’ package ecosystem, npm, is the largest ecosystem of open source libraries in the world.","text":"Node.js® is a JavaScript runtime built on Chrome&#39;s V8 JavaScript engine. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient. Node.js’ package ecosystem, npm, is the largest ecosystem of open source libraries in the world. 学习书籍|视频 菜鸟教程 - 文档 7-days-nodejs - 文章 《Node.js 包教不包会》 – 文章 《了不起的 Node.js：将 JavaScript 进行到底》- 书籍 《新时期的 Node.js 入门》- 书籍 Node.js 从零开发 Web Server 博客项目 前端晋升全栈工程师必备 - 视频 学习资料 Node.js 入门 Node.js 官方文档 CNode：Node.js 专业中文社区 【全文】狼叔：如何正确的学习 Node.js Express-4.x 官方指南 react 全家桶+express 实战个人博客系列教程 详解如何从零开始搭建 Express+Vue 开发环境 vue 项目-前端 Vue 后台 express 【实战】用 express+MongoDB 搭建一个完整的前端项目 基于 Vue+express 的博客项目 Promise Node.js 最新技术栈之 Promise 篇 - 2015 理解 Promise 的工作原理 JavaScript Promise 迷你书（中文版） 周边大咖 wesome-nodejs @justjavac 大神的免费的计算机编程类中文书籍 【知乎 Live】狼叔：如何正确的学习 Node.js 学习日志 Http Tcp Connect Event Express-init Express-spider Express-spider-more npm package 积累 Node 相关 网站初始化，实现 GET 和 POST 的 Ajax 请求 登录模块 上传图片模块 node-blog-express-koa2 node-express-mongodb node-express-spider","categories":[],"tags":[]},{"title":"使用 superagent 与 cheerio 完成简单爬虫","slug":"node-express-spider","date":"2019-07-06T06:38:13.000Z","updated":"2019-11-11T06:51:44.246Z","comments":true,"path":"2019/07/06/node-express-spider/","link":"","permalink":"https://www.yangtao.site/2019/07/06/node-express-spider/","excerpt":"爬一下 CNode 专业中文社区","text":"爬一下 CNode 专业中文社区 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647const express = require(\"express\");const superagent = require(\"superagent\");const cheerio = require(\"cheerio\");const app = express();const PORT = process.env.PORT || 8000;const URL = \"https://cnodejs.org\";/** * 当在浏览器中访问 http://localhost:8000/ 时，输出 CNode(https://cnodejs.org/ ) 社区首页的所有帖子标题和链接，以 json 的形式。 */app.get(\"/\", (req, res, next) =&gt; &#123; // 使用 superagent 获取 url superagent.get(URL, (err, sres) =&gt; &#123; if (err) &#123; return next(err); &#125; const $ = cheerio.load(sres.text); const items = []; const $target = $(\"#topic_list .topic_title\"); let itemsHtml = \"\"; $target.each((i, item) =&gt; &#123; let $this = $(item); items.push(&#123; title: $this.attr(\"title\"), url: URL + $this.attr(\"href\") &#125;); &#125;); console.log(\"items---&gt;\", items); // 以 JSON 格式打印 if (items) &#123; $(items).each((i, item) =&gt; &#123; itemsHtml += `&lt;li&gt;&lt;a href=\"$&#123;item.url&#125;\" title=\"$&#123;item.title&#125;\"&gt;$&#123;item.title&#125;&lt;/a&gt;&lt;/li&gt;`; &#125;); itemsHtml = `&lt;ol id=\"listItem\"&gt;$&#123;itemsHtml&#125;&lt;/ol&gt;`; &#125; else &#123; itemsHtml = `&lt;p&gt;暂时还获取不到数据...&lt;/p&gt;`; &#125; res.send(itemsHtml); &#125;);&#125;);app.listen(PORT, (req, res) =&gt; &#123; console.log(\"App is listening at port \" + PORT);&#125;); 并发请求处理输出 CNode 社区首页的所有主题的标题，链接和第一条评论，以 json 的格式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990const express = require(\"express\");const superagent = require(\"superagent\");const cheerio = require(\"cheerio\");const morgan = require(\"morgan\");const async = require(\"async\");const app = express();const PORT = process.env.PORT || 8000;const URL = \"https://cnodejs.org\";app.set(\"view engine\", \"ejs\");app.use(morgan(\"dev\"));app.use(express.json());/** * 控制并发请求 */app.get(\"/\", (req, res, next) =&gt; &#123; console.log(\"loading...\"); console.log(`正在请求$&#123;URL&#125;`); superagent.get(URL).end((err, sres) =&gt; &#123; if (err) &#123; return console.error(err); &#125; const topicUrls = []; const $ = cheerio.load(sres.text); let concurrencyCount = 0; const fetchUrl = (url, callback) =&gt; &#123; let getItem = &#123;&#125;; superagent.get(url).end((err, sres) =&gt; &#123; if (err) &#123; return new Error(err); &#125; const $ = cheerio.load(sres.text); concurrencyCount++; getItem = &#123; href: url, title: $(\".topic_full_title\") .text() .replace(/[\\r\\n]/g, \"\"), comment: $(\".reply_content\") .eq(0) .text() .replace(/[\\ \\r\\n]/g, \"\") &#125;; console.log( `\\r\\n正在请求第 $&#123;concurrencyCount&#125; 条的数据data:\\r\\n$&#123;[ JSON.stringify(getItem) ]&#125;` ); callback(null, getItem); &#125;); &#125;; $(\"#topic_list .topic_title\").each(function(idx, element) &#123; const $element = $(element); const href = URL + $element.attr(\"href\"); console.log(`正在获取第 $&#123;idx + 1&#125; 条列表的url：$&#123;href&#125;`); topicUrls.push(href); &#125;); if (topicUrls.length &lt; 1) return; console.log(`\\r\\n开始并发请求...\\r\\n`); async.mapLimit( topicUrls, 3, (url, callback) =&gt; &#123; console.time(\"delay\"); fetchUrl(url, callback); console.timeEnd(\"delay\"); &#125;, (err, results) =&gt; &#123; console.log(\"\\r获取到的数据: \\r\\n\", results); res.json(results); &#125; ); &#125;);&#125;);app.listen(PORT, (req, res) =&gt; &#123; console.log(\"App is listening at port \" + PORT);&#125;); 优化下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102const express = require(\"express\");const superagent = require(\"superagent\");const cheerio = require(\"cheerio\");const morgan = require(\"morgan\");const async = require(\"async\");const app = express();const PORT = process.env.PORT || 3000;const URL = \"https://cnodejs.org\";const ALLNUMS = 20;const TIEMS = 2;app.set(\"view engine\", \"ejs\");app.use(morgan(\"dev\"));app.use(express.json());/** * 控制并发请求 */app.get(\"/\", (req, res, next) =&gt; &#123; console.log(\"loading...\"); console.log(`正在请求$&#123;URL&#125;`); const getHomePageUrls = new Promise((resolve, reject) =&gt; &#123; superagent.get(URL).end((err, sres) =&gt; &#123; if (err) &#123; return reject(err); &#125; const topicUrls = []; const $ = cheerio.load(sres.text); $(\"#topic_list .topic_title\").each(function(idx, element) &#123; const $element = $(element); const href = URL + $element.attr(\"href\"); console.log(`正在获取第 $&#123;idx + 1&#125; 条列表的url：$&#123;href&#125;`); topicUrls.push(href); &#125;); if (topicUrls.length &gt; 0) &#123; resolve(topicUrls.slice(0, ALLNUMS)); &#125; &#125;); &#125;); let concurrencyCount = 0; const fetchUrl = (url, callback) =&gt; &#123; let getItem = &#123;&#125;; superagent.get(url).end((err, sres) =&gt; &#123; if (err) &#123; return new Error(err); &#125; const $ = cheerio.load(sres.text); concurrencyCount++; getItem = &#123; href: url, title: $(\".topic_full_title\") .text() .replace(/[\\ \\r\\n]/g, \"\"), comment: $(\".reply_content\") .eq(0) .text() .replace(/[\\ \\r\\n]/g, \"\") &#125;; console.log( `\\r\\n正在请求第 $&#123;concurrencyCount&#125; 条的数据data:\\r\\n$&#123;[ JSON.stringify(getItem) ]&#125;` ); callback(null, getItem); &#125;); &#125;; Promise.race([getHomePageUrls]) .then(itemUrls =&gt; &#123; console.log(`\\r\\n开始并发 $&#123;TIEMS&#125; 次请求...\\r\\n`); async.mapLimit( itemUrls, TIEMS, (url, callback) =&gt; &#123; console.time(\"delay\"); fetchUrl(url, callback); console.timeEnd(\"delay\"); &#125;, (err, results) =&gt; &#123; console.log(\"\\r获取到的数据: \\r\\n\", results); res.json(results); &#125; ); &#125;) .catch(err =&gt; console.error(err));&#125;);app.listen(PORT, (req, res) =&gt; &#123; console.log(\"App is listening at port \" + PORT);&#125;);","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://www.yangtao.site/categories/Nodejs/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://www.yangtao.site/tags/Nodejs/"}]},{"title":"Nodejs系列之Events","slug":"node-events","date":"2019-06-25T12:11:58.000Z","updated":"2019-11-11T06:52:24.259Z","comments":true,"path":"2019/06/25/node-events/","link":"","permalink":"https://www.yangtao.site/2019/06/25/node-events/","excerpt":"Node.js 事件循环Node.js 是单进程单线程应用程序，但是因为 V8 引擎提供的异步执行回调接口，通过这些接口可以处理大量的并发，所以性能非常高。","text":"Node.js 事件循环Node.js 是单进程单线程应用程序，但是因为 V8 引擎提供的异步执行回调接口，通过这些接口可以处理大量的并发，所以性能非常高。 Node.js 几乎每一个 API 都是支持回调函数的。 Node.js 基本上所有的事件机制都是用设计模式中观察者模式实现。 Node.js 单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数. EventEmitter 提供了多个属性，如on和emit。 on 函数用于绑定事件函数，emit 属性用于触发一个事件。 12345678910111213141516171819const events = require('events')// 创建 eventEmitter 对象const eventEmitter = new events.EventEmitter()// 绑定 connection 事件处理程序eventEmitter.on('connection', () =&gt; &#123; console.log('建立连接...') // 触发 dataReceived 事件 eventEmitter.emit('dataReceived')&#125;)// 绑定 dataReceived 事件处理程序eventEmitter.on('dataReceived', () =&gt; &#123; console.log('接收数据中...')&#125;)// 触发 connection 事件eventEmitter.emit('connection')console.log(\"数据接收完毕！\"); 1234➜ node 02-event.js建立连接...接收数据中...数据接收完毕！ EventEmitter 类写法： 12345678910const EventEmitter = require('events');// class 继承class MyEmitter extends EventEmitter &#123;&#125;// 实例化const myEmitter = new MyEmitter();myEmitter.on('event', () =&gt; &#123; console.log('触发事件');&#125;);myEmitter.emit('event'); EventEmitter 类Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。 Node.js 里面的许多对象都会分发事件：一个 net.Server 对象会在每次有新连接时触发一个事件， 一个 fs.readStream 对象会在文件被打开的时候触发一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。 EventEmitter 类由 events 模块定义： 12const EventEmitter = require('events');const myEmitter = new EventEmitter(); EventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。 对于每个事件，EventEmitter 支持 若干个事件监听器。 当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。 1234567891011121314151617181920const EventEmitter = require('events');const myEmitter = new EventEmitter();// 第一个监听器。myEmitter.on('event', function firstListener() &#123; console.log('第一个监听器');&#125;);// 第二个监听器。myEmitter.on('event', function secondListener(arg1, arg2) &#123; console.log(`第二个监听器中的事件有参数 $&#123;arg1&#125;、$&#123;arg2&#125;`);&#125;);// 第三个监听器myEmitter.on('event', function thirdListener(...args) &#123; const parameters = args.join(', '); console.log(`第三个监听器中的事件有参数 $&#123;parameters&#125;`);&#125;);console.log(myEmitter.listeners('event'));myEmitter.emit('event', 1, 2, 3, 4, 5); myEmitter 为事件 event 注册了三个个事件监听器，然后触发 event 事件，输出： 123第一个监听器第二个监听器中的事件有参数 1、2第三个监听器中的事件有参数 1, 2, 3, 4, 5 EventEmitter 提供了多个属性，初了绑定事件函数的on和触发事件函数的emit，还有如下一些属性： addListener(event, listener)为指定事件添加一个监听器到监听器数组的尾部，emitter.on(eventName, listener) 的别名。 once(event, listener)为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器 removeListener(event, listener)移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器 removeAllListeners([event])移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器 setMaxListeners(n)默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于提高监听器的默认限制的数量。 listeners(event)返回名为 eventName 的事件的监听器数组的副本 on(event, listener)为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数 off(eventName, listener)removeListener() 的别名 emit(event, [arg1], [arg2], […])按监听器的顺序执行执行每个监听器，如果事件有注册监听返回 true，否则返回 false listenerCount(eventName)返回正在监听的名为 eventName 的事件的监听器的数量 练习下： 123456789101112131415161718192021222324252627const EventEmitter = require('events')const myEmitter = new EventEmitter()const listener1 = () =&gt; &#123; console.log('监听器1启动')&#125;const listener2 = () =&gt; &#123; console.log('监听器2启动')&#125;myEmitter.on('event', listener1)myEmitter.on('event', listener2)let listeners = myEmitter.listenerCount('event')console.log(`现在有$&#123;listeners&#125;个监听器正在监听事件`)myEmitter.emit('event')myEmitter.off('event', listener1)console.log('监听器1已被移除')myEmitter.emit('event')listeners = myEmitter.listenerCount('event')console.log(`现在有 $&#123;listeners&#125; 个监听器正在监听事件`)console.log('End!') 输出： 12345678[nodemon] starting `node 04-event.js`现在有2个监听器正在监听事件监听器1启动监听器2启动监听器1已被移除监听器2启动现在有 1 个监听器正在监听事件End! 错误事件当 EventEmitter 实例出错时，应该触发 ‘error’ 事件。 这些在 Node.js 中被视为特殊情况。 123456const EventEmitter = require('events');class MyEmitter extends EventEmitter &#123;&#125;const myEmitter = new MyEmitter();myEmitter.emit('error', new Error('错误信息')); 如果没有为 ‘error’ 事件注册监听器，则当 ‘error’ 事件触发时，会抛出错误、打印堆栈跟踪、并退出 Node.js 进程。 所以最佳实践是，应该始终为 ‘error’ 事件注册监听器： 123456const myEmitter = new MyEmitter();myEmitter.on('error', (err) =&gt; &#123; console.error('错误信息');&#125;);myEmitter.emit('error', new Error('错误'));// 打印: 错误信息 Node 应用程序是如何工作的创建一个 input.txt ,文件内容如：www.runoob.com 12345678910111213141516171819const fs = require('fs')// 阻塞// 在文件读取完后才执行完程序const getData = fs.readFileSync('test/input.txt')console.log(getData.toString())console.log('阻塞程序运行结束')// 非阻塞// 不需要等待文件读取完，这样就可以在读取文件时同时执行接下来的代码，大大提高了程序的性能fs.readFile('test/input.txt', (err, data) =&gt; &#123; if(err) &#123; return console.error(err) &#125; console.log(data.toString())&#125;)console.log('非阻塞程序运行结束') 如果没发生错误，readFileSync 或者 readFile 跳过 err 对象的输出，文件内容就通过回调函数输出： 1234www.runoob.com阻塞程序运行结束非阻塞程序运行结束www.runoob.com 接下来我们删除 input.txt 文件，执行结果如下所示： 1&#123; [Error: ENOENT: no such file or directory, open 'input.txt'] errno: -2, code: 'ENOENT', syscall: 'open', path: 'input.txt' &#125; 学习资料 菜鸟教程之 Node.js 学习 官方文档之 events（事件触发器）","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://www.yangtao.site/categories/Nodejs/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://www.yangtao.site/tags/Nodejs/"}]},{"title":"Nodejs系列之HTTP","slug":"node-http","date":"2019-06-14T11:10:40.000Z","updated":"2019-11-11T06:51:25.375Z","comments":true,"path":"2019/06/14/node-http/","link":"","permalink":"https://www.yangtao.site/2019/06/14/node-http/","excerpt":"超文本传输协议，是一种 Web 协议，属于 TCP 上层的协议。 HTTP 模块式 Node 的核心模块，主要提供了一系列用于网络传输的 API。","text":"超文本传输协议，是一种 Web 协议，属于 TCP 上层的协议。 HTTP 模块式 Node 的核心模块，主要提供了一系列用于网络传输的 API。 HTTP 消息头如下所示(键是小写的，值不能被修改)： 1234567&#123; \"content-length\": \"123\", \"content-type\": \"text/plain\", \"connection\": \"keep-alive\", \"host\": \"mysite.com\", \"accept\": \"*/*\"&#125; 创建 HTTP 服务器使用 NodeJS 内置的 http 模块简单实现一个 HTTP 服务器: 12345678const http = require(\"http\");http .createServer((request, response) =&gt; &#123; response.writeHead(200, &#123; \"Content-Type\": \"text/plain\" &#125;); response.end(\"Hello World!\"); &#125;) .listen(3000); 以上程序创建了一个 HTTP 服务器并监听 3000 端口，打开浏览器访问该端口http://127.0.0.1:3000/就能够看到效果。 使用 createServer 创建一个 HTTP 服务器，该方法返回一个 http.server 类的实例。 createServer 方法包含了一个匿名的回调函数，该函数有两个参数 request，response，它们是 IncomingMessage 和 ServerResponse 的实例。 分别表示 HTTP 的 request 和 response 对象，当服务器创建完成后，Node 进程开始循环监听 3000 端口。 http.server 类定义了一系列的事件，如 connection 和 request 事件。 处理 HTTP 请求method，URL 和 headerNode 将相关的信息封装在一个对象（request）中，该对象是 IncomingMessage 的实例。 获取 method、URL： 12const method = req.method;const url = req.url; 比如访问http://127.0.0.1:8000/index.html?name=tao，就会输出： 1234&#123; \"method\": \"GET\", \"url\": \"/index.html?name=tao\"&#125; URL 的值为去除网站服务器地址之外的完整值。 header获取 HTTP header 信息： 12const headers = req.headers;const userAgent = headers[\"user-agent\"]; 输出： 12345678910111213&#123; \"headers\": &#123; \"host\": \"127.0.0.1:8000\", \"user-agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:68.0) Gecko/20100101 Firefox/68.0\", \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\", \"accept-language\": \"zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\", \"accept-encoding\": \"gzip, deflate\", \"connection\": \"keep-alive\", \"upgrade-insecure-requests\": \"1\", \"cache-control\": \"max-age=0\" &#125;, \"userAgent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10.13; rv:68.0) Gecko/20100101 Firefox/68.0\"&#125; header 是一个 JSON 对象，可以对属性名进行单独索引。 request bodyNode 使用 stream 处理 HTTP 的请求体，并且注册了两个事件：data 和 end。 获取完整的 HTTP 内容体： 123456789let body = [];request.on(\"data\", chunk =&gt; &#123; body.push(chunk);&#125;);request.on(\"end\", () =&gt; &#123; body = Buffer.concat(body).toString();&#125;); Response 对象get/post 请求综上所述，我们来组织一个简易的 get、post 请求实例： 12345678910111213141516171819202122232425262728293031323334353637383940const http = require(\"http\");const querystring = require(\"querystring\");http .createServer((req, res) =&gt; &#123; const method = req.method; const url = req.url; const path = url.split(\"?\")[0]; const query = querystring.parse(url.split(\"?\")[1]); const headers = req.headers; const userAgent = headers[\"user-agent\"]; const resData = &#123; method, url, path, query, headers, userAgent &#125;; res.setHeader(\"Content-type\", \"application/json\"); if (method === \"GET\") &#123; res.end(JSON.stringify(resData)); &#125; if (method === \"POST\") &#123; let postData = []; req.on(\"data\", chunk =&gt; &#123; postData.push(chunk); &#125;); req.on(\"end\", () =&gt; &#123; resData.postData = Buffer.concat(postData).toString(); res.end(JSON.stringify(resData)); &#125;); &#125; &#125;) .listen(8000); 比如POST请求 http://127.0.0.1:8000/api/blog?ip=2，然后使用 Postman 工具测试结果如下： 123456789101112131415161718192021&#123; \"method\": \"POST\", \"url\": \"/api/blog?ip=2\", \"path\": \"/api/blog\", \"query\": &#123; \"ip\": \"2\" &#125;, \"headers\": &#123; \"content-type\": \"application/json\", \"cache-control\": \"no-cache\", \"postman-token\": \"9e6cb382-8551-4a3f-b352-0581bb377cbc\", \"user-agent\": \"PostmanRuntime/7.6.0\", \"accept\": \"*/*\", \"host\": \"127.0.0.1:8000\", \"accept-encoding\": \"gzip, deflate\", \"content-length\": \"62\", \"connection\": \"keep-alive\" &#125;, \"userAgent\": \"PostmanRuntime/7.6.0\", \"postData\": \"&#123;\\n\\t\\\"title\\\": \\\"你说什么\\\",\\n\\t\\\"content\\\": \\\"我知道你知道\\\"\\n&#125;\"&#125; httphttp 模块提供两种使用方式： 作为服务端使用时，创建一个 HTTP 服务器，监听 HTTP 客户端请求并返回响应。 作为客户端使用时，发起一个 HTTP 客户端请求，获取服务端响应。 一个简单的 Web 服务器123456789101112131415161718192021222324252627282930313233343536373839404142const http = require(\"http\");const qs = require(\"querystring\");http .createServer(function(req, res) &#123; if (\"/\" == req.url) &#123; res.writeHead(200, &#123; \"Content-Type\": \"text/html\" &#125;); res.end( [ '&lt;form method=\"POST\" action=\"/url\"&gt;', \"&lt;h1&gt;My Form&lt;/h1&gt;\", \"&lt;fieldset&gt;\", \"&lt;label&gt;Personal information&lt;/label&gt;\", \"&lt;p&gt;What is your name?&lt;/p&gt;\", '&lt;input type=\"text\" name=\"name\" /&gt;', \"&lt;p&gt;&lt;button&gt;Submit&lt;/button&gt;&lt;/p&gt;\", \"&lt;/fieldset&gt;\", \"&lt;/form&gt;\" ].join(\"\") ); &#125; else if (\"/url\" == req.url &amp;&amp; \"POST\" == req.method) &#123; var body = \"\"; req.on(\"data\", function(chunk) &#123; body += chunk; &#125;); req.on(\"end\", function() &#123; res.writeHead(200, &#123; \"Content-Type\": \"text/html\" &#125;); res.end( \"&lt;p&gt;Content-type: \" + req.headers[\"content-type\"] + \"&lt;/p&gt;\" + \"&lt;p&gt;Data: \" + qs.parse(body).name + \"&lt;/p&gt;\" ); &#125;); &#125; else &#123; res.writeHead(404); res.end(\"Not Found.\"); &#125; &#125;) .listen(3000); 一个 Twitter Web 客户端创建服务器：app.js 12345678910111213141516const http = require(\"http\");const qs = require(\"querystring\");http .createServer(function(req, res) &#123; var body = \"\"; req.on(\"data\", function(chunk) &#123; body += chunk; &#125;); req.on(\"end\", function() &#123; res.writeHead(200); res.end(\"Done\"); console.log(\"\\n got name \\033[90m\" + qs.parse(body).name + \"\\033[39m\\n\"); &#125;); &#125;) .listen(3000); 创建客户端：client.js 123456789101112131415161718192021222324252627282930313233const http = require(\"http\");const qs = require(\"querystring\");function send(theName) &#123; http .request( &#123; host: \"127.0.0.1\", port: 3000, url: \"/\", method: \"POST\" &#125;, function(res) &#123; var body = \"\"; res.setEncoding(\"utf8\"); res.on(\"data\", function(chunk) &#123; body += chunk; &#125;); res.on(\"end\", function() &#123; console.log(\"\\n \\033[90m request complete! \\033[39m\"); process.stdout.write(\"\\n your name: \"); &#125;); &#125; ) .end(qs.stringify(&#123; name: theName &#125;));&#125;process.stdout.write(\"\\n your name: \");process.stdin.resume();process.stdin.setEncoding(\"utf-8\");process.stdin.on(\"data\", function(name) &#123; send(name.replace(\"\\n\", \"\"));&#125;); 启动node app.js，再启动node client.js HTTPSHTTPS 是基于 TLS/SSL 的 HTTP 协议。在 Node.js 中，作为一个单独的模块实现。 HTTPS 模块与 HTTP 模块极为类似，区别在于 HTTPS 模块需要额外处理 SSL 证书。 1234567891011121314const https = require(\"https\");const fs = require(\"fs\");const options = &#123; key: fs.readFileSync(\"test/fixtures/keys/agent2-key.pem\"), cert: fs.readFileSync(\"test/fixtures/keys/agent2-cert.pem\")&#125;;https .createServer(options, (req, res) =&gt; &#123; res.writeHead(200); res.end(\"hello world\\n\"); &#125;) .listen(8000); URL处理 HTTP 请求时 url 模块使用率超高，因为该模块允许解析 URL、生成 URL，以及拼接 URL。 首先我们来看看一个完整的 URL 的各组成部分，输出如下： 1234567891011121314&gt; require('url').parse('http://user:pass@host.com:8080/p/a/t/h?query=string#hash');Url &#123; protocol: 'http:', slashes: true, auth: 'user:pass', host: 'host.com:8080', port: '8080', hostname: 'host.com', hash: '#hash', search: '?query=string', query: 'query=string', pathname: '/p/a/t/h', path: '/p/a/t/h?query=string', href: 'http://user:pass@host.com:8080/p/a/t/h?query=string#hash'&#125; 当然，不完整的 url，也可以解析： 123456789101112131415const http = require(\"http\");const url = require(\"url\");http .createServer((request, response) =&gt; &#123; let body = []; const tmp = request.url; // /foo/bar?a=b response.writeHead(200, &#123; \"Content-Type\": \"text/plain\" &#125;); console.log(\"url-parse\", url.parse(tmp)); response.end(\"Hello World\"); &#125;) .listen(8000); 1234567891011121314&#123; \"protocol\": null, \"slashes\": null, \"auth\": null, \"host\": null, \"port\": null, \"hostname\": null, \"hash\": null, \"search\": \"?a=b\", \"query\": \"a=b\", \"pathname\": \"/foo/bar\", \"path\": \"/foo/bar?a=b\", \"href\": \"/foo/bar?a=b\"&#125; format 方法允许将一个 URL 对象转换为 URL 字符串 12345678const urlFormat = url.format(&#123; protocol: \"http:\", host: \"www.example.com\", pathname: \"/p/a/t/h\", search: \"query=string\"&#125;);console.log(&#123; urlFormat &#125;); // &#123; urlFormat: 'http://www.example.com/p/a/t/h?query=string' &#125; Query Stringquerystring 模块用于实现 URL 参数字符串与参数对象的互相转换 12345querystring.parse(\"foo=bar&amp;baz=qux&amp;baz=quux&amp;corge\");// &#123; foo: 'bar', baz: [ 'qux', 'quux' ], corge: '' &#125;querystring.stringify(&#123; foo: \"bar\", baz: [\"qux\", \"quux\"], corge: \"\" &#125;);// 'foo=bar&amp;baz=qux&amp;baz=quux&amp;corge=' Zlibzlib 模块提供了数据压缩和解压的功能。当我们处理 HTTP 请求和响应时，可能需要用到这个模块。 Netnet 模块可用于创建 Socket 服务器或 Socket 客户端。 由于 Socket 在前端领域的使用范围还不是很广，这里先不涉及到 WebSocket 的介绍，仅仅简单演示一下如何从 Socket 层面来实现 HTTP 请求和响应。 问题解答使用 NodeJS 操作网络，特别是操作 HTTP 请求和响应时会遇到一些惊喜，这里对一些常见问题做解答。 为什么通过 headers 对象访问到的 HTTP 请求头或响应头字段不是驼峰的？ 从规范上讲，HTTP 请求头和响应头字段都应该是驼峰的。但现实是残酷的，不是每个 HTTP 服务端或客户端程序都严格遵循规范，所以 NodeJS 在处理从别的客户端或服务端收到的头字段时，都统一地转换为了小写字母格式，以便开发者能使用统一的方式来访问头字段，例如headers[&#39;content-length&#39;]。 为什么 http 模块创建的 HTTP 服务器返回的响应是 chunked 传输方式的？ 因为默认情况下，使用.writeHead方法写入响应头后，允许使用.write方法写入任意长度的响应体数据，并使用.end方法结束一个响应。由于响应体数据长度不确定，因此 NodeJS 自动在响应头里添加了Transfer-Encoding: chunked字段，并采用 chunked 传输方式。但是当响应体数据长度确定时，可使用.writeHead方法在响应头里加上Content-Length字段，这样做之后 NodeJS 就不会自动添加Transfer-Encoding字段和使用 chunked 传输方式。 为什么使用 http 模块发起 HTTP 客户端请求时，有时候会发生 socket hang up 错误？ 答： 发起客户端 HTTP 请求前需要先创建一个客户端。http 模块提供了一个全局客户端http.globalAgent，可以让我们使用.request或.get方法时不用手动创建客户端。但是全局客户端默认只允许 5 个并发 Socket 连接，当某一个时刻 HTTP 客户端请求创建过多，超过这个数字时，就会发生socket hang up错误。解决方法也很简单，通过http.globalAgent.maxSockets属性把这个数字改大些即可。另外，https 模块遇到这个问题时也一样通过https.globalAgent.maxSockets属性来处理。 学习资料 7-days-nodejs - 文章 《了不起的 Node.js：将 JavaScript 进行到底》- 书籍 《新时期的 Node.js 入门》- 书籍 Node.js 从零开发 Web Server 博客项目 前端晋升全栈工程师必备 - 视频 http（HTTP） - 官方文档","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://www.yangtao.site/categories/Nodejs/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://www.yangtao.site/tags/Nodejs/"}]},{"title":"Nodejs系列之TCP","slug":"node-tcp","date":"2019-06-12T11:37:08.000Z","updated":"2019-11-11T06:47:58.625Z","comments":true,"path":"2019/06/12/node-tcp/","link":"","permalink":"https://www.yangtao.site/2019/06/12/node-tcp/","excerpt":"定义传输控制协议（TCP）是一个面向连接的协议，保证了两台计算机之间数据传输的可靠性和顺序。 Node HTTP 服务器是构建于 Node TCP 服务器之上的。","text":"定义传输控制协议（TCP）是一个面向连接的协议，保证了两台计算机之间数据传输的可靠性和顺序。 Node HTTP 服务器是构建于 Node TCP 服务器之上的。 TCP 的特性： 面向连接的通信和保证顺序的传递 面向字节 - ASCII、Unicode 可靠性 流控制 拥堵控制 - Qos Socket 是对 TCP 协议的一种封装方式，Socket本身不是协议，而是一个编程接口。 telnet允许在终端手动建立一个TCP连接服务端使用 Node.js 写一个web服务器，并监听 3000 端口，然后 node app.js 运行下是否正确1234require('http').createServer(function(req, res) &#123; res.writeHead(200); res.end('Hello world');&#125;).listen(3000) TCP连接使用telnet 127.0.0.1 3000建立一个连接，然后输入GET / HTTP/1.1，回车两次，然后服务器端就出现了响应：1234567891011121314151617~ telnet 127.0.0.1 3000Trying 127.0.0.1...Connected to localhost.Escape character is '^]'.GET / HTTP/1.1HTTP/1.1 200 OKDate: Sun, 15 Sep 2019 06:20:43 GMTConnection: keep-aliveTransfer-Encoding: chunkedbHello world0Connection closed by foreign host. 总结： 成功建立了一个 TCP 连接 创建了一个HTTP请求 接收到一个HTTP响应 到达的数据和在Node.js中写的一样 基于TCP的聊天程序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253const net = require('net')let count = 0, users = &#123;&#125;const server = net.createServer(function(conn) &#123; let nickname; conn.setEncoding('utf8') conn.write( '\\n &gt; 欢迎访问 \\033[92mNode-Chat\\033[39m!' + '\\n &gt; ' + count + '个其他用户已连接' + '\\n &gt; 请输入你的用户名并回车：' ) count++ conn.on('data', function(data) &#123; data = data.replace('\\r\\n', '') console.log(data); if(!nickname) &#123; if(users[data]) &#123; conn.write('\\033[93m&gt; 昵称已被使用，请重试：\\033[39m '); return; &#125; else &#123; nickname = data users[nickname] = conn console.log('users: ', conn) broadcast('\\033[90m &gt; ' + nickname + ' 上线了\\033[39m\\n'); &#125; &#125; else &#123; broadcast('\\033[96m &gt; ' + nickname + ':\\033[39m ' + data + '\\n', true); &#125; &#125;) conn.on('close', function() &#123; count-- delete users[nickname] broadcast('\\033[90m &gt; ' + nickname + ' 下线了\\033[39m\\n'); &#125;) // 向每一个用户发送信息 function broadcast (msg, exceptMyself) &#123; for (let i in users) &#123; if(!exceptMyself || i != nickname) &#123; users[i].write(msg) &#125; &#125; &#125;&#125;)server.listen(3000, function() &#123; console.log('\\033[96m server listening on *: 3000\\033[39m')&#125;) 单独运行：telnet 127.0.0.1 3000，比如： 1234567891011121314151617181920212223242526272829~ telnet 127.0.0.1 3000Trying 127.0.0.1...Connected to localhost.Escape character is '^]'. &gt; 欢迎访问 Node-Chat! &gt; 0个其他用户已连接 &gt; 请输入你的用户名并回车：XiaoMing &gt; XiaoMing 上线了Hi &gt; HanMeimei 上线了 &gt; HanMeimei: Hello &gt; LiSi 上线了 &gt; LiSi: Ni hao ma?# 第二位用户 &gt; 欢迎访问 Node-Chat! &gt; 1个其他用户已连接 &gt; 请输入你的用户名并回车：HanMeimei &gt; HanMeimei 上线了Hello# 第三位用户 &gt; 欢迎访问 Node-Chat! &gt; 2个其他用户已连接 &gt; 请输入你的用户名并回车：LiSi &gt; LiSi 上线了Ni hao ma?","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://www.yangtao.site/categories/Nodejs/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://www.yangtao.site/tags/Nodejs/"}]},{"title":"Nodejs系列之Connect","slug":"node-connect","date":"2019-06-11T06:28:31.000Z","updated":"2019-11-11T06:41:52.056Z","comments":true,"path":"2019/06/11/node-connect/","link":"","permalink":"https://www.yangtao.site/2019/06/11/node-connect/","excerpt":"Connect 是一个基于 HTTP 服务器的工具集，成为中间件（middleware）。 中间件，其实就是一个简单的 JavaScript 函数。除了处理 req 和 res 对象之外，还接受一个 next 函数来做流控制。","text":"Connect 是一个基于 HTTP 服务器的工具集，成为中间件（middleware）。 中间件，其实就是一个简单的 JavaScript 函数。除了处理 req 和 res 对象之外，还接受一个 next 函数来做流控制。 一个简单的网站初始化： 1234567891011121314151617var http = require(\"http\");var connect = require(\"connect\");var serveStatic = require(\"serve-static\");var path = require(\"path\");var app = connect();app.use(serveStatic(path.join(__dirname, \"public-optimized\")));app.use(serveStatic(path.join(__dirname, \"public\")));// respond to all requestsapp.use(function(req, res) &#123; res.end(\"Hello from Connect!\\n\");&#125;);//create node.js http server and listen on porthttp.createServer(app).listen(3000); 中间件的使用，模拟登录登出： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687var http = require(\"http\");var connect = require(\"connect\");var morgan = require(\"morgan\");var bodyParser = require(\"body-parser\");var cookieParser = require(\"cookie-parser\");var session = require(\"express-session\");var users = require(\"./config/users.json\");var app = connect();// loggerapp.use(morgan(\"dev\"));// parse an HTML body into a stringapp.use(bodyParser());app.use(cookieParser());app.use( session(&#123; secret: \"my site secret\" &#125;));app.use(function(req, res, next) &#123; if (\"/\" == req.url &amp;&amp; req.session.logged_in) &#123; res.writeHead(200, &#123; \"Content-Type\": \"text/html\" &#125;); res.end( `Welcome back, &lt;b&gt;$&#123;req.session.name&#125;&lt;/b&gt;&lt;a href=\"/logout\"&gt;Logout&lt;/a&gt;` ); &#125; else &#123; next(); &#125;&#125;);app.use(function(req, res, next) &#123; if (\"/\" == req.url &amp;&amp; \"GET\" == req.method) &#123; res.writeHead(200, &#123; \"Content-Type\": \"text/html\" &#125;); res.end( [ '&lt;form method=\"POST\" action=\"/login\"&gt;', \"&lt;h1&gt;Login&lt;/h1&gt;\", \"&lt;fieldset&gt;\", \"&lt;label&gt;Please log in&lt;/label&gt;\", 'Username: &lt;input type=\"text\" name=\"user\" /&gt;&lt;br&gt;', 'Password: &lt;input type=\"password\" name=\"password\" /&gt;', \"&lt;p&gt;&lt;button&gt;Submit&lt;/button&gt;&lt;/p&gt;\", \"&lt;/fieldset&gt;\", \"&lt;/form&gt;\" ].join(\"\") ); &#125; else &#123; next(); &#125;&#125;);app.use(function(req, res, next) &#123; if (\"/login\" == req.url &amp;&amp; \"POST\" == req.method) &#123; res.writeHead(200, &#123; \"Content-Type\": \"text/html\" &#125;); if ( !users[req.body.user] || req.body.password != users[req.body.user].password ) &#123; res.end('Bad username/password&lt;br&gt;&lt;a href=\"/\"&gt;Back&lt;/a&gt;'); &#125; else &#123; req.session.logged_in = true; req.session.name = users[req.body.user].name; res.end(\"Success!\"); &#125; &#125; else &#123; next(); &#125;&#125;);app.use(function(req, res, next) &#123; if (\"/logout\" == req.url) &#123; req.session.logged_in = false; res.writeHead(200); res.end(\"Logged out!\"); &#125; else &#123; next(); &#125;&#125;);//create node.js http server and listen on porthttp.createServer(app).listen(3000);","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://www.yangtao.site/categories/Nodejs/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://www.yangtao.site/tags/Nodejs/"}]},{"title":"js设计模式学习之单例模式","slug":"mode-单例模式","date":"2019-05-03T13:24:26.000Z","updated":"2019-05-03T13:27:02.350Z","comments":true,"path":"2019/05/03/mode-单例模式/","link":"","permalink":"https://www.yangtao.site/2019/05/03/mode-单例模式/","excerpt":"保证一个类仅有一个实例，并提供一个访问它的全局访问点","text":"保证一个类仅有一个实例，并提供一个访问它的全局访问点 实现一个单例模式用一个变量标志当前是否已经为某个类型创建过对象，如果是，则下次直接返回之前创建的对象。 1234567891011121314151617181920var Singleton = function (name) &#123; this.name = name; this.instance = null;&#125;Singleton.prototype.getName = function () &#123; console.log(this.name);&#125;Singleton.getInstance = function (name) &#123; if (!this.instance) &#123; this.instance = new Singleton(name); &#125; return this.instance;&#125;var a = Singleton.getInstance('Tony1');var b = Singleton.getInstance('Tony2');console.log(a === b); // true 通过 Singleton.getInstance来获取 Singleton 类的唯一对象，里边使用了 new 来获取，导致了这个类的“不透明性”。 透明的单例模式创建一个“透明”的单例类，就是让我们从这个类中创建对象的时候可以和使用其他普通类一样：var aa = new CreateDiv(&#39;Sisi1&#39;); 1234567891011121314151617181920212223242526var CreateDiv = (function () &#123; var instance; var CreateDiv = function (html) &#123; if (instance) &#123; return instance; &#125; this.html = html; this.init(); return instance = this; &#125;; CreateDiv.prototype.init = function () &#123; var div = document.createElement('div'); div.innerHTML = this.html; document.body.appendChild(div); &#125;; return CreateDiv;&#125;)();var aa = new CreateDiv('Sisi1');var bb = new CreateDiv('Sisi2');console.log(aa === bb); // true 下面这段代码中，CreateDiv 的构造函数负责了两件事：创建对象和执行初始化 init 方法，及保证只有一个对象： 12345678var CreateDiv = function (html) &#123; if (instance) &#123; return instance; &#125; this.html = html; this.init(); return instance = this;&#125;; 但是，如果我们要创建很多的div，这里的 return instance = this; 就需要删掉。 用代理实现单例模式这时候，为了避免上面不能复用的尴尬，通过引入代理类的方式，把负责管理单例的逻辑移交至代理类ProxySingletonCreateDiv，这样CreateDiv只是一个普通的类。 12345678910111213141516171819202122232425var CreateDiv = function (html) &#123; this.html = html; this.init();&#125;;CreateDiv.prototype.init = function () &#123; var div = document.createElement('div'); div.innerHTML = this.html; document.body.appendChild(div);&#125;var ProxySingletonCreateDiv = (function () &#123; var instance; return function (html) &#123; if (!instance) &#123; instance = new CreateDiv(html); &#125; return instance; &#125;&#125;)();var aa = new ProxySingletonCreateDiv('Tony1');var bb = new ProxySingletonCreateDiv('Tony2');console.log(aa === bb); // true JavaScript 中的单例模式单例模式的核心是：确保只有一个实例，并提供全局访问。 使用命名空间 对象字面量的方式: 12345678910var namespace1 = &#123; a: function() &#123; console.log(1); &#125;, b: function() &#123; console.log(2); &#125;&#125;namespace1.a(); //1 把a和b都定义为 namespace1 的属性，减少了变量和全局作用域打交道的机会，还可以动态地创建命名空间： 1234567891011121314151617181920212223242526272829303132333435363738394041424344var MyApp = &#123;&#125;;MyApp.namespace = function (name) &#123; var parts = name.split('.'); var current = MyApp; for (var i in parts) &#123; if (!current[parts[i]]) &#123; current[parts[i]] = &#123;&#125;; &#125; current = current[parts[i]]; &#125;&#125;MyApp.namespace('event');MyApp.namespace('dom.style');console.log(MyApp);// 相当于：var MyApp = &#123; event: &#123;&#125;, dom: &#123; style: &#123;&#125; &#125;&#125;``` 2. 使用闭包封装私有变量使用下划线约定私有变量 _name 和 _age。```jsvar user = (function () &#123; var _name = 'Seven'; var _age = 27; return &#123; getUserInfo: function () &#123; return _name + '-' + _age; &#125; &#125;&#125;)();console.log(user.getUserInfo()) // Seven-27 惰性单例宗旨：在需要的时候才创建对象！！！ 栗子：QQ的登录浮窗 第一种方案：页面加载完成的时候便创建好浮窗。 1234567891011var loginLayer = (function () &#123; var div = document.createElement('div'); div.innerHTML = '我是一个小小的悬浮框'; div.style.display = 'none'; document.body.appendChild(div); return div;&#125;)();document.getElementById('loginBtn').addEventListener('click', function () &#123; loginLayer.style.display = 'block';&#125;); 但是，不管我们登录与否，都会创建悬浮窗，所以我们可以修改为：在点击登录的时候再创建悬浮窗。 123456789101112var createLoginLayer = function () &#123; var div = document.createElement('div'); div.innerHTML = '我是一个小小的悬浮框'; div.style.display = 'none'; document.body.appendChild(div); return div;&#125;;document.getElementById('loginBtn').addEventListener('click', function () &#123; var loginLayer = createLoginLayer(); loginLayer.style.display = 'block';&#125;); 这时候，虽然达到了惰性的目的，却失去了单例的效果，每次点击登录，都会创建一个新的悬浮窗。 所以我们需要一个变量来判断是否已经创建过悬浮窗： 1234567891011121314151617var createLoginLayer = (function () &#123; var div; return function () &#123; if (!div) &#123; // 判断是否已创建 div = document.createElement('div'); div.innerHTML = '我是一个小小的悬浮框'; div.style.display = 'none'; document.body.appendChild(div); &#125; return div; &#125;&#125;)();document.getElementById('loginBtn').addEventListener('click', function () &#123; var loginLayer = createLoginLayer(); loginLayer.style.display = 'block';&#125;); 通用的惰性单例虽然上面的悬浮框是一个可用的惰性单例，但是仍然违反了单一职责原则，如果我们要创建其他的标签，就需要把创建悬浮窗的函数复制一份，再修修改改，无法做到复用。 所以，我们需要把不变的部分隔离出来，进行抽象，无论创建什么标签，都是一样的逻辑： 1234var obj;if(!obj) &#123; obj = xxx;&#125; 接着，继续： 123456789101112131415161718192021var getSingle = function (fn) &#123; var result; return function () &#123; return result || (result = fn.apply(this, arguments)); &#125;&#125;var createLoginLayer = function () &#123; var div = document.createElement('div'); div.innerHTML = '我是一个小小的悬浮框'; div.style.display = 'none'; document.body.appendChild(div); return div;&#125;var createSingleLoginLayer = getSingle(createLoginLayer);document.getElementById('loginBtn').addEventListener('click', function () &#123; var loginLayer = createSingleLoginLayer(); loginLayer.style.display = 'block';&#125;); 这时，我们创建其他标签就只需要关系如何创建该标签就可以： 123456789101112var createIframe = function () &#123; var iframe = document.createElement('iframe'); iframe.src = 'https://baidu.com'; document.body.appendChild(iframe); return iframe;&#125;var createSingleIframe = getSingle(createIframe);document.getElementById('loginBtn2').addEventListener('click', function () &#123; createSingleIframe();&#125;); 小结单例模式是一种简单却非常常用的模式，特别是惰性单例技术，在合适的时候才创建对象，并且只创建唯一的一个。 创建对象 和 管理单例 的职责被分布在两个不同的方法中，两个方法组合起来才具有单例模式的威力。 学习资料： 《JavaScript 设计模式与开发实践》第 4 章 发布： 掘金《js设计模式学习之单例模式》","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/categories/JavaScript/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://www.yangtao.site/tags/设计模式/"}]},{"title":"jQuery插件写法小结之重写轮播图功能","slug":"plugin-slide-photo","date":"2019-05-03T13:19:29.000Z","updated":"2019-11-13T05:45:07.770Z","comments":true,"path":"2019/05/03/plugin-slide-photo/","link":"","permalink":"https://www.yangtao.site/2019/05/03/plugin-slide-photo/","excerpt":"最近在维护老网站的时候，发现一些jQuery库的使用有些臃肿，并且大部分自定义的js文件很容易污染全局变量，所以想着重写下，虽然jQuery的辉煌时代已经过去了，但是他的思想，依旧灿烂（滚去维护去）","text":"最近在维护老网站的时候，发现一些jQuery库的使用有些臃肿，并且大部分自定义的js文件很容易污染全局变量，所以想着重写下，虽然jQuery的辉煌时代已经过去了，但是他的思想，依旧灿烂（滚去维护去） 先举个栗子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566;(function($) &#123; var methods = &#123; init: function(options) &#123; // 可自定义扩展项 options = $.extend( true, &#123;&#125;, $.fn.myPlugin.defaults, options ); console.log('options', options, this) return this; &#125;, getName: function() &#123; console.log('Name is ', $.fn.myPlugin.defaults.name, '.') &#125;, getAge: function() &#123; console.log('Age is ', $.fn.myPlugin.defaults.age, '.') &#125;, show: function()&#123; return this.each(function()&#123; this.style.display == \"none\" &amp;&amp; (this.style.display = '') if (getComputedStyle(this, '').getPropertyValue(\"display\") == \"none\") this.style.display = defaultDisplay(this.nodeName) &#125;) &#125;, hide: function() &#123; return this.css(\"display\", \"none\") &#125; &#125;; // 命名空间最好只有一个 $.fn.myPlugin = function(method) &#123; // 方法调用，可满足三种情况：1. method, 2. init, 3. error if(methods[method]) &#123; return methods[method].apply(this, Array.prototype.slice.call(arguments, 1)); //将具有length属性的对象转成数组 &#125; else if(typeof method === 'object' || !method) &#123; // 如果没有参数或者参数 return methods.init.apply(this, arguments); &#125; else &#123; $.error('Method' + method + 'does not exist on jQuery.myPlugin.'); &#125; &#125; $.fn.myPlugin.defaults = &#123; 'name': 'zhangsan', 'age': '20' &#125;;&#125;)(jQuery)/* --- 测试 --- */// 初始化init$('#testPara').myPlugin()// 修改参数$('#testPara').myPlugin(&#123; 'name': 'wuwang', 'age': '27'&#125;)// 调取方法$('#testPara').myPlugin('hide')$('#testPara').myPlugin('show') 简单易懂，但是五脏俱全，接下来简单说明： 搞定复杂参数列表首先，我们一般传参如下： 123function foo(a1, a2, a3, a4) &#123; &#125;foo(1, 2, 3, 4) 那如果不传参呐？ 1foo(1, null, 3, 4) 就需要如上使用 null 来站位，参数多了，保证你晕。 所以，我们使用 可选哈希参数（options hash），如：12345foo(1, null, null, 4)// 改成foo(1, &#123; a4: 4&#125;) 接着，我们使用 jQuery 的 $.extend() 工具函数合并可选参数，并设置默认值：1234567function foo (a1, options) &#123; var settings = $.extend(&#123; a2: value2, a3: value3, a4: value4 &#125;, options || &#123;&#125; );&#125; 最后，就有了栗子中形态： 123456var settings = $.extend( true, // 是否为深拷贝 &#123;&#125;, // 使用源元素属性来扩展目标对象 $.fn.myPlugin.defaults, // 默认的一个对象，将属性添加到 target（即&#123;&#125;） 目标对象中 options // 多个源后会覆盖前面同名的属性); 这样，就再也不会纠结参数的不传或者多个占位传参，挺好。 实际操作下：先看一个多个参数的： 12345$('#btn').myPlugin(&#123; 'mynewname': 'lisi', 'mynewage': 22&#125;)// 打印settings： &#123;name: \"zhangsan\", age: \"20\", mynewname: \"lisi\", mynewage: 22&#125; 再看一个：123456$('#btn').myPlugin(&#123; 'name': 'lisi', 'mynewage': 22&#125;)// &#123;name: \"lisi\", age: \"20\", mynewage: 22&#125; 一看就懂，有则覆盖，无则添加，完美。 统一命名空间由于是jQuery插件，都挂载在 jQuery 对象下，所以恰当命名空间的插件尽可能不与其他插件冲突，甚至是 jQuery 的核心库方法。 比如：12345(function($) &#123; var defaults = &#123;&#125; // 定义默认项 var methods = &#123;&#125; // 定义方法 $.fn.myPlugin = function(method) &#123;&#125; // 定义 myPlugin 命名空间并赋值一个匿名函数&#125;(jQuery) 允许公开访问默认设置为了更加的定制化，我们需要暴露默认的设置，这样我们就可以修改设置了。 首先修改 defaults 变量，为了暴露给外部世界，需要把它赋值给 $.fn 属性。并且为了统一命名空间原则，需要把它作为 myPlugin 的属性，如：1234$.fn.myPlugin.defaults = &#123; 'name': 'zhangsan', 'age': '20'&#125;; 接着，当使用默认值来合并参数选项时，在项目中只出现一次，即在 init() 方法里，如：1234567891011var methods = &#123; init: function(options) &#123; // 可自定义扩展项 options = $.extend( true, &#123;&#125;, $.fn.myPlugin.defaults, options ); &#125;&#125; 这样，当我们在浏览器里直接测试：123456// 获取$.fn.myPlugin.defaults.name // zhangsan// 修改$.fn.myPlugin.defaults.name = 'wangwu'// \"wangwu\" 维护链式调用性使用 return this ，可以维护链式调用性。 Array.prototype.slice.call()Array.prototype.slice.call(arguments)能将具有length属性的对象转成数组 （arguments.toArray().slice()） 12var a=&#123;length:2,0:'first',1:'second'&#125;;Array.prototype.slice.call(a); //Array [ \"first\", \"second\" ] 再举个栗子项目中经常使用轮播图，我们就在前人的基础上，模仿一下吧（你就说是抄的不就行了麽）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111;(function ($) &#123; function showPhoto(options, index) &#123; var $photoElement = $(options.photoElement); if (!$photoElement.is(':animated')) &#123; $photoElement.animate(&#123; opacity: 0.5 &#125;, 0).attr( 'src', options.transformer(options.$thumbnails[index].src) ).animate(&#123; opacity: 1 &#125;, 800); options.current = index; &#125; &#125; var methods = &#123; init: function (options) &#123; options = $.extend( true, &#123;&#125;, $.fn.slidePhoto.defaults, options, &#123; current: 0, // 初始值为0 $thumbnails: this.filter('img'), //选出所有的图片 delay: options.delay &gt;= 1000 ? options.delay : 1000, &#125; ); // 点击图片，切换对应大图 options.$thumbnails.click(function () &#123; showPhoto(options, options.$thumbnails.index(this)); &#125;); // 显示下一张 $(options.nextControl + ', ' + options.photoElement).click(function () &#123; var index = (options.current + 1) % options.$thumbnails.length; // 取模 showPhoto(options, index); &#125;); // 显示上一张 $(options.previousControl).click(function () &#123; var index = options.current === 0 ? options.$thumbnails.length - 1 : options.current - 1; showPhoto(options, index); &#125;); // 显示第一张 $(options.firstControl).click(function () &#123; showPhoto(options, 0); &#125;).triggerHandler('click'); // 主要是初始时触发，触发被选元素上指定的事件，返回事件处理函数的返回值 // 显示最后一张 $(options.lastControl).click(function () &#123; showPhoto(options, options.$thumbnails.length - 1); &#125;) // 自动播放 var tick; function autoPlay() &#123; tick = window.setInterval( function () &#123; $(options.nextControl).triggerHandler('click') &#125;, options.delay); &#125; // 鼠标移入移出状态 function mouserStatus(obj) &#123; $(obj).mouseenter(function () &#123; if (tick) &#123; window.clearInterval(tick); &#125; &#125;).mouseleave(autoPlay); &#125; if (options.autoPlayControl) &#123; autoPlay(); &#125; // 鼠标滑动暂停、播放 mouserStatus(options.photoElement); mouserStatus(options.$thumbnails); return this; &#125; &#125;; $.fn.slidePhoto = function (method) &#123; if (methods[method]) &#123; return methods[method].apply(this, Array.prototype.slice.call(arguments, 1)); &#125; else if ($.type(method) === 'object') &#123; return methods.init.apply(this, arguments); &#125; else &#123; $.error('Method ' + method + ' does not exist on jQuery.slidePhoto'); &#125; &#125;; $.fn.slidePhoto.defaults = &#123; photoElement: 'img.photomatic-photo', // 大图显示 transformer: function (name) &#123; return name.replace('thumbnail', 'photo'); // 将'thumbnail' 替换为 'photo'，即最终返回大图的src属性值 &#125;, nextControl: null, // 下一张 previousControl: null, // 前一张 firstControl: null, // 第一张 lastControl: null, // 最后一张 autoPlayControl: false, delay: 3000 // 延时 &#125;;&#125;)(jQuery) 用法：123456789$('#thumbnails-pane img').slidePhoto(&#123; photoElement: '#photo-display', previousControl: '#previous-button', nextControl: '#next-button', firstControl: '#first-button', lastControl: '#last-button', autoPlayControl: true, delay: 3000 &#125;); 参考： 《jQuery实战 第三版》","categories":[{"name":"工具库","slug":"工具库","permalink":"https://www.yangtao.site/categories/工具库/"}],"tags":[{"name":"js插件","slug":"js插件","permalink":"https://www.yangtao.site/tags/js插件/"}]},{"title":"初探 this、call 和 apply","slug":"js-this-apply-call","date":"2019-05-03T13:16:03.000Z","updated":"2019-05-03T13:22:55.761Z","comments":true,"path":"2019/05/03/js-this-apply-call/","link":"","permalink":"https://www.yangtao.site/2019/05/03/js-this-apply-call/","excerpt":"this JavaScript 中 this 总是指向一个对象","text":"this JavaScript 中 this 总是指向一个对象 this 的指向 作为对象的方法调用 this 指向该对象，如： 123456789var obj = &#123; a: 1, getA: function() &#123; console.log(this === obj); // true console.log(this.a); // 1 &#125;&#125;;obj.getA(); 作为普通函数调用 当函数不作为对象的属性被调用时，普通函数的 this 总是指向全局对象，浏览器里就是 window 对象。 12345678910var name = \"globalName\";var obj = &#123; name: \"tyang\", getName: function() &#123; return this.name; &#125;&#125;;var getName = obj.getName;console.log(obj.getName()); // tyangconsole.log(getName()); // globalName obj.getName() 作为 obj 对象的属性被调用，this 指向 obj 对象; getName() 使用变量 getName 引用 obj.getName，此时是函数调用方式，this 指向全局 window; 在严格模式，情况有所不同：this 不会指向全局对象，而是 undefined： 123456function func() &#123; \"use strict\"; console.log(this); // undefined&#125;func(); 当函数作为某个对象的方法调用时，this 等于那个对象。不过，匿名函数的执行环境具有全局性，因此其 this 对象通常指向 window。 1234567891011121314var gName = \"The window\";var gObject = &#123; gName: \"My object\", getName: function() &#123; return function() &#123; // 返回一个匿名函数 return this.gName; &#125;; &#125;&#125;;console.log(gObject.getName()()); // 'The window'var getNameFunc = gObject.getName();console.log(getNameFunc()); // 'The window' 创建了一个全局对象 gName，这个对象包含一个方法 getName()， 这个方法返回一个匿名函数，这个匿名函数返回 this.name。因此调用 gObject.getName()() 会立即执行匿名函数，并返回一个字符串 &#39;The window&#39;。 为什么匿名函数没有取得包含作用域的 this 对象呢？ 每个函数再被调用的时候，会自动取得两个特殊变量：this 和 arguments，内部函数在搜索这两个变量时，只会搜索到其活动对象为止，因此永远不可能直接访问外部函数中的这两个变量。 所以，可以在外部作用域中设置一个变量来保存 this 对象： 123456789101112var gName = \"The window\";var gObject = &#123; gName: \"My object\", getName: function() &#123; var that = this; // 将 this 对象赋值给 that 变量 return function() &#123; return that.gName; // that 引用着 gObject &#125;; &#125;&#125;;console.log(gObject.getName()()); // 'My object' 当然，arguments 对象也可以如此使用：对该对象的引用保存到另一个闭包能够访问的变量中。 构造器调用 当使用 new 运算符调用函数时，该函数会返回一个对象，一般情况下，构造器里的 this 指向返回的这个对象，如： 12345var MyClass = function() &#123; this.name = \"Lisi\";&#125;;var nameObj = new MyClass();console.log(nameObj.name); // Lisi 但是，当显式返回一个 object 类型的对象时，那最终会返回这个对象，并不是之前的 this： 123456789var MyClass = function() &#123; this.name = \"Lisi\"; return &#123; // 如果这里不会烦 object 类型的数据，如：return 'wangwu'，就不会返回显式对象 name: \"wangwu\" &#125;;&#125;;var nameObj = new MyClass();console.log(nameObj.name); // wangwu Function.prototype.call 或 Function.prototype.apply 调用 call 和 apply 可以动态地改变传入函数的 this： 12345678var personObj = &#123; name: \"ytao\", age: \"22\"&#125;;function person() &#123; return this.name + this.age;&#125;console.log(person.call(personObj)); // ytao22 丢失的 this我们一般会重写这个获取 id 的方法： 12345var getId = function(id) &#123; return document.getElementById(id);&#125;;getId(\"divBox\"); 那可不可以这样呢： 12getId2 = document.getElementById;getId2(\"divBox\"); // Uncaught TypeError: Illegal invocation 结果直接报错，当 getElementById 方法作为 document 对象的属性被调用时， 方法内部的 this 是指向 document 的。如果 getId2(&#39;divBox&#39;)，相当于是普通函数调用，函数内部的 this 指向的是 window。 所以，按照这个思路，我们可以这样模拟一下它的实现： 12345678document.getElementById = (function(func) &#123; return function() &#123; return func.apply(document, arguments); &#125;;&#125;)(document.getElementById);getId3 = document.getElementById;getId3(\"divBox\"); call 和 apply fun.apply(thisArg, [argsArray]) fun.call(thisArg, arg1, arg2, …) 在函数式编程中，call 和 apply 方法尤为有用，两者用法一致，只是传参的形式上有所区别而已。 区别apply() 接受两个参数，第一个参数指定了函数体内 this 对象，第二个是数组或者类数组，apply() 方法将这个集合中的元素作为参数传递给被调用的函数。 call() 方法的作用和 apply() 方法类似，区别就是 call()方法接受的是参数列表，而 apply()方法接受的是一个参数数组。 Function​.prototype​.apply() Function​.prototype​.call() 第一个参数为 null，函数体内的 this 会指向默认的宿主对象，但是在严格模式下，依然是 null。 12345678910var applyFunc = function(a, b, c) &#123; console.log(this === window);&#125;;applyFunc.apply(null, [1, 2, 3]); // truevar applyFunc = function(a, b, c) &#123; \"use strict\"; console.log(this === null);&#125;;applyFunc.apply(null, [1, 2, 3]); // true 用途 改变 this 指向 假如在一个点击事件函数中有一个内部函数 func，当点击事件被触发时，就会出现如下情况： 1234567document.getElementById(\"divBox\").onclick = function() &#123; console.log(this.id); // divBox var func = function() &#123; console.log(this.id); // undefined，这里的 this 指向了 window &#125;; func();&#125;; 这时，我们用 call() 来改变一下： 1234567document.getElementById(\"divBox\").onclick = function() &#123; console.log(this.id); // divBox var func = function() &#123; console.log(this.id); // divBox &#125;; func.call(this);&#125;; 模拟 bind 方法 function.bind(thisArg[, arg1[, arg2[, …]]]) bind()方法创建一个新的函数，在调用时设置 this 关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项。 1234567891011121314151617Function.prototype.bind = function(context) &#123; var self = this; // 保存原函数 return function() &#123; // 返回新函数 return self.apply(context, arguments); // 将传入的 context 当做新函数体内的 this &#125;;&#125;;var bindObj = &#123; name: \"tyang\"&#125;;var bindFunc = function() &#123; console.log(this.name); // tyang&#125;.bind(bindObj);bindFunc(); 这是一个简化版的 Function.prototype.bind实现，self.apply(context, arguments)才是执行原来的 bindFunc 函数，并且指定 context 对象为 bindFunc 函数体内的 this。 我们再继续修改下，使之可以预先添加一些参数： 123456789101112131415161718192021Function.prototype.bind = function() &#123; var self = this, context = [].shift.call(arguments), // 获取参数中第一个为绑定的this上下文 args = [].slice.call(arguments); // 将剩余的参数转化为数组 // 返回新函数 return function() &#123; return self.apply(context, [].concat.call(args, [].slice.call(arguments))); //arguments 为新函数的参数，即传入的 3，4 &#125;;&#125;;var bindObj = &#123; name: \"lisisi\"&#125;;var bindFunc = function(a, b, c, d) &#123; console.log(this.name); // lisisi console.log([a, b, c, d]); // [1, 2, 3, 4]&#125;.bind(bindObj, 1, 2);bindFunc(3, 4); self.apply(context, [].concat.call(args, [].slice.call(arguments)));，执行新函数的时候，会把之前传入的 context 作为 this，[].slice.call(arguments)将新函数传入的参数转化为数组，并作为[].concat.call(args)的给定参数，组合两次，作为新函数最终的参数。 借用其他对象的方法 第一种，”借用构造函数“实现一些类似继承的效果： 1234567891011var A = function(name) &#123; this.name = name;&#125;;var B = function() &#123; A.apply(this, arguments);&#125;;B.prototype.getName = function() &#123; return this.name;&#125;;var bbb = new B(\"Yangtao\");console.log(bbb.getName()); //Yangtao 第二种，给类数组对象使用数组方法，比如： 1234(function() &#123; Array.prototype.push.call(arguments, 3); console.log(arguments); // [1, 2, 3]&#125;)(1, 2); 再比如之前用到的，把 arguments 转成真正的数组的时候可以借用 Array.prototype.slice.call(arguments)，想截去头一个元素时，借用Array.prototype.shift.call(arguments) 虽然我们可以把”任意“对象传入 Array.prototype.push: 1234var aObj = &#123;&#125;;Array.prototype.push.call(aObj, \"first\");console.log(aObj.length); // 1console.log(aObj[0]); // first 但是，这个对象也得满足以下两个条件： 对象本身要可以存取属性 对象的 length 属性可读写 如果是其他类型，比如 number，无法存取；比如函数，length 属性不可写，使用 call 或 apply 就会报错： 12345678var num = 1;Array.prototype.push.call(num, \"2\");console.log(num.length); // undefinedconsole.log(num[0]); // undefinedvar funcObj = function() &#123;&#125;;Array.prototype.push.call(funcObj, \"3\");console.log(funcObj.length); // Uncaught TypeError: Cannot assign to read only property 'length' of function 'function () &#123;&#125;' 学习资料： 《JavaScript 高程 3》第七章 《JavaScript 设计模式与开发实践 · 曾探》第 2 章 发布： 掘金《初探 this、call 和 apply》","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/tags/JavaScript/"}]},{"title":"初探 JavaScript 的变量","slug":"js-var","date":"2019-02-25T08:12:34.000Z","updated":"2019-02-27T11:04:59.199Z","comments":true,"path":"2019/02/25/js-var/","link":"","permalink":"https://www.yangtao.site/2019/02/25/js-var/","excerpt":"基本类型和引用类型的值","text":"基本类型和引用类型的值 ECMAScript变量一般有两种数据类型的值：基本类型和引用类型。 基本类型： 简单的数据段：Undefined, Null, Boolean, Number, String 引用类型：多个值构成的对象； 1. 动态的属性定义两者的值：创建一个变量并为其变量赋值； 执行两者的值： 引用类型：可以添加、删除属性和方法； 基本类型：不能添加、删除属性和方法； 比如：引用类型 a，可以添加属性 name age1234var a = new Object();a.name = \"杨子龙\";a.age = 24;console.log(a.name); //杨子龙 基本类型 name 无法添加属性 age123var name = \"杨子龙\";name.age = 24;console.log(name.age); //undefined 代码中可知：只能给引用类型值动态地添加属性，以便将来使用。 2. 赋值变量值从一个变量向另一个变量复制基本类型值和引用类型值时： 基本类型：在变量对象上创建一个新值，并将其值复制给新变量分配的位置上；（完全独立的两个变量）例如： 123var a = 111;var b = a;console.log(b); //111 代码中可知：变量b的值只是变量a的值的一个副本，两者的值111是完全独立的。 引用类型：将存储在变量对象中的值复制一份放到为新变量分配的空间中；（引用同一个对象的两个变量） 引用类型的值的副本实际是一个指针，指向存储在堆中的一个对象。例如：1234var obj1 = new Object;var obj2 = obj1;obj1.name = \"杨子龙\";console.log(obj2,name); // Object &#123; name=\"杨子龙\"&#125; 杨子龙 代码中可知：obj1和obj2都指向同一个对象Object；所以，为obj1添加的name属性，通过obj2也可以访问的到。 3. 传递参数我们都知道基本类型是按值访问的，因为可以访问保存在变量中的实际的值。所有函数的参数都是按值传递的。 基本类型：基本类型值的传递如同基本类型变量的复制一样；在向参数传递值，被传递的值会被复制给一个局部变量（命名参数），因此这个局部变量的变化不会反映在函数的外部。 例如： 12345678function fn(num) &#123; num += 10; return num;&#125;var a = 10;var result = fn(a);console.log(result); //20console.log(a); //10 代码中可知：参数num和变量a互不相识，只是有着相同的值而已，用完之后，你还是你，我还是我，互不干政。 引用类型：引用类型的传递如同引用类型变量的复制一样；在向参数传递值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。 例如：123456function fn(obj) &#123; obj.name = '杨子龙';&#125;var person = new Object();fn(person);console.log(person.name); //杨子龙 代码中可知：在这个函数内部，参数obj和变量person引用的是同一个对象Object，所以，你不动我也不动，你动我也动，你中有我，我中有你，情义绵绵，经久不息…… 也就是说：即使变量person是按值传递的，但是参数obj（想象成局部变量）还是会按引用来访问同一个对象。 访问变量有按值和按引用两种方式，参数只能按值传递。 4. 检测类型 基本类型：typeof 引用类型：instanceof（对象或null） 例如： 1234567891011121314151617var a = 'Yang Zilong';var b = 24;var c = '';var d = true;var e;var g = undefined;var f = null; // 比较特殊var h = new Object();console.log(typeof a); //stringconsole.log(typeof b); //number console.log(typeof c); //stringconsole.log(typeof d); //booleanconsole.log(typeof e); //undefinedconsole.log(typeof g); //undefinedconsole.log(typeof f); //objectconsole.log(typeof h); //object 所用引用类型的值都是Object的实例。 如下：12345678var person = new Object();var num = [1,2, 3];var pattern = /.at/i;console.log(person instanceof Object); //trueconsole.log(num instanceof Object); //trueconsole.log(num instanceof Array); //trueconsole.log(pattern instanceof Object); //trueconsole.log(pattern instanceof RegExp); //true 使用instanceof检测基本类型，会返回false，基本类型不是对象。 参考资料：《JavaScript高级程序设计》（第三版）第四章 同步于： 掘金、慕课网","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/tags/JavaScript/"}]},{"title":"初探JavaScript之Prototype","slug":"js-prototype","date":"2019-02-25T07:21:42.000Z","updated":"2019-05-03T13:17:45.798Z","comments":true,"path":"2019/02/25/js-prototype/","link":"","permalink":"https://www.yangtao.site/2019/02/25/js-prototype/","excerpt":"Array.prototype每一个函数，都有一个 prototype 属性，不管是你自定义的，还是函数内置的。 123var fn = function() &#123;&#125;console.log(fn.prototype) // &#123;constructor: ƒ&#125;console.log(fn.prototype.constructor === fn) // true","text":"Array.prototype每一个函数，都有一个 prototype 属性，不管是你自定义的，还是函数内置的。 123var fn = function() &#123;&#125;console.log(fn.prototype) // &#123;constructor: ƒ&#125;console.log(fn.prototype.constructor === fn) // true 这里的 fn.prototype 打印出一个对象，对象里的 constructor 属性又指回了该函数本身 fn。 即每个原型都有一个 consctructor 属性指向关联的构造函数，比如： 1Array === Array.prototype.constructor //true 我们接着看： 1console.log(Array.prototype) // [constructor: ƒ, concat: ƒ, copyWithin: ƒ, fill: ƒ, find: ƒ, …] 这里，除了 constructor 属性，还有其他内置的属性，即我们经常使用的操作数组的方法。 __proto__(隐式原型)所有通过函数 new （构造函数）出来的东西，都有一个 __proto__ 指向该函数的 prototype，比如： 123var arr = new Array()arr.__proto__ === Array.prototype // trueArray === Array.prototype.constructor //true 说白了，通过构造函数 new 出来的函数，该函数的__proto__属性指向构造函数的原型对象（即Array.prototype），所以，该函数与构造函数之间没有什么关联，是通过 原型对象 产生了联系，这也就是原型链继承的雏形吧。 举个关于继承 extends 的例子： 12345678910111213141516function Animal() &#123; this.eat = function() &#123; console.log('Animal eat') &#125;&#125;function Dog() &#123; this.bark = function() &#123; console.log('Dog bark') &#125;&#125;// 绑定原型，实现继承Dog.prototype = new Animal()var dog = new Dog()dog.eat() // Animal eatdog.bark() // Dog bark 上面看明白了，那么ES6的继承我们也就可以明白原理了，即 class Dog extends Animal 相当于 Dog.prototype = new Animal() 123456789101112131415161718192021class Animal &#123; constructor(name) &#123; this.name = name &#125; eat() &#123; console.log('Animal eat!' + this.name) &#125;&#125;class Dog extends Animal &#123; constructor(name) &#123; super(name) this.name = name &#125; bark() &#123; console.log('Dog bark!' + this.name) &#125;&#125;const dog = new Dog('哈士奇')dog.eat()dog.bark() 接下来，我们就清楚为什么能这样： 当我们要使用一个对象（数组）的某个功能时，如果该对象本身具有这个功能，直接调用，没有的话，那就去自身的__proto__属性中去找 12345678910var obj = &#123; myfn: function() &#123; console.log('myfn') &#125;&#125;obj.myfn() // 'myfn'obj.hasOwnProperty('myfn') //trueobj.toString() // \"[object Object]\"obj.hasOwnProperty('toString') // falseobj.__proto__.hasOwnProperty('toString') // true hasOwnProperty()就可以得出这个属性是否是属于该对象本身的属性: myfn 是我们自定义的，obj.hasOwnProperty(&#39;myfn&#39;)为 true toString() 我们不是自定义的，却可以使用，查一下是否属于自定义属性，obj.hasOwnProperty(&#39;toString&#39;)，答案为false 既然不属于自定义属性，那就去自身的__proto__去找，然后去原型对象上查一下，obj.__proto__.hasOwnProperty(&#39;toString&#39;)，哦，原来在这儿 在源码中，我们经常看到Array.prototype.concat，其实就是我们使用的[].concat，[]，因为[].__proto__ === Array.prototype __proto__是可修改的比如，我们新增一个addClass()方法：123456var arr = [1,2,3];arr.__proto__.addClass = function () &#123; console.log(123);&#125;arr.push(4);arr.addClass(); // 123 但是，这里要注意，如下重写之后，就没有了诸如 push、concat等方法： 123456arr.__proto__ = &#123; addClass: function () &#123; console.log(123); &#125;&#125;;arr.push(3) //Uncaught TypeError: arr.push is not a function Object.prototype的原型万物皆对象，到最后依旧是对象，最后这个东东是个啥，我们来看一下：123456789101112131415161718// 构造函数 Personfunction Person() &#123;&#125;// 实例对象 myfn，它的 隐式原型 指向了其构造函数的 原型对象var myfn = new Person()myfn.__proto__ === Person.prototype //true// 那构造函数 Person 的 隐式原型又指向了谁呢Person.prototype.__proto__ === Object.prototype //true// Function呐Function.prototype.__proto__ === Object.prototype //true// 这个呢var fn = function() &#123;&#125;fn.prototype.__proto__ === Object.prototype //trueObject.prototype.__proto__ === null //truetypeof null //\"object\" 总结： 所有的函数都有一个 prototype属性，该属性指向了一个对象，该对象就是调用该构造函数而创建出来的实例（如myfn）的原型（如myfn.__proto__）,即：myfn.__proto__ === Person.prototype 所有的对象（除null）都具有一个__proto__属性，该属性指向该对象的原型，比如：myfn.__proto__ === Person.prototype 原型也是一个对象，根据上条，那原型的原型，就是Object.prototype 最后的null对象，可以当做是 什么都没有 盗一张图，我们就更加清楚了（蓝色这条表示的是原型链） PS: 关于原型对象这一块本来就很绕，自己看懂了不一定就真的懂了，自己梳理的时候还是漏洞百出，而且还乱，就算现在我梳理了一遍，过些日子，我要是不再继续翻阅，应该又讲不通了，下面的资料很详细，在我学习的过程中提供了很大的帮助，在此感谢作者们！ 参考资料： js原型链基础 JavaScript深入之从原型到原型链 深入理解javascript原型和闭包（3）——prototype原型 同步于 掘金 、QDfuns","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/tags/JavaScript/"}]},{"title":"Debounce 和 Throttle","slug":"debounce-throttle","date":"2019-02-24T15:49:33.000Z","updated":"2019-02-24T15:56:22.845Z","comments":true,"path":"2019/02/24/debounce-throttle/","link":"","permalink":"https://www.yangtao.site/2019/02/24/debounce-throttle/","excerpt":"原文地址：Debounce 和 Throttle 的原理及实现","text":"原文地址：Debounce 和 Throttle 的原理及实现 防抖和节流防抖如输入框时，只在最后提交的时候校验，即：将多次高频率操作优化为只在最后一次执行 思路：每次触发事件时，清除之前的定时器方法 1234567891011121314151617181920212223function debounce(fn, wait, immediate) &#123; let timer = null; console.log('in'); return function() &#123; let context = this; let args = arguments; if(immediate &amp;&amp; !timer) &#123; fn.apply(context, args) &#125; if(timer) clearTimeout(timer) timer = setTimeout(() =&gt; &#123; console.log('timer') fn.apply(context, args) &#125;, wait); &#125;&#125;function test() &#123; console.log('被触发了');&#125;document.getElementById('btn').onfocus = debounce(test, 1000) 节流降低频率，每隔一段时间后执行一次，将高频率操作优化为低频率操作，如滚动条事件，resize事件 思路：每次触发事件时都判断当前是否有等待执行的延时函数12345678910111213141516171819202122function throtte(fn, wait, immediate) &#123; let timer = null let callNow = immediate return function() &#123; let args = arguments let context = this if(callNow) &#123; fn.apply(context, args) callNow = false &#125; if(!timer) &#123; timer = setTimeout(() =&gt; &#123; fn.apply(context, args) timer = null &#125;, wait); &#125; &#125;&#125;window.addEventListener('resize', throtte(test, 1000))","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/tags/JavaScript/"}]},{"title":"初探Class、继承、Promise 及 ES6 常用功能","slug":"es6-class","date":"2019-02-24T15:36:51.000Z","updated":"2019-03-13T14:01:13.870Z","comments":true,"path":"2019/02/24/es6-class/","link":"","permalink":"https://www.yangtao.site/2019/02/24/es6-class/","excerpt":"Class - 语法糖 Class 在语法上更贴合面向对象的写法 Class 实现继承更加易读、易理解 更易于写 java 等后端语言的使用 本质还是语法糖，使用 prototype","text":"Class - 语法糖 Class 在语法上更贴合面向对象的写法 Class 实现继承更加易读、易理解 更易于写 java 等后端语言的使用 本质还是语法糖，使用 prototype ES5中的写法获取实例对象的原型对象Object.getPrototypeOf(m2) 判断实例与构造函数的原型对象是否有关系MathHandle2.prototype.isPrototypeOf(m2)12345678910111213141516function MathHandle2(x, y) &#123; this.x = x this.y = y&#125;MathHandle2.prototype.add = function () &#123; return this.x + this.y&#125;var m2 = new MathHandle2(1,3)console.log(m2.add())console.log(m2.__proto__ === MathHandle2.prototype) //true// 获取实例对象的原型对象Object.getPrototypeOf()console.log(Object.getPrototypeOf(m2) === MathHandle2.prototype) //true// 判断实例与构造函数的原型对象是否有关系isPrototypeOf()console.log(MathHandle2.prototype.isPrototypeOf(m2)) //true ES6中的写法对象实例的隐式原型（属性）指向构造函数的原型对象m.__proto__ === MathHandle.prototype 构造函数的原型对象的constructor属性指回了构造函数本身MathHandle.prototype.constructor === MathHandle12345678910111213141516171819class MathHandle &#123; // 构造函数 constructor(x, y) &#123; this.x = x this.y = y &#125; add() &#123; return this.x + this.y &#125;&#125;const m = new MathHandle(1, 3)console.log(m.add()) //4// 对象实例的隐式原型（属性）指向构造函数的原型对象console.log(m.__proto__ === MathHandle.prototype) //true// 构造函数的原型对象的constructor属性指回了构造函数本身console.log(MathHandle.prototype.constructor === MathHandle) //true 继承prototype123456789101112131415function Animal() &#123; this.eat = function() &#123; console.log('Animal eat') &#125;&#125;function Dog() &#123; this.bark = function() &#123; console.log('Dog bark') &#125;&#125;// 绑定原型，实现继承Dog.prototype = new Animal()var hashiqi = new Dog()hashiqi.eat() // Animal eathashiqi.bark() // Dog bark extends123456789101112131415161718192021class Animal &#123; constructor(name) &#123; this.name = name &#125; eat() &#123; console.log('Animal eat!' + this.name) &#125;&#125;class Dog extends Animal &#123; constructor(name) &#123; super(name) this.name = name &#125; bark() &#123; console.log('Dog bark!' + this.name) &#125;&#125;const hashiqi = new Dog('哈士奇')hashiqi.eat()hashiqi.bark() Promise new Promise 实例，而且要 return new Promise 时要传入函数，函数有 resolve、reject 两个函数 成功时执行 resolve()，失败时执行 reject() then 监听结果 12345678910111213141516171819202122232425262728293031323334353637383940function loadImg(src) &#123; var promise = new Promise(function(resolve, reject) &#123; var img = document.createElement('img') img.onload = function() &#123; resolve(img) &#125; img.onerror = function() &#123; reject() &#125; img.src = src &#125;) return promise&#125; var src1 = 'https://img3.mukewang.com/5c611772085966af06000338-240-135.jpg' var src2 = 'https://img2.mukewang.com/5c6b7cff08d6895906000338-240-135.jpg' var result1 = loadImg(src1) var result2 = loadImg(src2) result1.then(function(img) &#123; console.log('第一张图片', img.src) return result2 //串联操作 &#125;).then(function(img) &#123; console.log('第二张图片', img.src) &#125;).catch(function(ex) &#123; // 统一捕获错误信息 console.log(ex) &#125;) // Promise.all 接受一个 promise 对象的数组，待全部完成之后，统一执行 success var result3 = loadImg(src1) var result4 = loadImg(src2) Promise.all([result3, result4]).then(function(data) &#123; console.log(data) &#125;) // Promise.race 接受一个包含多个 promise 对象的数组，只要有一个完成，就执行 success Promise.race([result3,result4]).then(function(data) &#123; console.log('race:', data) &#125;) ES6常用功能 let const 多行字符串、模板变量 解构赋值 块级作用域 函数默认参数 箭头函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293// let constlet i = 10;i = 20; // Uncaught SyntaxError: Identifier 'i' has already been declaredconst j = 100j = 20 // Uncaught TypeError: Assignment to constant variable.// 多行字符串、模板变量const name = 'yangtao', age = 27;const html = ` &lt;div&gt; &lt;p&gt;$&#123;name&#125;&lt;/p&gt; &lt;p&gt;$&#123;age&#125;&lt;/p&gt; &lt;/div&gt;`;// 结构赋值const obj = &#123;a: 100, b: 200&#125;const &#123;a, b&#125; = obj// 等同于（对象按照属性）var obj = &#123;a: 100, b: 200&#125;var a = obj.a, b = obj.b;const arr = ['xxx', 'yyy', 'zzz']const [x, z] = arr// 等同于(数组按照索引)var arr = ['xxx', 'yyy', 'zzz']var x = arr[0], z = arr[1];// 块级作用域const myObj = &#123;a: 1, b: 2&#125;for(let item in obj) &#123; console.log(item)&#125;console.log(item)// 等同于var myObj = &#123; a: 1, b: 2 &#125;;for (var _item in obj) &#123; console.log(_item);&#125;console.log(item);// 函数参数function num(a,b=0) &#123;&#125;// 等同于function num2(a) &#123; var b = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : 0;&#125;// 箭头函数const myarr = [1,3,4]myarr.map(item =&gt; item + 1)myarr.map((item, index) =&gt; console.log(item, index))// 等同于var myarr = [1, 3, 4];myarr.map(function (item) &#123; return item + 1;&#125;);myarr.map(function (item, index) &#123; return console.log(item, index);&#125;);// this指向很诡异function fn() &#123; console.log('real', this) // real &#123;a: 10&#125; var arr = [1,2,3]; arr.map(function(item) &#123; console.log(this) // window &#125;)&#125;fn.call(&#123;a: 10&#125;)// 使用箭头函数修改function fn() &#123; console.log('real', this) // real &#123;a: 10&#125; var arr = [1,2,3]; arr.map(item =&gt; console.log(this)) // &#123;a: 10&#125;&#125;fn.call(&#123;a: 10&#125;)// 等同于function fn() &#123; var _this = this; console.log('real', this); // real &#123;a: 10&#125; var arr = [1, 2, 3]; arr.map(function (item) &#123; return console.log(_this); &#125;); // &#123;a: 10&#125;&#125;fn.call(&#123; a: 10 &#125;); 关于 JS 众多模块化标准 没有模块化 AMD成为标准，require.js(也有CMD) 前端打包工具，是node.js模块化可以被使用 ES6出现，想统一现在所有模块化标准 nodejs积极支持，浏览器尚未统一 模块化 语法：import export(注意有无default) 环境：babel编译 ES6 语法，模块化可用 webpack 和 rollup 扩展：对模块化标准统一的期待 Rollup rollup 功能单一，webpack 功能强大 参考设计原则和《Linux/Unix设计思想》 工具要尽量功能单一，可集成，可扩展 gulp + rollup","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/categories/JavaScript/"}],"tags":[{"name":"es6","slug":"es6","permalink":"https://www.yangtao.site/tags/es6/"}]},{"title":"说一说常见的请求头和相应头都有什么呢","slug":"header-response","date":"2019-02-20T11:51:25.000Z","updated":"2019-03-13T14:02:19.596Z","comments":true,"path":"2019/02/20/header-response/","link":"","permalink":"https://www.yangtao.site/2019/02/20/header-response/","excerpt":"1.请求(客户端-&gt;服务端[request])","text":"1.请求(客户端-&gt;服务端[request]) GET(请求的方式) /newcoder/hello.html(请求的目标资源) HTTP/1.1(请求采用的协议和版本号) Accept: */*(客户端能接收的资源类型) Accept-Language: en-us(客户端接收的语言类型) Connection: Keep-Alive(维护客户端和服务端的连接关系) Host: localhost:8080(连接的目标主机和端口号) Referer: http://localhost/links.asp(告诉服务器我来自于哪里) User-Agent: Mozilla/4.0(客户端版本号的名字) Accept-Encoding: gzip, deflate(客户端能接收的压缩数据的类型) If-Modified-Since: Tue, 11 Jul 2000 18:23:51 GMT(缓存时间) Cookie(客户端暂存服务端的信息) Date: Tue, 11 Jul 2000 18:23:51 GMT(客户端请求服务端的时间) 2.响应(服务端-&gt;客户端[response]) HTTP/1.1(响应采用的协议和版本号) 200(状态码) OK(描述信息) Location: http://www.baidu.com(服务端需要客户端访问的页面路径) Server:apache tomcat(服务端的Web服务端名) Content-Encoding: gzip(服务端能够发送压缩编码类型) Content-Length: 80(服务端发送的压缩数据的长度) Content-Language: zh-cn(服务端发送的语言类型) Content-Type: text/html; charset=GB2312(服务端发送的类型及采用的编码方式) Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT(服务端对该资源最后修改的时间) Refresh: 1;url=http://www.it315.org(服务端要求客户端1秒钟后，刷新，然后访问指定的页面路径) Content-Disposition: attachment; filename=aaa.zip(服务端要求客户端以下载文件的方式打开该文件) Transfer-Encoding: chunked(分块传递数据到客户端） Set-Cookie:SS=Q0=5Lb_nQ; path=/search(服务端发送到客户端的暂存数据) Expires: -1//3种(服务端禁止客户端缓存页面数据) Cache-Control: no-cache(服务端禁止客户端缓存页面数据) Pragma: no-cache(服务端禁止客户端缓存页面数据) Connection: close(1.0)/(1.1)Keep-Alive(维护客户端和服务端的连接关系) Date: Tue, 11 Jul 2000 18:23:51 GMT(服务端响应客户端的时间) 在服务器响应客户端的时候，带上Access-Control-Allow-Origin头信息，解决跨域的一种方法。 原文地址：传送门","categories":[{"name":"网络知识","slug":"网络知识","permalink":"https://www.yangtao.site/categories/网络知识/"}],"tags":[{"name":"http","slug":"http","permalink":"https://www.yangtao.site/tags/http/"}]},{"title":"关于闭包的一道面试题","slug":"js-closure","date":"2019-02-19T09:57:37.000Z","updated":"2019-11-13T05:45:15.478Z","comments":true,"path":"2019/02/19/js-closure/","link":"","permalink":"https://www.yangtao.site/2019/02/19/js-closure/","excerpt":"原文地址：依次点击 4 个 li 标签，哪一个选项是正确的运行结果","text":"原文地址：依次点击 4 个 li 标签，哪一个选项是正确的运行结果 题目现有如下 html 结构： 123456&lt;ul&gt; &lt;li&gt;click me&lt;/li&gt; &lt;li&gt;click me&lt;/li&gt; &lt;li&gt;click me&lt;/li&gt; &lt;li&gt;click me&lt;/li&gt;&lt;/ul&gt; 依次点击 4 个 li 标签，运行结果是什么 1234567var elements = document.getElementsByTagName(\"li\");var length = elements.length;for (var i = 0; i &lt; length; i++) &#123; elements[i].onclick = function() &#123; alert(i); &#125;;&#125; 回答（依次弹出 4，4，4，4）以下是我当时在牛客网回答时从《JavaScript 高级程序设计》书中抄的： 这是由于作用域链的这种配置机制引出的一个副作用，即闭包只能取得包含函数中任何变量的最后一个值。闭包所保存的是整个变量对象，而不是某个特殊的变量。 这里的闭包函数elements[i].onclick=function(){alert(i);}的作用域链中保存着闭包的活动对象（这里为空）和全局变量对象（主要是 i）,所以，它们引用的是同一个变量 i；当点击完成后，变量 i=4,也就是每个内部函数 i 的值都是 4； 可以通过创建另一个匿名函数强制让闭包的行为符合预期： 1234567891011window.onload = function() &#123; var elements = document.getElementsByTagName(\"li\"); var length = elements.length; for (var i = 0; i &lt; length; i++) &#123; elements[i].onclick = (function(num) &#123; return function() &#123; alert(num); &#125;; &#125;)(i); &#125;&#125;; 在调用匿名函数时，我们传入变量 i，由于参数是按值传递的，所以就会将变量 i 的当前值复制给参数 num。而这个匿名函数内部，又创建并 alert 了一个访问 num 的闭包。这样，每一次点击都有 num 变量的一个副本，因此可以返回各自不同的数值。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/tags/JavaScript/"}]},{"title":"Express、Koa 初始化","slug":"node-express","date":"2019-02-16T16:36:20.000Z","updated":"2019-11-27T13:23:25.735Z","comments":true,"path":"2019/02/17/node-express/","link":"","permalink":"https://www.yangtao.site/2019/02/17/node-express/","excerpt":"对比一下 express 和 koa 的入口文件","text":"对比一下 express 和 koa 的入口文件 express 初始化12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849var createError = require(\"http-errors\");var express = require(\"express\");var path = require(\"path\");var cookieParser = require(\"cookie-parser\");var logger = require(\"morgan\");// 加载路由控制var indexRouter = require(\"./routes/index\");var usersRouter = require(\"./routes/users\");// 创建实例var app = express();// 创建 ejs 模板引擎即模板文件位置app.set(\"views\", path.join(__dirname, \"views\"));app.set(\"view engine\", \"ejs\");// 定义日志和输出级别app.use(logger(\"dev\"));// JSON 解析中间件app.use(express.json());// application/x-www-form-urlencode请求解析中间件app.use(express.urlencoded(&#123; extended: false &#125;));// 定义cookie解析器app.use(cookieParser());// HTTP 伪造中间件app.use(express.methodOverride());// 定义静态文件目录app.use(express.static(path.join(__dirname, \"public\")));// 匹配路径和路由app.use(\"/\", indexRouter);// 404 错误处理app.use(function(req, res, next) &#123; next(createError(404));&#125;);// 500 错误处理及错误堆栈跟踪app.use(function(err, req, res, next) &#123; // set locals, only providing error in development res.locals.message = err.message; res.locals.error = req.app.get(\"env\") === \"development\" ? err : &#123;&#125;; // render the error page res.status(err.status || 500); res.render(\"error\");&#125;);module.exports = app; Koa 初始化123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const Koa = require(\"koa\");const app = new Koa();const views = require(\"koa-views\");const json = require(\"koa-json\");const onerror = require(\"koa-onerror\");const bodyparser = require(\"koa-bodyparser\");const logger = require(\"koa-logger\");const index = require(\"./routes/index\");const users = require(\"./routes/users\");const ENV = app.env;// error handleronerror(app);// middlewaresapp.use( bodyparser(&#123; enableTypes: [\"json\", \"form\", \"text\"] &#125;));app.use(json());app.use(logger(\"dev\"));app.use(require(\"koa-static\")(__dirname + \"/public\"));app.use( views(__dirname + \"/views\", &#123; extension: \"pug\" &#125;));// loggerapp.use(async (ctx, next) =&gt; &#123; const start = new Date(); await next(); const ms = new Date() - start; console.log(`$&#123;ctx.method&#125; $&#123;ctx.url&#125; - $&#123;ms&#125;ms`);&#125;);// routesapp.use(index.routes(), index.allowedMethods());// app.use(users.routes(), users.allowedMethods())app.use(user.routes(), index.allowedMethods());app.use(blog.routes(), index.allowedMethods());// error-handlingapp.on(\"error\", (err, ctx) =&gt; &#123; console.error(\"server error\", err, ctx);&#125;);module.exports = app; 实例目录 网站初始化，实现 GET 和 POST 的 Ajax 请求 登录模块 上传图片模块 原文地址：Node.js+Express+MongoDB 建站实例","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://www.yangtao.site/categories/Nodejs/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://www.yangtao.site/tags/Nodejs/"}]},{"title":"Vue经典实例 ToDoList","slug":"vue-todolist","date":"2019-02-16T16:25:43.000Z","updated":"2019-03-13T14:06:15.971Z","comments":true,"path":"2019/02/17/vue-todolist/","link":"","permalink":"https://www.yangtao.site/2019/02/17/vue-todolist/","excerpt":"使用webpack构建一个vue的简易开发环境并添加一个Todo demo ToDoList传送门：Demo &amp;&amp; Github","text":"使用webpack构建一个vue的简易开发环境并添加一个Todo demo ToDoList传送门：Demo &amp;&amp; Github 下载：1git clone https://github.com/yangtao2o/todo.git 下载依赖：1npm install 本地运行：1npm run dev 访问地址：http://localhost:8000 生产运行：1npm run build","categories":[{"name":"前端框架","slug":"前端框架","permalink":"https://www.yangtao.site/categories/前端框架/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.yangtao.site/tags/vue/"}]},{"title":"《Vue.js实战》之前端路由与vue-router","slug":"vue-router","date":"2019-02-04T03:23:17.000Z","updated":"2019-03-13T14:06:11.395Z","comments":true,"path":"2019/02/04/vue-router/","link":"","permalink":"https://www.yangtao.site/2019/02/04/vue-router/","excerpt":"前端路由与 vue-router","text":"前端路由与 vue-router 什么是前端路由 每次 GET 或者 POST 请求在服务端有一个专门的正则配置列表，然后匹配到具体的一条路径后，分发到不同的 Controller，进行各种操作，最终将 html 或数据返回给前端，这就完成了一次 IO。 前端路由的实现\b有两种： URL的hash，即锚点（#），js 通过 hashChange 事件监听 url 的变化 HTML5 的 History 模式 优点： 页面持久性，如音乐网站 前后端彻底分离，如 Angular 的 ngRouter，\bReact 的 ReactRouter，还有 Vue 的 vue-router 需要考虑的问题： 页面的拔插性 页面的生命周期 内存管理等 vue-router 基本用法1234567# 新建目录 router# 安装 vue-routernpm i -S vue-router# index.js添加import VueRouter from 'vue-router';Vue.use(VueRouter); 在目录 \brouter 新建 views 目录，接着新建 about.vue、 index.vue、 user.vue等 123456789101112131415161718192021222324252627282930// index.jsconst Routers = [ &#123; path: '/index', component: (resolve) =&gt; require(['../router/views/index.vue'], resolve) &#125;, &#123; path: '/about', component: (resolve) =&gt; require(['../router/views/about.vue'], resolve) &#125;, &#123; path: '*', redirect: '../index' // 404指向首页 &#125;];const RouterConfig = &#123; // 使用HTML5的history路由模式 mode: 'history', routes: Routers&#125;const router = new VueRouter(RouterConfig);document.body.appendChild(root);new Vue(&#123; router: router, render: h =&gt; h(App)&#125;).$mount(root); 路由模式通过HTML5的History路由模式，通过 ‘/’设置路径。修改package.json:123\"scripts\": &#123; \"dev\": \"webpack-dev-server --config webpack.config.js --mode=development --history-api-fallback\"&#125;, 增加了 --history-api-fallback，所有的路由都指向index.html。 然后在根实例App.vue中添加&lt;router-view&gt;&lt;/router-view&gt; 跳转vue-router 有两种跳转页面的方式： &lt;router-link&gt;组件，会渲染成\b &lt;a&gt; 标签，如：&lt;router-link to=&quot;/about&quot;&gt;跳转到 about&lt;/router-link&gt; tag : tag=&quot;li&quot; 标签会被渲染成指定的 &lt;li&gt; replace : 无历史记录 active-class 使用router实例： $router 方法，如：this.$router.push(&#39;/index&#39;); replace : this.$router.replace(&#39;/index&#39;); go : this.$router.go(-1);高级用法 问题：如何在SPA项目中，修改网页的标题？ 一般我们是通过window.document.title = &#39;标题&#39;来修改，但是在什么时候修改，这是个问题。 vue-router 提供了导航钩子 beforeEach() 和 afterEach()，它们会在路由即将改变前和改变后触发。 这样就解决了页面众多，维护麻烦的问题。（mounted钩子） 123456789101112131415router.beforeEach((to, from, next) =&gt; &#123; // 从路由对象 to 里获取 meta 信息 window.document.title = to.meta.title; // 判断页面是否登录 if(window.localStorage.getItem('token')) &#123; next(); &#125; else &#123; next('/login'); &#125;&#125;);router.afterEach((to, from, next) =&gt; &#123; // 页面跳转回来滚动条默认\b在顶端 window.scroll(0, 0);&#125;) 状态管理与 Vuex状态管理与使用场景组件的基本运行模式：一个组件分为数据和视图，数据更新时，视图也跟着更新…视图中又可以绑定一些事件，它们触发methods里指定的方法，从而可以改变数据、更新视图。 如果需要跨组件共享数据的需求，那就需要借助 Vuex 来管理组件状态。 Vuex 基本用法1npm i -S vuex 高级用法实战：中央事件总线插件 vue-bus(loading…) 练习地址","categories":[{"name":"前端框架","slug":"前端框架","permalink":"https://www.yangtao.site/categories/前端框架/"}],"tags":[{"name":"vue-router","slug":"vue-router","permalink":"https://www.yangtao.site/tags/vue-router/"}]},{"title":"《Vue.js实战》之使用webpack","slug":"vue-webpack","date":"2019-02-04T03:22:59.000Z","updated":"2019-03-13T14:00:11.210Z","comments":true,"path":"2019/02/04/vue-webpack/","link":"","permalink":"https://www.yangtao.site/2019/02/04/vue-webpack/","excerpt":"使用 webpack","text":"使用 webpack 前端工程化与webpack前端工程化主要解决的问题： JavaScript、css 代码的合并与压缩 CSS 预处理：Less、Sass、Stylus 的编译 生成雪碧图 ES6 -&gt; ES5 模块化等 webpack 的主要使用场景是单页面富应用（SPA），将一些诸如：typescript、less、jpg、vue等格式的文件通过特定的加载器（Loader）编译后，最终统一生成 .js、.css、.png等静态资源文件。 如何文件都可称为是一个模块。webpack就是处理模块间的依赖关系，并把他们进行打包。 webpack 基础配置安装 webpack 与 webpack-dev-server初始化12npm init # 按照提示一步步往下走 本地局部安装 webpack:（书中是v2，我的\b需要下载脚手架 -cli）1234567npm install webpack --save-devnpm i -D webpack-cli# 会多出下面一项“\"devDependencies\": &#123; \"webpack\": \"^4.28.4\"&#125; 安装 webpack-dev-server，可以启动一个服务器、热更新、接口代理等1npm install webpack-dev-server --save-dev 最终的 package.json 文件内容如下：1234567891011121314151617181920212223242526272829&#123; \"name\": \"vue-webpack-iview\", \"version\": \"1.0.0\", \"description\": \"学习《Vue.js实战》之进阶篇\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"repository\": &#123; \"type\": \"git\", \"url\": \"git+https://github.com/yangtao2o/vue-webpack-iview.git\" &#125;, \"keywords\": [ \"vue\", \"webpack\", \"iview\" ], \"author\": \"yangtao\", \"license\": \"ISC\", \"bugs\": &#123; \"url\": \"https://github.com/yangtao2o/vue-webpack-iview/issues\" &#125;, \"homepage\": \"https://github.com/yangtao2o/vue-webpack-iview#readme\", \"devDependencies\": &#123; \"webpack\": \"^4.28.4\", \"webpack-cli\": \"^3.2.1\", \"webpack-dev-server\": \"^3.1.14\" &#125;&#125; 就是一个 js 文件而已创建 webpack.config.js，并初始化： 12345var config = &#123;&#125;module.exports = config; 接着，在 package.json 里配置启动项： 123456789\"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"dev\": \"webpack-dev-server --open --config webpack.config.js --mode=development\"&#125;// --open：会在启动服务时自动\b打开浏览器// --config：指向 webpack-dev-server 读取的配置文件路径// --host --port：可配置 IP 和端口，如：--host 172.172.172.1 --port 8888// --mode=development：需要说明是什么环境，不然会显示警告 webpack 的入口\b（Entry）和出口（Output），重中之重，新建 main.js，并在 webpack.config.js 中进行\b\b入口和输出的配置：123456789101112var config = &#123; entry: &#123; main: &apos;./main&apos; // 入口文件为 main.js &#125;, output: &#123; path: path.join(__dirname, &apos;./dist&apos;), // 输出目录 publicPath: &apos;./dist&apos;, //指定资源文件引用的目录 filename: &apos;main.js&apos; // 指定输出文件的名称 &#125;&#125;module.exports = config; 然后：npm run dev，浏览器会自动打开页面了。 逐步完善配置文件webpack 对于不同的\b模块需要不同的加载器来处理，通过安装不同的加载器，就可以对各种后缀名的文件进行处理。 如处理 .css 文件：123456789101112131415161718# cssnpm install css-loader --save-devnpm install style-loader --save-dev# rules 属性中可以指定一系列的 loaders# 每一个 loader 都必须包含 test 和 use # \b处理名为 .css 的文件时，先通过 css-loader 转换，再通过 style-loader 转换，然后继续打包module: &#123; rules: [ &#123; test: '/\\.css$/', use: [ 'style-loader', 'css-loader' ] &#125; ]&#125; 在实际的业务中，需要使用插件 extract-text-webpack-plugin 把各处的css文件提取出来。，并生成一个 main.css 文件，最终在 index.html 里加载它。 1npm install extract-text-webpack-plugin@next --save-dev config12345678910111213141516var ExtractTextPlugin = require('extract-text-webpack-plugin');module: &#123; rules: [ &#123; test: '/\\.css$/', use: ExtractTextPlugin.extract(&#123; use: 'css-loader', fallback: 'style-loader' &#125;) &#125; ]&#125;,plugins: [ new ExtractTextPlugin('main.css'),] 单文件组件与 vue-loader安装加载器：123456npm install --save-dev vue vue-loader vue-style-loadernpm install --save-dev vue-template-compilernpm install --save-dev vue-hot-reload-apinpm i -D babel babel-loadernpm i -D @babel/corenpm i -D @babel/preset-env 配置：Babel-loader、Vue-loader 结合自己配置的过程中关于版本冲突的解决办法参考：webpack4配置vue环境和一些小坑 主要修改： index.js(之前的 main.js，目录也放在了/src/下) 1234567import Vue from 'vue';import App from './App.vue';const root = document.createElement('div');document.body.appendChild(root);new Vue(&#123; render: h =&gt; h(App)&#125;).$mount(root); App.vue 12345678910111213141516171819&lt;template&gt; &lt;div&gt; Hello &#123;&#123; name &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; name: 'Vue.js' &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; package.js 12345678910111213141516171819202122\"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"dev\": \"webpack-dev-server --config webpack.config.js --mode=development\", \"build\": \"webpack --progress --hide-modules --mode=production\"&#125;,\"devDependencies\": &#123; \"@babel/core\": \"^7.2.2\", \"@babel/preset-env\": \"^7.2.3\", \"babel\": \"^6.23.0\", \"babel-loader\": \"^8.0.5\", \"css-loader\": \"^2.1.0\", \"extract-text-webpack-plugin\": \"^4.0.0-beta.0\", \"style-loader\": \"^0.23.1\", \"vue\": \"^2.5.22\", \"vue-hot-reload-api\": \"^2.3.1\", \"vue-loader\": \"^15.5.1\", \"vue-style-loader\": \"^4.1.2\", \"vue-template-compiler\": \"^2.5.22\", \"webpack\": \"^4.28.4\", \"webpack-cli\": \"^3.2.1\", \"webpack-dev-server\": \"^3.1.14\"&#125;, webpack.config.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344const path = require('path');const VueLoaderPlugin = require('vue-loader/lib/plugin');const ExtractTextPlugin = require('extract-text-webpack-plugin');module.exports = &#123; entry: path.join(__dirname, './src/index.js'), output: &#123; path: path.join(__dirname, './dist'), // 输出目录 publicPath: '/dist', //指定资源文件引用的目录 filename: 'main.js' // 指定输出文件的名称 &#125;, module: &#123; rules: [ &#123; test: /\\.vue$/, loader: 'vue-loader', options: &#123; loaders: &#123; css: ExtractTextPlugin.extract(&#123; use: 'css-loader', fallback: 'vue-style-loader' &#125;) &#125; &#125; &#125;, &#123; test: /\\.js$/, loader: 'babel-loader', exclude: /node_modules/ &#125;, &#123; test: /\\.css$/, use: ExtractTextPlugin.extract(&#123; use: 'css-loader', fallback: 'style-loader' &#125;) &#125; ] &#125;, plugins: [ new VueLoaderPlugin(), new ExtractTextPlugin('main.css'), ]&#125; .babelrc 1234&#123; \"presets\": [\"@babel/preset-env\"], \"plugins\": [\"@babel/plugin-transform-runtime\"]&#125; index.html 123456...&lt;link rel=\"stylesheet\" href=\"./dist/main.css\"&gt;...&lt;body&gt; &lt;script src=\"./dist/main.js\"&gt;&lt;/script&gt;&lt;/body&gt; 用于生产环境(loading…) 练习地址","categories":[{"name":"前端框架","slug":"前端框架","permalink":"https://www.yangtao.site/categories/前端框架/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.yangtao.site/tags/vue/"},{"name":"webpack","slug":"webpack","permalink":"https://www.yangtao.site/tags/webpack/"}]},{"title":"页面滑动时的动画插件 WOW.js","slug":"plugin-wow","date":"2019-02-04T03:16:42.000Z","updated":"2019-12-03T10:19:12.420Z","comments":true,"path":"2019/02/04/plugin-wow/","link":"","permalink":"https://www.yangtao.site/2019/02/04/plugin-wow/","excerpt":"当初次加载页面的时候，需要一些动画渐入，并且当滑动到当前内容时也会出现动画，之后就恢复正常，所以就用到了 WOW.js。","text":"当初次加载页面的时候，需要一些动画渐入，并且当滑动到当前内容时也会出现动画，之后就恢复正常，所以就用到了 WOW.js。 比如：RT-Thread 再比如设计师必备：sketchapp WOW.js文档：WOW Animate.css模拟：Animate animate.css 包含了一组炫酷、有趣、跨浏览器的动画，可以在你的项目中直接使用。 CDN12345&lt;link href=\"https://cdn.bootcss.com/animate.css/3.7.0/animate.min.css\" rel=\"stylesheet\"/&gt;&lt;script src=\"https://cdn.bootcss.com/wow/1.1.2/wow.min.js\"&gt;&lt;/script&gt; 用法文档：Setup WOW.js 12345678```html&lt;div class=&quot;wow bounceInUp&quot; data-wow-duration=&quot;2s&quot; data-wow-delay=&quot;5s&quot;&gt; Content to Reveal Here&lt;/div&gt;&lt;script&gt; new WOW().init();&lt;/script&gt; ps：初始加载页面的时候，很有可能会出现内容再动画渲染，所以直接设置： 123.wow &#123; visibility: hidden;&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"https://www.yangtao.site/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://www.yangtao.site/tags/CSS/"}]},{"title":"npm run 报错：getaddrinfo ENOTFOUND localhost","slug":"localhost","date":"2019-01-13T03:42:37.000Z","updated":"2019-03-13T14:04:16.158Z","comments":true,"path":"2019/01/13/localhost/","link":"","permalink":"https://www.yangtao.site/2019/01/13/localhost/","excerpt":"安装 Angular 的时候，启动 ng serve --open，报错如下：","text":"安装 Angular 的时候，启动 ng serve --open，报错如下：12345➜ my-app git:(master) ng servegetaddrinfo ENOTFOUND localhostError: getaddrinfo ENOTFOUND localhost at errnoException (dns.js:50:10) at GetAddrInfoReqWrap.onlookup [as oncomplete] (dns.js:92:26) 查了一下自己的hosts，原来我把默认的host给关掉了，重新启动即可： 123127.0.0.1 localhost255.255.255.255 broadcasthost::1 localhost 重新 ng serve --open，然后：ℹ ｢wdm｣: Compiled successfully.","categories":[{"name":"前端框架","slug":"前端框架","permalink":"https://www.yangtao.site/categories/前端框架/"}],"tags":[{"name":"报错","slug":"报错","permalink":"https://www.yangtao.site/tags/报错/"},{"name":"Angular","slug":"Angular","permalink":"https://www.yangtao.site/tags/Angular/"}]},{"title":"Windows下Node.js 多版本管理器-Gnvm","slug":"tool-gnvm","date":"2018-12-21T13:40:59.000Z","updated":"2019-11-11T07:37:52.772Z","comments":true,"path":"2018/12/21/tool-gnvm/","link":"","permalink":"https://www.yangtao.site/2018/12/21/tool-gnvm/","excerpt":"我们在平时的项目开发中，经常需要指定 Node 的版本，所有版本控制管理，就很有必要，需要哪个切哪个。","text":"我们在平时的项目开发中，经常需要指定 Node 的版本，所有版本控制管理，就很有必要，需要哪个切哪个。 MacOS主要有 n 和 nvm,具体可以自行百度，查之，用之 123456789sudo npm install -g n# 直接输入 n ,然后回车，可上下选择版本# 安装最新版/稳定版n latest/stable# 删除n rm 8.11.3 主要安利 Windows下的 gnvm官方地址：GNVM - Node.js 多版本管理器 下载12# 使用 git bash，其它下载方式如 go、curl等可查看官方文档git clone git@github.com:Kenshin/gnvm-bin.git 安装将解压后的 gnvm.exe 保存到 node.js 所在的文件夹下，如：1C:\\Program Files\\nodejs 验证管理员身份进入 cmd，输入 gnvm version1234C:\\WINDOWS\\system32&gt;gnvm versionCurrent version 0.2.0 64 bit.Copyright (C) 2014-2016 Kenshin Wang &lt;kenshin@ksria.com&gt;See https://github.com/kenshin/gnvm for more information. 配置12345678C:\\WINDOWS\\system32&gt;gnvm configWaring: config file C:\\Program Files\\nodejs\\\\.gnvmrc is not exist.Notice: Config file C:\\Program Files\\nodejs\\\\.gnvmrc create success.Notice: config file path C:\\Program Files\\nodejs\\\\.gnvmrcgnvm config registry is http://nodejs.org/dist/gnvm config noderoot is C:\\Program Files\\nodejs\\gnvm config globalversion is 10.14.2-x86gnvm config latestversion is unknown 查询需要下载的 node 版本123456789101112131415161718192021222324252627282930313233343536C:\\WINDOWS\\system32&gt;gnvm search 8.*.*Search Node.js version rules [8.*.*] from http://nodejs.org/dist/index.json, please wait.+--------------------------------------------------+| No. date node ver exec npm ver |+--------------------------------------------------+ 1 2018-12-18 8.14.1 x86 x64 6.4.1 2 2018-11-27 8.14.0 x86 x64 6.4.1 3 2018-11-20 8.13.0 x86 x64 6.4.1 4 2018-09-10 8.12.0 x86 x64 6.4.1 5 2018-08-15 8.11.4 x86 x64 5.6.0 6 2018-06-12 8.11.3 x86 x64 5.6.0 7 2018-05-15 8.11.2 x86 x64 5.6.0 8 2018-03-29 8.11.1 x86 x64 5.6.0 9 2018-03-28 8.11.0 x86 x64 5.6.0 10 2018-03-06 8.10.0 x86 x64 5.6.0 11 2018-01-02 8.9.4 x86 x64 5.6.0 12 2017-12-07 8.9.3 x86 x64 5.5.1 13 2017-12-05 8.9.2 x86 x64 5.5.1 14 2017-11-07 8.9.1 x86 x64 5.5.1 15 2017-10-31 8.9.0 x86 x64 5.5.1 16 2017-10-25 8.8.1 x86 x64 5.4.2 17 2017-10-24 8.8.0 x86 x64 5.4.2 18 2017-10-11 8.7.0 x86 x64 5.4.2 19 2017-09-26 8.6.0 x86 x64 5.3.0 20 2017-09-12 8.5.0 x86 x64 5.3.0 21 2017-08-15 8.4.0 x86 x64 5.3.0 22 2017-08-08 8.3.0 x86 x64 5.3.0 23 2017-07-20 8.2.1 x86 x64 5.3.0 24 2017-07-19 8.2.0 x86 x64 5.3.0 25 2017-07-11 8.1.4 x86 x64 5.0.3 26 2017-06-29 8.1.3 x86 x64 5.0.3 27 2017-06-15 8.1.2 x86 x64 5.0.3 28 2017-06-13 8.1.1 x86 x64 5.0.3 29 2017-06-08 8.1.0 x86 x64 5.0.3 30 2017-05-30 8.0.0 x86 x64 5.0.0+--------------------------------------------------+ 下载帮助文档12345C:\\WINDOWS\\system32&gt;gnvm help node-versionShow and fix [global] [latest] Node.js version e.g. :gnvm node-version :Show Node.js global and latest version, and fix it.gnvm node-version latest :Show Node.js latest version, and fix it.gnvm node-version global :Show Node.js global version, and fix it. 下载node1C:\\WINDOWS\\system32&gt;gnvm install 8.11.3 --global 查看已下载的版本列表12345C:\\WINDOWS\\system32&gt;gnvm lsNotice: gnvm.exe root is C:\\Program Files\\nodejs\\\\v10.14.2 -- x86v8.11.2v8.11.3 -- global 使用指定版本12C:\\WINDOWS\\system32&gt;gnvm use 8.11.3Set success, global Node.js version is 8.11.3. 查看当前Node版本12C:\\WINDOWS\\system32&gt;node -vv8.11.3 基本上可以解决版本切换问题，详情可查询官方文档","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://www.yangtao.site/categories/Nodejs/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://www.yangtao.site/tags/Nodejs/"},{"name":"gnvm","slug":"gnvm","permalink":"https://www.yangtao.site/tags/gnvm/"}]},{"title":"通俗点理解Nodejs的非阻塞及事件驱动","slug":"node-event-io","date":"2018-12-18T15:58:41.000Z","updated":"2019-11-13T05:41:20.874Z","comments":true,"path":"2018/12/18/node-event-io/","link":"","permalink":"https://www.yangtao.site/2018/12/18/node-event-io/","excerpt":"node.js是什么 node.js是什么？ 这是一种通过JavaScript语言开发web服务端的东西 为什么我们要用node.js？ node.js有非阻塞，事件驱动I/O等特性，从而让高并发（high concurrency）在的轮询（Polling）和comet构建的应用中成为可能。","text":"node.js是什么 node.js是什么？ 这是一种通过JavaScript语言开发web服务端的东西 为什么我们要用node.js？ node.js有非阻塞，事件驱动I/O等特性，从而让高并发（high concurrency）在的轮询（Polling）和comet构建的应用中成为可能。 HTTP请求 浏览器给网站发请求的过程一直没怎么变过。 当浏览器给网站发了请求。服务器收到了请求，然后开始搜寻被请求的资源。如果有需要，服务器还会查询一下数据库，最后把响应结果传回浏览器。 不过，在传统的web服务器中（比如Apache），每一个请求都会让服务器创建一个新的进程来处理这个请求。 后来有了Ajax。有了Ajax，我们就不用每次都请求一个完整的新页面了，取而代之的是，每次只请求需要的部分页面信息就可以了。 这显然是一个进步。 长轮询但是比如你要建一个FriendFeed这样的社交网站（类似人人网那样的刷朋友新鲜事的网站），你的好友会随时的推送新的状态，然后你的新鲜事会实时自动刷新。 要达成这个需求，我们需要让用户一直与服务器保持一个有效连接。目前最简单的实现方法，就是让用户和服务器之间保持长轮询（long polling）。 HTTP请求不是持续的连接，你请求一次，服务器响应一次，然后就完了。 长轮询是一种利用HTTP模拟持续连接的技巧。具体来说，只要页面载入了，不管你需不需要服务器给你响应信息，你都会给服务器发一个Ajax请求。这个请求不同于一般的Ajax请求，服务器不会直接给你返回信息，而是它要等着，直到服务器觉得该给你发信息了，它才会响应。 比如，你的好友发了一条新鲜事，服务器就会把这个新鲜事当做响应发给你的浏览器，然后你的浏览器就刷新页面了。浏览器收到响应刷新完之后，再发送一条新的请求给服务器，这个请求依然不会立即被响应。 于是就开始重复以上步骤。 利用这个方法，可以让浏览器始终保持等待响应的状态。虽然以上过程依然只有非持续的Http参与，但是我们模拟出了一个看似持续的连接状态。 Apache我们再看传统的服务器（比如Apache）。 每次一个新用户连到你的网站上，你的服务器就得开一个连接。每个连接都需要占一个进程，这些进程大部分时间都是闲着的（比如等着你好友发新鲜事，等好友发完才给用户响应信息。或者等着数据库返回查询结果什么的）。 虽然这些进程闲着，但是照样占用内存。这意味着，如果用户连接数的增长到一定规模，你服务器没准就要耗光内存直接瘫了。 非阻塞和事件驱动这种情况怎么解决？ 解决方法就是刚才上边说的：非阻塞和事件驱动。 这些概念在我们谈的这个情景里面其实没那么难理解。 你把非阻塞的服务器想象成一个loop循环，这个loop会一直跑下去。 一个新请求来了，这个loop就接了这个请求，把这个请求传给其他的进程（比如传给一个搞数据库查询的进程），然后响应一个回调（callback）。 完事了这loop就接着跑，接其他的请求。 这样下来。服务器就不会像之前那样傻等着数据库返回结果了。 如果数据库把结果返回来了，loop就把结果传回用户的浏览器，接着继续跑。 在这种方式下，你的服务器的进程就不会闲着等着。 从而在理论上说，同一时刻的数据库查询数量，以及用户的请求数量就没有限制了。服务器只在用户那边有事件发生的时候才响应，这就是事件驱动。 FriendFeed是用基于Python的非阻塞框架Tornado (知乎也用了这个框架) 来实现上面说的新鲜事功能的。不过，Node.js就比前者更妙了。 再看Node.jsNode.js的应用是通过javascript开发的，然后直接在Google的变态V8引擎上跑。 用了Node.js，你就不用担心用户端的请求会在服务器里跑了一段能够造成阻塞的代码了。 因为javascript本身就是事件驱动的脚本语言。 你回想一下，在给前端写javascript的时候，更多时候你都是在搞事件处理和回调函数。 javascript本身就是给事件处理量身定制的语言。 Node.js还是处于初期阶段。如果你想开发一个基于Node.js的应用，你应该会需要写一些很底层代码。 但是下一代浏览器很快就要采用WebSocket技术了，从而长轮询也会消失。 在Web开发里，Node.js这种类型的技术只会变得越来越重要。 英文原文：Node.js is the New Black 中文原文：Node.js是用来做什么的？","categories":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://www.yangtao.site/categories/Nodejs/"}],"tags":[{"name":"Nodejs","slug":"Nodejs","permalink":"https://www.yangtao.site/tags/Nodejs/"}]},{"title":"git push 报错之 Permission to userA.git denied to userB","slug":"git-push-error","date":"2018-12-17T14:47:00.000Z","updated":"2019-11-13T05:37:55.606Z","comments":true,"path":"2018/12/17/git-push-error/","link":"","permalink":"https://www.yangtao.site/2018/12/17/git-push-error/","excerpt":"报错信息：123➜ git-command git:(master) git pushremote: Permission to xxx.git denied to zguii.fatal: unable to access 'https://github.com/xxx.git/': The requested URL returned error: 403","text":"报错信息：123➜ git-command git:(master) git pushremote: Permission to xxx.git denied to zguii.fatal: unable to access 'https://github.com/xxx.git/': The requested URL returned error: 403 解决过程原因之前我有登录过其他账号，如zguii，并进行了一系列操作，后来我要使用自己的账号的时候，就会出现如上的报错信息。 刚开始嫌麻烦，我使用客户端发布操作，正常，后来，多次使用 git bash，就很痛苦了，索性就改一下。 思路既然是用户权限被占用了，而且我也不需要那个用户了，那就删除吧。 过程123456789101112131415161718192021222324# 重新创建文件，暂时设置密码为空，并且会产生 `id_rsa`、`id_rsa.pub`，（有可能会产生 config ，但有可能是空文件）ssh-keygen -t rsa -C \"yangtaobanner@foxmail.com\"➜ git-command git:(master) ssh-keygen -t rsa -C \"yangtaobanner@foxmail.com\"Generating public/private rsa key pair.Enter file in which to save the key (/Users/yangtao/.ssh/id_rsa): /Users/yangtao/.ssh/id_rsa already exists.Overwrite (y/n)? yEnter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /Users/yangtao/.ssh/id_rsa.Your public key has been saved in /Users/yangtao/.ssh/id_rsa.pub.The key fingerprint is:# 复制 `id_rsa.pub` 里的所有内容，将此粘贴到你要新建的 `SSH key`里# 查看配置git config --listgit config --list --global# 测试是否可以连接ssh -T git@github.comHi yangtao2o! You've successfully authenticated, but GitHub does not provide shell access. 设置完毕，再次 git push，额…依旧报错…想到可能是缓存，好吧，清！呃呃…依然如此… 好多分钟之后，忽然想起还能访问默认账户，说明账户依然存在，笨！ 然后，我就去钥匙串查看了一下 github.com，我去，还真是岿然不动地躺在那儿… 恶狠狠地删之！！！ 然后，git push，输入用户、密码，熬过几秒，刷刷刷，看到了久违的 Done 其实，归根结底，如果Git设置里的账户是你自己的，只要删除钥匙串账户就行，我竟然走了这么久的弯路，脚很疼，哦不，脑瓜子疼！ PS：MacOS 隐藏文件开启快捷键：1command + ^ + . windows解决方法解决 github push failed （remote: Permission to userA/repo.git denied to userB.） ➜ 主要是删除之前的用户，如我的之前的账户是 zguii MacOS解决方法mac下配置多个git账号并进行账号切换 解决git本地多ssh key的问题 多个 SSH KEY 的管理","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://www.yangtao.site/categories/开发工具/"}],"tags":[{"name":"git","slug":"git","permalink":"https://www.yangtao.site/tags/git/"},{"name":"开发工具","slug":"开发工具","permalink":"https://www.yangtao.site/tags/开发工具/"}]},{"title":"Git 常用命令练习","slug":"git-command","date":"2018-12-14T14:45:16.000Z","updated":"2019-11-13T05:38:21.295Z","comments":true,"path":"2018/12/14/git-command/","link":"","permalink":"https://www.yangtao.site/2018/12/14/git-command/","excerpt":"使用 git bash 的过程中，除了常用的那几条，其它的总需要查找手册，索性跟着大牛总结的文章走一遍吧 前言 Workspace: 工作区 Index / Stage: 暂存区 Repository: 仓库区（或本地仓库） Remote: 远程仓库","text":"使用 git bash 的过程中，除了常用的那几条，其它的总需要查找手册，索性跟着大牛总结的文章走一遍吧 前言 Workspace: 工作区 Index / Stage: 暂存区 Repository: 仓库区（或本地仓库） Remote: 远程仓库 新建12345678# 在当前目录 git-command 下新建 Git 代码库，（会生成 .git 文件）git init# 新建目录 git-command 并将其初始化为 Git 代码库git init git-command# 从线上获取一个完整的项目代码git clone https://github.com/yangtao2o/git-command.git 配置Git的设置文件为 .gitconfig ，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 12345678# 显示配置信息git config --list# 修改git config --globalgit config --global user.name \"yangtao\"git config --global user.email \"xxx@.qq.com\" 增加、删除文件123456789101112131415161718192021# 添加指定文件到暂存区git add index.html# 添加指定目录到暂存区，包括子目录git add assets# 添加当前目录的所有文件到暂存区git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交git add -p# 删除工作区文件，并将这次删除加入暂存区git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区git rm --cached [file]# 修改文件名，并放入暂存区git mv index.html index-new.html 代码提交123456789101112131415161718# 暂存区提交到仓库区 ( -m (msg) )git commit -m \"My first commit\"# 指定文件提交git commit [file1] [file2] ... -m [message]# 提交工作区自上次 commit 之后的变化，直接到仓库区git commit -a# 提交时显示所有的 diff 信息git commit -v# 使用一次新的 commit ，提交上一次提交# 如果代码没有任何变化，则用来改写上一次 commit 的提交信息git commit --amend -m \"new commit\"# 重做上一次 commit ，并包括指定文件的新变化git commit --amend [file1] [file2] ... 分支123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有的本地分支git branch# 列出所有的远程分支 ( -r (remotes))git branch -r# 列出所有的本地分支和远程分支git branch -a# 新建一个分支，但依然停留在当前分支git branch primary# 新建，并切换至 该分支git checkout -b primary-yt# 新建，指向指定 commitgit branch [branch] [commitID]# 新建，与指定的远程分支建立追踪关系git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区git checkout [branch-name]# 切换到上一个分支git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间git branch --set-upstream [branch] [remote-branch]# 合并指定分支 master-yt 到当前分支 mastergit merge master-yt# 选择一个\b commit，合并进当前分支git cherry-pick [commitid]# 删除分支git branch -d master-ytt# 删除远程分支git push origin --delete [branch-name]git branch -dr [remote/branch] 标签12# 列出标签git tag 查看信息12345# 显示有变更的文件git status# 显示当前分支的版本历史git log 参考目录 Git 常用命令 Git教程 - 廖雪峰的官方网站 练习 Demo","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://www.yangtao.site/categories/开发工具/"}],"tags":[{"name":"git","slug":"git","permalink":"https://www.yangtao.site/tags/git/"},{"name":"开发工具","slug":"开发工具","permalink":"https://www.yangtao.site/tags/开发工具/"}]},{"title":"小片段代码简汇之CSS篇","slug":"code-css","date":"2018-12-09T13:20:11.000Z","updated":"2019-12-03T10:18:39.394Z","comments":true,"path":"2018/12/09/code-css/","link":"","permalink":"https://www.yangtao.site/2018/12/09/code-css/","excerpt":"总结在平时开发中遇到的一些小问题，大概很长一段时间就会来这么一次，小片段剧场.","text":"总结在平时开发中遇到的一些小问题，大概很长一段时间就会来这么一次，小片段剧场. 页面布局 干货!各种常见布局实现+知名网站实例分析 CSS 灵感 - 这里可以让你寻找到使用或者是学习 CSS 的灵感，以分类的形式，展示不同 CSS 属性或者不同的课题使用 CSS 来解决的各种方法。 white-space | word-break | word-wrap 彻底搞懂 word-break、word-wrap、white-space white-space控制空白字符的显示，同时还能控制是否自动换行。它有五个值：normal | nowrap | pre | pre-wrap | pre-line word-break控制单词如何被拆分换行。它有三个值：normal | break-all | keep-all word-wrap（overflow-wrap）控制长度超过一行的单词是否被拆分换行，是 word-break 的补充，它有两个值：normal | break-word 兼容 Windows、Mac 的 font-family123font-family: Helvetica Neue For Number, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, PingFang SC, \"PingFangSC-Light\", \"Microsoft yahei\", Arial, Helvetica, sans-serif; 关于 ios 下的 input 输入框光标上移的问题 一般外框设置高度为auto,取消掉line-height,input 本身设置字号大小，使用 padding 撑开，取消’height、line-height’ 下拉框箭头重写12345678910111213/* --ie清除--*/select::-ms-expand &#123; display: none;&#125;/* --火狐、谷歌清除--*/select &#123; appearance: none; -moz-appearance: none; -webkit-appearance: none; padding-right: 30px !important; background: #fafafb url(\"/select-logo.png\") 98% 50% no-repeat !important;&#125; 用 CSS 写三角形箭头12345678910111213141516171819202122232425262728.wx-wper-con &#123; position: absolute; left: 0; top: 40px; width: 158px; height: auto; background-color: #fff; border: 1px solid #e9e9e9; padding: 0px 5px; text-align: center; z-index: 100; box-shadow: 0 0 6px -2px #aaa;&#125;.wx-wper-con:before,.wx-wper-con:after &#123; position: absolute; top: -9.5px; right: 20px; display: inline-block; border-right: 8px solid transparent; border-bottom: 8px solid #dadada; border-left: 8px solid transparent; content: \"\";&#125;.wx-wper-con:after &#123; top: -8.5px; border-bottom: 8px solid #fff;&#125; border 边框渐变+圆角123456789101112131415161718192021.border-test &#123; width: 200px; height: 200px; position: relative; border: 4px solid transparent; background-color: #fff; border-top-right-radius: 50px; background-clip: padding-box;&#125;.border-test::after &#123; content: \"\"; display: block; position: absolute; top: -4px; right: -4px; bottom: -4px; left: -4px; border-top-right-radius: 50px; background: linear-gradient(155deg, red, blue); z-index: -1;&#125; 文字两端对齐12text-align: justify;text-align-last: justify; 每个单词的首字母大写1text-transform: uppercase; text-transform 这是 CSS2 中的属性，参数有 capitalize | uppercase | lowercase | none 参数介绍： none： 默认。定义带有小写字母和大写字母的标准的文本。 capitalize： 文本中的每个单词以大写字母开头。 uppercase： 定义仅有大写字母。 lowercase： 定义无大写字母，仅有小写字母。 单选高亮原文 123456789.input:checked + .colors &#123; border-color: #e63838; color: #e63838;&#125;&lt;div class=\"single-check\"&gt; &lt;input class=\"input\" type=\"radio\" name=\"colors\" value=\"1\"&gt; &lt;div class=\"colors\"&gt;天空之境&lt;/div&gt;&lt;/div&gt; ~ 选择器：查找某个元素后面的所有兄弟元素 + 选择器：查找某个元素后面紧邻的兄弟元素 多列等高问题 padding + margin：每列设置一个比较大的padding-bottom，然后通过取负值的 margin-bottom，缺点很明显：如下方无法看到圆角，无法看到 border-bottom 等 display: table display: flex 1px 方案123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354.min-device-pixel-ratio(@scale2, @scale3) &#123; @media screen and (min-device-pixel-ratio: 2), (-webkit-min-device-pixel-ratio: 2) &#123; transform: @scale2; &#125; @media screen and (min-device-pixel-ratio: 3), (-webkit-min-device-pixel-ratio: 3) &#123; transform: @scale3; &#125;&#125;.border-1px(@color: #DDD, @radius: 2px, @style: solid) &#123; &amp;::before &#123; content: \"\"; pointer-events: none; display: block; position: absolute; left: 0; top: 0; transform-origin: 0 0; border: 1px @style @color; border-radius: @radius; box-sizing: border-box; width: 100%; height: 100%; @media screen and (min-device-pixel-ratio: 2), (-webkit-min-device-pixel-ratio: 2) &#123; width: 200%; height: 200%; border-radius: @radius * 2; transform: scale(0.5); &#125; @media screen and (min-device-pixel-ratio: 3), (-webkit-min-device-pixel-ratio: 3) &#123; width: 300%; height: 300%; border-radius: @radius * 3; transform: scale(0.33); &#125; &#125;&#125;.border-top-1px(@color: #DDD, @style: solid) &#123; &amp;::before &#123; content: \"\"; position: absolute; left: 0; top: 0; width: 100%; border-top: 1px @style @color; transform-origin: 0 0; .min-device-pixel-ratio(scaleY(0.5), scaleY(0.33)); &#125;&#125; 原文 css 之 flex 和 gridflex flex - CSS（层叠样式表）| MDN Aligning Items in a Flex Container Flex 布局教程：语法篇 - 阮一峰 Flex 布局教程：实例篇 - 阮一峰 30 分钟彻底弄懂 flex 布局 — 可以直接读这篇总结文章，讲的很详细 A Complete Guide to Flexbox — 比较生动形象，自身网站就很好看 grid Bootstrap 4 的布局在使用 grid CSS Grid 网格布局教程 - 阮一峰 使用 flex 还是 grid 最全～ Grid vs Flex 学习资料 【前端词典】11 个 CSS 知识搭配 11 个 JS 特性 （实用合集） web 前端面试中 10 个关于 css 高频面试题,你都会吗?","categories":[{"name":"CSS","slug":"CSS","permalink":"https://www.yangtao.site/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://www.yangtao.site/tags/CSS/"}]},{"title":"小片段代码简汇之JS篇","slug":"code-js","date":"2018-12-07T15:41:03.000Z","updated":"2019-11-13T05:40:42.789Z","comments":true,"path":"2018/12/07/code-js/","link":"","permalink":"https://www.yangtao.site/2018/12/07/code-js/","excerpt":"总结在平时开发中遇到的一些小问题，大概很长一段时间就会来这么一次，小片段剧场。 Show Time:","text":"总结在平时开发中遇到的一些小问题，大概很长一段时间就会来这么一次，小片段剧场。 Show Time: 多行文本截取clamp.js12345678910111213&lt;script src = \"https://cdn.bootcss.com/Clamp.js/0.5.1/clamp.min.js\" &gt;&lt;/script&gt;clampFunc(\"obj-content-header\", 2);function clampFunc(className, clampNum) &#123; var $module = $(\".\" + className); clampNum = clampNum ? clampNum : 1; $.each($module, function (i, index) &#123; $clamp($(this).get(0), &#123; clamp: clampNum &#125;); &#125;);&#125; 判断本地是否存在jquery写法12345&lt;script type=\"text/javascript\"&gt; if (typeof jQuery == 'undefined') &#123; document.write(unescape(\"%3Cscript src='https://cdn.bootcss.com/jquery/1.9.0/jquery.min.js' type='text/javascript'%3E%3C/script%3E\")); &#125;&lt;/script&gt; 截流函数 AND 节流函数1234567891011121314151617181920212223242526272829303132333435363738394041/** 截流函数 **//** * fn 执行函数 * context 绑定上下文 * timeout 延时数值 **/let debounce = function(fn, context, timeout) &#123; let timer; // 使用闭包将内容传递出去 return function() &#123; if(timer) &#123; clearTimeout(timer); &#125; else &#123; timer = setTimeout(function() &#123; fn.apply(context, arguments); &#125;, timeout); &#125; &#125;&#125;/** 节流函数 **/var throttle = function(fn, delay, mustRunDelay) &#123; var timer = null; var t_start; return function() &#123; var context = this; var args = arguments; var t_curr = +new Date(); clearTimeout(timer); // 初始化 if(!t_start) &#123; t_start = t_curr; &#125; // 超时判断 if(t_curr - t_start &gt;= mustRunDelay) &#123; fn.apply(context, args); t_start = t_curr; &#125; else &#123; &#125; &#125;&#125; for循环添加点击事件123456789var elems = document.getElementsByTagName('a');for (var i = 0, l = elems.length; i &lt; l; i++) &#123; (function(index) &#123; elems[index].addEventListener('click', function(e) &#123; e.preventDefault(); console.log(index); &#125;, 'false'); &#125;)(i);&#125; 判断浏览器是否开启本地cookie1234567891011var nd = new Date();nd.setSeconds(nd.getSeconds() + 60);document.cookie = \"cookietest=1; expires=\" + nd.toGMTString();var cookiesEnabled = document.cookie.indexOf(\"cookietest=\") != -1;if (!cookiesEnabled) &#123; //没有启用cookie alert(\"没有启用cookie \");&#125; else &#123; //已经启用cookie alert(\"已经启用cookie \");&#125; 解决同级元素鼠标移入移出效果123456&lt;a class=\"member-card-item\" id=\"memberCard\" href=\"#\"&gt;&lt;/a&gt;&lt;div class=\"member-card-wper\" id=\"memberProfile\"&gt; &lt;i class=\"drop-icon\"&gt;&lt;/i&gt; &lt;span class=\"card-item\"&gt;&lt;/span&gt; &lt;span class=\"card-item\"&gt;&lt;/span&gt;&lt;/div&gt; 1234567891011121314151617181920var cardTimer = null;var $mCard = $('#rightNav .wx-wper');var $mProfile = $('#rightNav .wx-outer');$mCard.get(0).onmouseover = $mProfile.get(0).onmouseover = function() &#123; clearCardTime();&#125;$mCard.get(0).onmouseout = $mProfile.get(0).onmouseout = function() &#123; cardTime();&#125;function cardTime() &#123; cardTimer = setTimeout(function() &#123; $mProfile.hide(); &#125;, 400);&#125;function clearCardTime() &#123; clearTimeout(cardTimer); $mProfile.show();&#125; placeholder样式兼容&amp;&amp;属性IE兼容1234567.common-form-control::-webkit-input-placeholder,.common-form-control::-moz-placeholder,.common-form-control:-ms-input-placeholder,.common-form-control::placeholder &#123; color: #9b9b9b; opacity: 1;&#125; 1234567891011121314151617181920212223;(function($) &#123; $.fn.placeholder = function(options) &#123; var opts = $.extend(&#123;&#125;, $.fn.placeholder.defaults, options); var isIE = document.all ? true : false; return this.each(function() &#123; var _this = this, placeholderValue = _this.getAttribute(\"placeholder\"); //缓存默认的placeholder值 if (isIE) &#123; _this.setAttribute(\"value\", placeholderValue); _this.onfocus = function() &#123; $.trim(_this.value) == placeholderValue ? _this.value = \"\" : ''; &#125;; _this.onblur = function() &#123; $.trim(_this.value) == \"\" ? _this.value = placeholderValue : ''; &#125;; &#125; &#125;); &#125;;&#125;)(jQuery);&lt;script type=\"text/javascript\"&gt; $(\"input\").placeholder();&lt;/script&gt; 返回顶部函数1234567891011121314151617181920212223242526272829303132// 返回顶部function gotoTop(acceleration,stime) &#123; acceleration = acceleration || 0.1; stime = stime || 10; var x1 = 0; var y1 = 0; var x2 = 0; var y2 = 0; var x3 = 0; var y3 = 0; if (document.documentElement) &#123; x1 = document.documentElement.scrollLeft || 0; y1 = document.documentElement.scrollTop || 0; &#125; if (document.body) &#123; x2 = document.body.scrollLeft || 0; y2 = document.body.scrollTop || 0; &#125; var x3 = window.scrollX || 0; var y3 = window.scrollY || 0; var x = Math.max(x1, Math.max(x2, x3)); var y = Math.max(y1, Math.max(y2, y3)); var speeding = 1 + acceleration; window.scrollTo(Math.floor(x / speeding), Math.floor(y / speeding)); if(x &gt; 0 || y &gt; 0) &#123; var run = \"gotoTop(\" + acceleration + \", \" + stime + \")\"; window.setTimeout(run, stime); &#125;&#125; 滚动监听垂直联动12345678910111213141516171819202122232425262728$(window).scroll(function (event) &#123; var i = 0, sTop = $(this).scrollTop(), windowH = $(window).height() / 2, pos = parseFloat($('#area3').offset().top) / 2, pos1 = $('#area3').offset().top - windowH, pos2 = $('#area4').offset().top - windowH, pos3 = $('#area5').offset().top - windowH, pos4 = $('#area6').offset().top - windowH $target = $('#navList').parent().parent(); if (sTop &gt;= pos) &#123; $target.show(); &#125; else &#123; $target.hide(); &#125; if (sTop &gt;= pos4) &#123; i = 3; &#125; else if (sTop &gt;= pos3) &#123; i = 2; &#125; else if (sTop &gt;= pos2) &#123; i = 1; &#125; else &#123; i = 0; &#125; $('#navList li').eq(i).addClass('active').siblings().removeClass('active');&#125;); 右侧浮动导航平滑切换1234567891011$(\"#navList a\").click(function () &#123; var href = $(this).attr(\"href\"); var pos = $(href).offset().top - 48; $(this).parent().addClass('active').siblings().removeClass('active'); if (!$(\"body\").is(\":animated\")) &#123; $(\"html,body\").animate(&#123; scrollTop: pos &#125;, 600); &#125; return false;&#125;); 判断浏览器是否为IE（包括IE11）123456789function isIE() &#123; if (!!window.ActiveXObject || \"ActiveXObject\" in window) &#123; alert(\"is IE\"); return true; &#125; else &#123; alert(\"is not IE\"); return false; &#125;&#125; 判断浏览器是否为移动端123456var isMobile = false;if(navigator.userAgent.match(/(iPhone|iPod|Android|ios)/i)) &#123; isMobile = true;&#125; else &#123; isMobile = false;&#125; 将时间戳转换为时间123456789101112131415161718function getMyDate(str) &#123; var oDate = new Date(str), oYear = oDate.getFullYear(), oMonth = oDate.getMonth() + 1, oDay = oDate.getDate(), oHour = oDate.getHours(), oMin = oDate.getMinutes(), oSen = oDate.getSeconds(), oTime = oYear + '-' + getzf(oMonth) + '-' + getzf(oDay) + ' ' + getzf(oHour) + ':' + getzf(oMin) + ':' + getzf(oSen); //最后拼接时间 return oTime;&#125;;function getzf(num) &#123; if (parseInt(num) &lt; 10) &#123; num = '0' + num; &#125; return num;&#125; Node实现JavaScript模块的原理简单介绍原文123456789101112131415161718192021222324252627/** Node实现JavaScript模块的一个简单的原理介绍 * Node利用JavaScript的函数式编程的特性，轻而易举地实现了模块的隔离 * 变量module是Node在加载js文件前准备的一个变量，并将其传入加载函数 **/(function() &#123; var s = &apos;Hello&apos;; //读取Hello.js代码 var name = &apos;Taotao&apos;; console.log(&apos;Hell0 &apos; + name + &apos;!&apos;);&#125;)();// 准备module对象var module = &#123; id: &apos;hello&apos;, exports: &#123;&#125;&#125;;var load = function(module) &#123; //读取Hello.js代码 function greet(module) &#123; console.log(&apos;Hell0 &apos; + name + &apos;!&apos;); &#125; module.exports = greet; return module.exports;&#125;var exported = load(module);//保存save(module, exported); Nodejs基本模块fsNode.js内置的fs模块就是文件系统模块，负责读写文件。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354'use strict';var fs = require(\"fs\");// 异步读文件fs.readFile('test1.txt', 'utf-8', function(err, data) &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log(data); &#125;&#125;);// 异步写文件var writeData = 'Hello,Node.js';fs.writeFile('test1.txt', writeData, function(err) &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log('OK!'); &#125;&#125;);// 同步读文件try &#123; var data = fs.readFileSync('test1.txt', 'utf-8'); console.log(data);&#125; catch (err) &#123; console.log(err);&#125;// 同步读文件try &#123; fs.writeFileSync('test1.txt', writeData); console.log(\"OK!\");&#125; catch (err) &#123; console.log(err);&#125;// 异步读取文件相关信息fs.stat('test1.txt', function(err, stat) &#123; if (err) &#123; console.log(err); &#125; else &#123; console.log('isFile: ' + stat.isFile()); // 是否是文件 console.log('isDirectory: ' + stat.isDirectory()); // 是否是目录 if (stat.isFile()) &#123; console.log('size: ' + stat.size); // 文件大小 console.log('birth time: ' + stat.birthtime); // 创建时间，Date对象 console.log('modifier time: ' + stat.mtime); // 修改时间，Date对象 &#125; &#125;&#125;);// 同步读取文件 statSync() Nodejs基本模块http廖雪峰的官方网站之Node中的Http1234567891011121314151617181920212223242526272829303132333435363738'use strict';// 导入http模块var fs = require('fs'), url = require('url'), path = require('path'), http = require('http');// 从命令行参数获取root目录，默认是当前目录：var root = path.resolve(process.argv[2] || '.');console.log('Static root dir: ' + root);// 创建http servervar server = http.createServer(function(request, response) &#123; // 获得URL的path var pathname = url.parse(request.url).pathname; // 获得对应的本地文件路径 var filepath = path.join(root, pathname); // 获取文件状态 fs.stat(filepath, function(err, stats) &#123; if(!err &amp;&amp; stats.isFile()) &#123; console.log('200 ' + request.url); response.writeHead(200); // 将文件流导向response fs.createReadStream(filepath).pipe(response); &#125; else &#123; console.log('404 ' + request.url); response.writeHead(404); response.end('404 Not Found'); &#125; &#125;);&#125;);// 让服务器监听8080端口server.listen(8080);console.log('Server is running at http:127.0.0.1:8080/');","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/tags/JavaScript/"}]},{"title":"自定义单选框、复选框样式","slug":"style-checkout-radio","date":"2018-12-07T15:36:33.000Z","updated":"2019-11-13T05:39:07.212Z","comments":true,"path":"2018/12/07/style-checkout-radio/","link":"","permalink":"https://www.yangtao.site/2018/12/07/style-checkout-radio/","excerpt":"开发过程中，为了兼容IE低版本浏览器，我们重写单选框、复选框等的样式，就需要借助 js 来实现。","text":"开发过程中，为了兼容IE低版本浏览器，我们重写单选框、复选框等的样式，就需要借助 js 来实现。Javascript 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 重写多选框,单选框样式;(function ($) &#123; $.fn.hcheckbox = function (options) &#123; $(':checkbox+label', this).each(function () &#123; $(this).addClass('disabled'); if ($(this).prev().is(':disabled') == false) &#123; if ($(this).prev().is(':checked')) $(this).addClass(\"checked\"); &#125; else &#123; $(this).addClass('disabled'); return false; &#125; &#125;).click(function (event) &#123; var ischeckbox = $(this).prev().is(':checked'); if (!ischeckbox) &#123; $(this).addClass(\"checked\"); $(this).prev().checked = true; &#125; else &#123; $(this).removeClass('checked'); $(this).prev().checked = false; &#125; event.stopPropagation(); &#125;).prev().hide(); &#125; $.fn.hradio = function (options) &#123; var self = this; return $(':radio+label', this).each(function () &#123; $(this).addClass('hRadio'); if ($(this).prev().is(\"checked\")) $(this).addClass('hRadio-Checked'); &#125;).click(function (event) &#123; $(this).parent().siblings().find(':radio+label').removeClass(\"hRadio-Checked\"); if (!$(this).prev().is(':checked')) &#123; $(this).addClass(\"hRadio-Checked\"); $(this).prev()[0].checked = true; &#125; event.stopPropagation(); &#125;).prev().hide(); &#125;&#125;)(jQuery)$(function() &#123; $('.checkbox').hcheckbox(); $('.radio-wper').hradio();&#125;); Style123456789101112131415161718192021222324252627282930313233343536.checkbox input,.radio-wper input &#123; display: none;&#125;.checkbox label,.radio-wper label &#123; padding-left: 22px; position: relative;&#125;.checkbox .disabled:before,.checkbox .checked:before,.radio-wper .hRadio:before,.radio-wper .hRadio-Checked:before &#123; content: \"\"; display: inline-block; width: 14px; height: 14px; position: absolute; top: 3px; left: 0; background-position: 0 0; background-repeat: no-repeat; background-size: 100% 100%;&#125;.checkbox .disabled:before &#123; background-image: url('../../images/activities/adi2018/check-01.png');&#125;.checkbox .checked:before &#123; background-image: url('../../images/activities/adi2018/check-02.png');&#125;.radio-wper .hRadio:before &#123; background-image: url('../../images/activities/adi2018/radio-01.png');&#125;.radio-wper .hRadio-Checked:before &#123; background-image: url('../../images/activities/adi2018/radio-02.png');&#125;","categories":[{"name":"工具库","slug":"工具库","permalink":"https://www.yangtao.site/categories/工具库/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/tags/JavaScript/"}]},{"title":"实现文字的无缝滚动、间歇性向上翻滚","slug":"plugin-scroll","date":"2018-11-29T12:53:31.000Z","updated":"2019-11-13T05:41:43.968Z","comments":true,"path":"2018/11/29/plugin-scroll/","link":"","permalink":"https://www.yangtao.site/2018/11/29/plugin-scroll/","excerpt":"文字向上滚动分为：无缝滚动、间歇性滚动","text":"文字向上滚动分为：无缝滚动、间歇性滚动 间歇性滚动使用jQuery的 animate一般情况下，向上翻滚一行内容，即一个&lt;li&gt;&lt;/li&gt;，但是如果是一行有多个li标签，要使用常见的插件就会出现问题了… 所以自己改吧改吧：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859(function ($) &#123; $.fn.myScroll = function(options) &#123; var init = &#123; items: 1, //一行有几项内容 speed: 3000, //滚动速度 moveHeight: 22 // 行高 &#125;; var intId = []; var opts = $.extend(&#123;&#125;, init, options); function moveUp(obj) &#123; obj.animate(&#123; marginTop: '-' + opts.moveHeight + 'px' &#125;, 1000, function() &#123; var $this = $(this); $this.find('li').slice(0, opts.items).appendTo($this); $this.css('margin-top', 0); &#125;) &#125; this.each(function(i) &#123; var sh = opts.moveHeight, speed = opts.speed, items = opts.items, $this = $(this); intId[i] = setInterval(timerEvent, speed); $this.hover(function() &#123; clearInterval(intId[i]); &#125;, function() &#123; intId[i] = setInterval(timerEvent, speed); &#125;); var len = $this.find('li').length; if(len &gt; items &amp;&amp; len &lt;= items * 2) &#123; $this.html($this.html() + $this.html()); &#125; function timerEvent() &#123; var len = $this.find('li').length; if(len &gt; items &amp;&amp; len &lt;= items * 2) &#123; len /= 2; &#125; if(len &lt;= items) &#123; clearInterval(intId[i]); &#125; else &#123; moveUp($this, sh); &#125; &#125; &#125;); &#125;&#125;)(jQuery);$('#scrollLists').myScroll(&#123; items: 3, speed: 3000, moveHeight: 22&#125;); 以下的都是单行内容翻滚，搬过来记录下： 使用JavaScript1234567891011121314151617function Scroll() &#123;&#125;Scroll.prototype.upScroll = function (dom, _h, interval) &#123; var dom = document.getElementById(dom); var timer = setTimeout(function () &#123; var _field = dom.children[0]; _field.style.marginTop = _h; clearTimeout(timer); &#125;, 1000) setInterval(function () &#123; var _field = dom.children[0]; _field.style.marginTop = \"0px\"; dom.appendChild(_field); var _field = dom.children[0] _field.style.marginTop = _h; &#125;, interval)&#125;var myScroll = new Scroll(); 用法：12345678/* * demo 父容器(ul)的id * -36px 子元素li的高度 * 3000 滚动间隔时间 * 每次滚动持续时间可到css文件中修改 * （找不到原文了-.-） */myScroll.upScroll(\"demo\",\"-36px\",3000); 无缝滚动下载地址：简单的jQuery无缝向上滚动效果12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758(function ($) &#123; $.fn.myScroll = function (options) &#123; //默认配置 var defaults = &#123; speed: 40, //滚动速度,值越大速度越慢 rowHeight: 24 //每行的高度 &#125;; var opts = $.extend(&#123;&#125;, defaults, options), intId = []; function marquee(obj, step) &#123; obj.find(\"ul\").animate(&#123; marginTop: '-=1' &#125;, 0, function () &#123; var s = Math.abs(parseInt($(this).css(\"margin-top\"))); if (s &gt;= step) &#123; $(this).find(\"li\").slice(0, 1).appendTo($(this)); $(this).css(\"margin-top\", 0); &#125; &#125;); &#125; this.each(function (i) &#123; var sh = opts[\"rowHeight\"], speed = opts[\"speed\"], _this = $(this); intId[i] = setInterval(function () &#123; if (_this.find(\"ul\").height() &lt;= _this.height()) &#123; clearInterval(intId[i]); &#125; else &#123; marquee(_this, sh); &#125; &#125;, speed); _this.hover(function () &#123; clearInterval(intId[i]); &#125;, function () &#123; intId[i] = setInterval(function () &#123; if (_this.find(\"ul\").height() &lt;= _this.height()) &#123; clearInterval(intId[i]); &#125; else &#123; marquee(_this, sh); &#125; &#125;, speed); &#125;); &#125;); &#125;&#125;)(jQuery);$(function()&#123; $('.myscroll').myScroll(&#123; speed: 40, //数值越大，速度越慢 rowHeight: 26 //li的高度 &#125;);&#125;);","categories":[{"name":"工具库","slug":"工具库","permalink":"https://www.yangtao.site/categories/工具库/"}],"tags":[{"name":"js插件","slug":"js插件","permalink":"https://www.yangtao.site/tags/js插件/"}]},{"title":"九宫格抽奖","slug":"plugin-lottery","date":"2018-11-27T15:11:54.000Z","updated":"2019-11-13T05:42:29.984Z","comments":true,"path":"2018/11/27/plugin-lottery/","link":"","permalink":"https://www.yangtao.site/2018/11/27/plugin-lottery/","excerpt":"九宫格抽奖记录：","text":"九宫格抽奖记录： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173// 九宫格抽奖var click=false;var luck=&#123; index: 0, //当前转动到哪个位置，起点位置 count: 0, //总共有多少个位置 timer: 0, //setTimeout的ID，用clearTimeout清除 speed: 30, //初始转动速度 times: 0, //转动次数 cycle: 70, //转动基本次数：即至少需要转动多少次再进入抽奖环节 prize: -1, //中奖位置 init:function(id)&#123; if ($(\"#\"+id).find(\".luck-unit\").length&gt;0) &#123; $luck = $(\"#\"+id); $units = $luck.find(\".luck-unit\"); this.obj = $luck; this.count = $units.length; // $luck.find(\".luck-unit-\"+this.index).addClass(\"active\"); &#125;; &#125;, roll:function()&#123; var index = this.index; var count = this.count; var luck = this.obj; $(luck).find(\".luck-unit-\"+index).removeClass(\"active\"); index += 1; if (index&gt;count-1) &#123; index = 0; &#125;; $(luck).find(\".luck-unit-\"+index).addClass(\"active\"); this.index=index; return false; &#125;, stop:function(index)&#123; this.prize=index; return false; &#125;&#125;;function roll(which)&#123; luck.times += 1; luck.roll(); if (luck.times &gt; luck.cycle+10 &amp;&amp; luck.prize==luck.index) &#123; var title = ''; var content = ''; var desc = ''; var prize = ''; // 最终停下来的位置 // 初始化 clearTimeout(luck.timer); luck.prize=-1; luck.times=0; click=false; switch(which) &#123; case 0: prize = '小米鼠标'; break; case 1: prize = '固态硬盘'; break; case 2: prize = '乐扣保温杯'; break; case 3: prize = '京东券'; break; case 4: prize = '谢谢参与'; break; case 5: prize = '万用表'; break; case 6: prize = '摩尔吧课程折扣券'; break; case 7: prize = '小米耳机'; break; &#125; if(which == 4) &#123; title = '谢谢参与'; content = '再接再厉' desc = '请查看活动详情，获取更多抽奖资格'; &#125; else &#123; title = '恭喜您'; content = '获得 &lt;span class=\"blue\"&gt;'+ prize +'&lt;/span&gt;'; if(which == 6) &#123; desc = '请至您的”个人中心“查收'; &#125; else &#123; desc = '奖品将于活动结束后统一发送'; &#125; &#125; // 展示中奖状态 setTimeout(function() &#123; modalShow(title,content,desc); &#125;, 800); &#125; else &#123; if (luck.times&lt;luck.cycle) &#123; luck.speed -= 10; &#125; else if (luck.times==luck.cycle) &#123; // 最终中奖位置的索引 luck.prize = which; &#125; else &#123; if (luck.times &gt; luck.cycle+10 &amp;&amp; ((luck.prize==0 &amp;&amp; luck.index==7) || luck.prize==luck.index+1)) &#123; luck.speed += 110; &#125; else &#123; luck.speed += 20; &#125; &#125; if (luck.speed&lt;40) &#123; luck.speed=40; &#125; luck.timer = setTimeout(function() &#123; roll(which); &#125;,luck.speed); &#125; return false;&#125;$(function() &#123; // Lottery init luck.init('luckArea'); $(\"#startBtn\").click(function()&#123; if(click) &#123; return false; &#125;else&#123; click=true; luck.speed=100; $.get(\"http://www.moore8.com/campaign/lotteryAct\", function (data) &#123; var data = $.parseJSON(data); console.log('data:', data); if(data.code == 1) &#123; var which = data.type; // 调取抽奖并传值 roll(which); &#125; else &#123; if(data.msg == '请先登录！') &#123; loginFunc('course_gift'); &#125; else &#123; var desc = '请查看活动详情，获取更多抽奖资格'; modalShow('对不起', data.msg, desc); &#125; click = false; &#125; &#125;); return false; &#125; &#125;);&#125;)function modalShow(title, body, desc) &#123; var title = title || '温馨提示'; var body = body || ''; var desc = desc || ''; $('#mTitle').html(title); $('#mBody').html(body); $('#mDesc').html(desc); $('#myModal').modal('show');&#125;function loginFunc(id) &#123; var href = window.location.href; var id = id ? \"%23\" + id : ''; window.location.href = \"/login/?referer=\" + href + id;&#125;","categories":[{"name":"工具库","slug":"工具库","permalink":"https://www.yangtao.site/categories/工具库/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://www.yangtao.site/tags/jQuery/"}]},{"title":"活动之整点秒杀功能优化","slug":"feat-sale","date":"2018-11-27T15:00:44.000Z","updated":"2019-11-13T05:39:42.740Z","comments":true,"path":"2018/11/27/feat-sale/","link":"","permalink":"https://www.yangtao.site/2018/11/27/feat-sale/","excerpt":"整点秒杀功能总结：","text":"整点秒杀功能总结：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205var starttime1 = \"2018/11/14 14:00\", endtime1 = \"2018/11/15 14:00\", starttime7 = \"2018/11/19 14:00\", endtime7 = \"2018/11/20 14:00\", // 中 5~8 组（省略） // 下 9~12 组（省略） starttime22 = \"2018/11/29 14:00\", endtime22 = \"2018/11/30 14:00\", starttime23 = \"2018/12/14 14:00\", endtime23 = \"2018/12/15 14:00\";/** * 获取 整点秒杀状态 */var getShopStatus = function () &#123; var statuShop = []; $.ajax(&#123; url: '//www.eeboard.com/wp-content/themes/eeboard/api/eeboardsix.php?act=shop_detail', dataType: 'json', cache: false, async: false, type: \"GET\", success: function (data) &#123; var arr8 = data.data.eight; // 整点秒杀状态 if (!arr8) &#123; arr8 = [false, false, false, false, false, false, false, false, false, false, false, false] &#125; var d1over = arr8[0], d2over = arr8[1], d3over = arr8[2], d4over = arr8[3], d5over = arr8[4], d6over = arr8[5], d7over = arr8[6], d8over = arr8[7], d9over = arr8[8], d10over = arr8[9], d11over = arr8[10], d12over = arr8[11]; statuShop = [ d1over, d1over, d2over, d2over, d3over, d3over, d4over, d5over, d5over, d6over, d6over, d7over, d7over, d8over, d8over, d9over, d9over, d10over, d10over, d11over, d11over, d12over, d12over ]; return statuShop; &#125;, error: function (error) &#123; // console.log('商城接口报错---'); // console.log(error); &#125; &#125;); return statuShop;&#125;var shopStatusArr = getShopStatus();/** * 时间状态函数 */function timeStatus(start, end) &#123; var status = 'load', nowTime = parseFloat(new Date().getTime()), startTime = parseFloat((new Date(start)).getTime()), endTime = parseFloat((new Date(end)).getTime()), lastStartTime = parseFloat(startTime - nowTime), lastEndTime = parseFloat(endTime - nowTime); // 未开始 if (lastStartTime &gt; 0) &#123; return status = 'load'; &#125; else if (lastStartTime &lt;= 0 &amp;&amp; lastEndTime &gt; 0) &#123; // 进行中 return status = 'start'; &#125; else if (lastEndTime &lt;= 0) &#123; // 已结束 return status = 'end'; &#125;&#125;/** * 各个时间段状态切换函数 */function isTimeStartEvent() &#123; var timer; var timersArr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]; // 判断时间状态 $.each(timersArr, function (i, item) &#123; var start = eval('starttime' + item); var end = eval('endtime' + item); var status = timeStatus(start, end); switchCaseEvent(item, status); &#125;);&#125;/* * 秒杀时间监控：判断时间段函数 */function intervalStartEvent(start, end) &#123; var bigTimer; var isClear = false; var status = timeStatus(start, end); // 时间截止，清除定时器 if (status === 'end') &#123; isClear = true; &#125; if (isClear) &#123; clearTimeout(bigTimer); &#125; else &#123; bigTimer = setTimeout('intervalStartEvent(starttime1, endtime23);', 1000); &#125; // 监控时间段函数 isTimeStartEvent();&#125;/** * 提示及button状态切换函数 */function switchCaseEvent(item, type) &#123; item = item || 1; type = type || 'end'; switch (item) &#123; case 1: case 2: startAndEndEvent($('#qiangbtn1'), item, type); break; case 3: case 4: startAndEndEvent($('#qiangbtn2'), item, type); break; case 5: case 6: startAndEndEvent($('#qiangbtn3'), item, type); break; case 7: startAndEndEvent($('#qiangbtn4'), item, type); break; case 8: case 9: startAndEndEvent($('#qiangbtn5'), item, type); break; case 10: case 11: startAndEndEvent($('#qiangbtn6'), item, type); break; case 12: case 13: startAndEndEvent($('#qiangbtn7'), item, type); break; case 14: case 15: startAndEndEvent($('#qiangbtn8'), item, type); break; case 16: case 17: startAndEndEvent($('#qiangbtn9'), item, type); break; case 18: case 19: startAndEndEvent($('#qiangbtn10'), item, type); break; case 20: case 21: startAndEndEvent($('#qiangbtn11'), item, type); break; case 22: case 23: startAndEndEvent($('#qiangbtn12'), item, type); break; default: break; &#125;&#125;/** * 文字状态切换函数 */function startAndEndEvent(obj, item, type) &#123; if (!obj) return; if (type === 'start') &#123; var status = shopStatusArr[item - 1]; if (status) &#123; $('#qiang-time0' + item).text('开始秒杀'); obj.removeClass('unclick').text('开始秒杀'); &#125; else &#123; $('#qiang-time0' + item).text('已抢光').css('color', '#9b9b9b'); obj.addClass('unclick unclick-over').text('已抢光'); &#125; return false; &#125; else if (type === 'end') &#123; $('#qiang-time0' + item).text('已抢光').css('color', '#9b9b9b'); obj.addClass('unclick unclick-time').text('已抢光'); &#125; else &#123; $('#qiang-time0' + item).text('即将开始'); // 两对时间段对应同一个按钮，判断本段时间是否截止，再开启另一段时间的状态 if (obj.hasClass('unclick-time')) &#123; obj.removeClass('unclick').text('即将开始'); &#125; &#125;&#125;","categories":[{"name":"工具库","slug":"工具库","permalink":"https://www.yangtao.site/categories/工具库/"}],"tags":[{"name":"js功能","slug":"js功能","permalink":"https://www.yangtao.site/tags/js功能/"}]},{"title":"设置Cookie","slug":"web-cookie","date":"2018-11-03T15:41:22.000Z","updated":"2019-11-13T05:41:53.067Z","comments":true,"path":"2018/11/03/web-cookie/","link":"","permalink":"https://www.yangtao.site/2018/11/03/web-cookie/","excerpt":"设置Cookie总结","text":"设置Cookie总结 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 收藏功能 function addFavorite() &#123; var title = '意法半导体STM32/STM8技术社区 - 提供最新的ST资讯和技术交流'; var URL = 'http://www.stmcu.org.cn/'; // IE10 if(document.all) &#123; window.external.addFavorite(URL, title); &#125; else &#123; alert('手动 Ctrl+D 可以收藏我们的网站哦'); &#125; &#125; // 设置cookie，同一域名都可获取 function setCookie(name, value, exdays) &#123; var exdays = exdays || 1024; var d = new Date(); d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000)); document.cookie = name + \"=\" + escape(value) + \";path=/;expires=\" + d.toGMTString(); &#125; // 读取cookies，判断是否存在设置的name function getCookie(name) &#123; var name = name + \"=\"; var ca = document.cookie.split(';'); for (var i = 0; i &lt; ca.length; i++) &#123; var c = ca[i].trim(); if (c.indexOf(name) == 0) &#123; return c.substring(name.length, c.length); &#125; &#125; return \"\"; &#125; function checkCookie() &#123; var user = getCookie(\"msgCookie\"); var width = window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth; if(width &gt;= 1080) &#123; if (user != \"\") &#123; msgHide(); &#125; else &#123; msgShow(); &#125; &#125; &#125; // 关闭时设置cookie function closeModal() &#123; msgHide(); setCookie(\"msgCookie\", 'msgCookie'); &#125; function msgHide() &#123; document.getElementById('newsTipsModal').style.display = 'none'; &#125; function msgShow() &#123; document.getElementById('newsTipsModal').style.display = 'block'; &#125; // init checkCookie();","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/categories/JavaScript/"}],"tags":[{"name":"js功能","slug":"js功能","permalink":"https://www.yangtao.site/tags/js功能/"}]},{"title":"学习JavaScript深入系列简要总结","slug":"js-learn-prototype","date":"2018-10-31T15:07:42.000Z","updated":"2019-11-13T05:40:14.632Z","comments":true,"path":"2018/10/31/js-learn-prototype/","link":"","permalink":"https://www.yangtao.site/2018/10/31/js-learn-prototype/","excerpt":"学习JavaScript深入系列简要总结","text":"学习JavaScript深入系列简要总结 从原型到原型链原文地址：JavaScript深入之从原型到原型链 每一个函数都有一个prototype属性，该属性指向了一个对象，此对象为调用该函数而创建的实例的原型 每一个对象（除null）都具有一个属性：__proto__，这个属性指向该对象的原型 每个原型都有一个constructor属性指向关联的构造函数 原型对象是通过 Object 构造函数生成的，最后Object.prototype.__proto__ = null 词法作用域和动态作用域原文链接：JavaScript深入之词法作用域和动态作用域 javascript采用的是词法作用域(lexical scoping)，函数的作用域是在函数定义的时候就决定了，而不是调用的时候才决定 词法作用域，即静态作用域，函数的作用域在函数定义的时候就决定了 动态作用域，函数的作用域是在函数调用的时候才决定 执行上下文栈当执行一个函数的时候，就会创建一个执行上下文(execution context)，并且压入执行上下文栈(Execution context stack, ESC) 当函数执行完毕的时候，会将函数的执行上下文栈中弹出 变量对象1、全局上下文的变量对象初始化：全局对象 2、函数上下文的变量对象初始化：只包括Arguments对象 3、进入执行上下文时：给变量对象添加形参、函数声明、变量声明等初始的属性值 4、代码执行阶段：再次修改变量对象的属性值 总结：未进入执行阶段之前，变量对象(VO)中的属性都不能访问！但是进入执行阶段之后，变量对象(VO)转变为了活动对象(AO)，里面的属性都能被访问了，然后开始进行执行阶段的操作。它们其实都是同一个对象，只是处于执行上下文的不同生命周期。 最后，函数是“第一等公民”，记住这个，变量名称和函数名称相同的声明，优先执行函数声明 作用域从ECMAScript规范解读this执行上下文闭包闭包是指那些能够访问自由变量的函数。 自由变量是指在函数中使用的，但既不是参数也不是函数的局部变量的变量。 那么，闭包 = 函数 + 函数能够访问的自由变量。 参数按值传递ECMAScript中所有函数的参数都是按值传递的。 即，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制给另一个变量一样。 参数如果是基本类型是按值传递，如果是引用类型按共享传递。 共享传递是指，在传递对象的时候，传递对象的引用的副本。 call和apply的模拟实现call()在使用一个指定的this值和若干个指定的参数值的前提下，调用某个函数或方法。 12345678910111213Function.prototype.mycall = function(context) &#123; var context = context || window; //获取调用call的函数，用this可以获取 context.fn = this; var args = []; for (var i = 1, l = arguments.length; i &lt; l; i++) &#123; args.push('arguments[' + i + ']'); &#125; // 把传给call的参数传递给了context.fn函数 var result = eval('context.fn(' + args + ')'); delete context.fn; return result;&#125; apply()同call()，只不过将多个参数值，以数组的形式传入而已。 12345678910111213141516Function.prototype.myapply = function(context, arr) &#123; var context = Object(context) || window; context.fn = this; var result; if (!arr) &#123; result = context.fn(); &#125; else &#123; var args = []; for (var index = 0; index &lt; arr.length; index++) &#123; args.push('arr[' + index + ']'); &#125; result = eval('context.fn(' + args + ')'); &#125; delete context.fn; return result;&#125; bind的模拟实现bind()方法会创建一个新函数。当这个新函数被调用，bind()第一个参数将作为它运行时的this，之后的一系列参数将会在传递的实参前传入，作为它的参数。 new的模拟实现new运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/tags/JavaScript/"}]},{"title":"冴羽的博客之JavaScript、ES6系列集锦","slug":"blog-01","date":"2018-10-26T13:45:29.000Z","updated":"2018-10-26T13:55:43.484Z","comments":true,"path":"2018/10/26/blog-01/","link":"","permalink":"https://www.yangtao.site/2018/10/26/blog-01/","excerpt":"JavaScript深入系列 15 篇已完结JavaScript专题系列 20 篇已完结underscore 系列 8 篇已完结","text":"JavaScript深入系列 15 篇已完结JavaScript专题系列 20 篇已完结underscore 系列 8 篇已完结 冴羽的博客专栏 掘金主页 segmentfault主页 知乎 深入系列目录 JavaScirpt深入之从原型到原型链 JavaScript深入之词法作用域和动态作用域 JavaScript深入之执行上下文栈 JavaScript深入之变量对象 JavaScript深入之作用域链 JavaScript深入之从ECMAScript规范解读this JavaScript深入之执行上下文 JavaScript深入之闭包 JavaScript深入之参数按值传递 JavaScript深入之call和apply的模拟实现 JavaScript深入之bind的模拟实现 JavaScript深入之new的模拟实现 JavaScript深入之类数组对象与arguments JavaScript深入之创建对象的多种方式以及优缺点 JavaScript深入之继承的多种方式以及优缺点 JavaScript深入系列15篇正式完结！ 专题系列目录 JavaScript专题之跟着underscore学防抖 JavaScript专题之跟着underscore学节流 JavaScript专题之数组去重 JavaScript专题之类型判断(上) JavaScript专题之类型判断(下) JavaScript专题之深浅拷贝 JavaScript专题之从零实现jQuery的extend JavaScript专题之如何求数组的最大值和最小值 JavaScript专题之数组扁平化 JavaScript专题之学underscore在数组中查找指定元素 JavaScript专题之jQuery通用遍历方法each的实现 JavaScript专题之如何判断两个对象相等 JavaScript专题之函数柯里化 JavaScript专题之偏函数 JavaScript专题之惰性函数 JavaScript专题之函数组合 JavaScript专题之函数记忆 JavaScript专题之递归 JavaScript专题之乱序 JavaScript专题之解读 v8 排序源码 JavaScript专题系列20篇正式完结！ underscore 系列目录 underscore 系列之如何写自己的 underscore underscore 系列之链式调用 underscore 系列之内部函数 cb 和 optimizeCb underscore 系列之内部函数 restArgs underscore 系列之防冲突与 Utility Functions underscore 系列之实现一个模板引擎(上) underscore 系列之实现一个模板引擎(下) underscore 系列之字符实体与 _.escape underscore 的源码该如何阅读？ ES6 系列目录 ES6 系列之 let 和 const ES6 系列之模板字符串 ES6 系列之箭头函数 ES6 系列之模拟实现 Symbol 类型 ES6 系列之迭代器与 for of ES6 系列之模拟实现一个 Set 数据结构 ES6 系列之 WeakMap ES6 系列之我们来聊聊 Promise ES6 系列之 Generator 的自动执行 ES6 系列之我们来聊聊 Async 友情链接 如何轻松拿到淘宝前端 offer","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/categories/JavaScript/"}],"tags":[{"name":"Blog","slug":"Blog","permalink":"https://www.yangtao.site/tags/Blog/"}]},{"title":"Purl.js-JS获取地址栏信息用例测试","slug":"js-purl","date":"2018-09-23T08:01:16.000Z","updated":"2018-09-23T08:47:02.159Z","comments":true,"path":"2018/09/23/js-purl/","link":"","permalink":"https://www.yangtao.site/2018/09/23/js-purl/","excerpt":"Purl.js可以帮助我们来获取地址栏的一些信息， 可以使用原生js，也可以使用jQuery Purl.js官方文档","text":"Purl.js可以帮助我们来获取地址栏的一些信息， 可以使用原生js，也可以使用jQuery Purl.js官方文档 Attributes Info source The whole url being parsed protocol eg. http, https, file, etc host eg. www.mydomain.com, localhost etc port eg. 80 relative The relative path to the file including the querystring (eg. /folder/dir/index.html?item=value) path The path to the file (eg. /folder/dir/index.html) directory The directory part of the path (eg. /folder/dir/) file The basename of the file eg. index.html query The entire query string if it exists, eg. item=value&amp;item2=value2 fragment or anchor The entire string after the # symbol 初始化：123456789101112131415161718192021222324252627var url;var myurl;$(\"#clickBtn\").find('button').click(function(e) &#123; var res, resInfo; myurl = $(\"#urlArea\").val(); // 如果myurl为空，则会获取当前页面的url url = purl(myurl); $(\"#urlArea\").val(myurl); res = $(this).text(); resInfo = getUrlInfo(url, res); $(\"#inputRes\").val(resInfo);&#125;);function getUrlInfo(url, res) &#123; if (res === 'param') &#123; return url.param(); &#125; else if (res === 'segment') &#123; return url.segment(); &#125; else &#123; return url.attr(res); &#125;&#125; 运行试试看： codepen完整代码 截图如下所示： 记录在QDfuns: Purl.js-使用JS获取URL信息","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/categories/JavaScript/"}],"tags":[{"name":"js插件","slug":"js插件","permalink":"https://www.yangtao.site/tags/js插件/"}]},{"title":"HTML5 Canvas 图形绘制","slug":"canvas-01","date":"2018-09-23T07:18:46.000Z","updated":"2019-12-03T10:17:27.750Z","comments":true,"path":"2018/09/23/canvas-01/","link":"","permalink":"https://www.yangtao.site/2018/09/23/canvas-01/","excerpt":"canvas 元素并非 Canvas 中最强大的部分，真正的关键部分是 2D 渲染上下文，这是你真正绘制图形的地方。canvas 元素的用途只是作为 2D 渲染上下文的包装器，它包含绘图和图形操作所需要的全部方法和丰富功能。理解这一点是很重要的，强调一下：绘图是在 2D 渲染上下文中进行的，而不是在 canvas 元素中进行。可以通过 canvas 元素访问和显示 2D 渲染上下文。【引入原文】","text":"canvas 元素并非 Canvas 中最强大的部分，真正的关键部分是 2D 渲染上下文，这是你真正绘制图形的地方。canvas 元素的用途只是作为 2D 渲染上下文的包装器，它包含绘图和图形操作所需要的全部方法和丰富功能。理解这一点是很重要的，强调一下：绘图是在 2D 渲染上下文中进行的，而不是在 canvas 元素中进行。可以通过 canvas 元素访问和显示 2D 渲染上下文。【引入原文】 示例HTML5 Canvas 粉尘态粒子引力效应 文章HTML5 Canvas 图形绘制 初级 HTML5 Canvas 图形绘制 中级 HTML5 跟随鼠标移动的雪花动画 HTML5 Canvas 很酷炫的粉尘态粒子引力效应实践 HTML5 很酷炫的点线粒子特效，你不试一下？","categories":[{"name":"Html","slug":"Html","permalink":"https://www.yangtao.site/categories/Html/"}],"tags":[{"name":"Canvas","slug":"Canvas","permalink":"https://www.yangtao.site/tags/Canvas/"}]},{"title":"【转】高效学习JavaScript的六个思维技巧","slug":"js-learn","date":"2018-09-22T15:44:53.000Z","updated":"2018-09-22T16:09:58.900Z","comments":true,"path":"2018/09/22/js-learn/","link":"","permalink":"https://www.yangtao.site/2018/09/22/js-learn/","excerpt":"初始整理于慕课网手记高效学习JavaScript的六个思维技巧","text":"初始整理于慕课网手记高效学习JavaScript的六个思维技巧 更快学习JavaScript的六个思维技巧 当人们试图学习JavaScript或其他编程语言的时候，他们通常会遇到如下挑战。 1234567891. 一些概念让他们感到困惑，特别是如果之前学过其他类型的语言。2. 很难找到学习的时间（或者动力）去学习。3. 你很容易忘掉之前学到的东西。4. JavaScript工具太多并且经常更新，以至于很难找到学习的切入点。5. ... 幸运的是，这些难题最终能够被克服。在这篇文章，我将展示六个能够帮助你更快、更开心、更高效地学习JavaScript的六个思维技巧。 1、不要让对未来的忧虑干扰你现在的学习 有些JavaScript初学者会问刚开始要学习哪种框架，但是如果你还没能熟练使用原生JavaScript，你就不应该问这种问题。因为你会花很多时间研究各种框架而得不到进步。 走出这个陷阱的一个方法是制定一个学习路径图。例如，要成为前端开发，你的路径图可能是下图。在将来你能够使用HTML和CSS制作动态页面。 2、不要让自信骗你进入持续遗忘的陷阱快速理解一个概念会是JavaScript进步的最大阻碍，下面我将解释。 当你遇到一个知识点，而你好像理解了，你很可能抑制不住内心跳到下一个知识点的冲动。 现实可能是你会理解下一个知识点然后继续跳到下一个知识点。 但是，很快你会到达一个节点，在这个节点你发现自己已经忘了前面所学，于是你需要回过头复习，你快速瞟了一下之前所学然后又继续学习新的知识。 但是现在，你忘记了其他东西。 你一直重复这种继续-回顾-继续-回顾模式直到你发现自己完全迷失。 你开始沮丧，想要休息，然后当你开始重振旗鼓，却发现自己已经忘掉所有。 幸运的是，我们有两个应对上述问题的方法： 一次只学一样东西； 做练习——实际就是敲代码； 当你学习一个新的概念，你要将它实践出来，练习它，与它和善相处，甚至能够将它与其他概念联系到一起。 当你学习一个示例，最重要的是你要自己将代码敲出来，这样能帮助你吸收它。另外，一次只学一个东西能够帮助你巩固所学，因为记忆更少的东西更容易。 这个过程看起来貌似比阅读然后快速跳到下一个知识点要花费更长的时间，但是实际上它所花的时间更少，因为这样你就不需要频繁复习之前所学。我在好几个场合后才艰难的领悟到这个道理。 3、使用正确的思维方式练习很多人认为敲代码是烦人的重复性工作，所以他们通常会跳过这个步骤试着寻找捷径。如果你试图为JavaScript练习寻找捷径，你将会为此花费更多的时间。 但是我们如何才能使得敲代码更加的有趣，使得我们愿意去敲代码呢？ 试着改变为下面的思维模式： 如果你刚学了一个JavaScript概念，然而你被告知不能使用它，对此你感觉如何？个人来说我会感到有点恼火，特别是为了弄懂它我花费了宝贵的时间。这就像是一个小孩得到了一个新的玩具，但却被限制不能玩它。 当你学习JavaScript的新知识，试着将这个知识点视作一个新玩具，例如新车、一双新鞋、或任何你觉得值得有趣的东西。然后，不要把敲代码当成工作，将敲代码视作你正在玩游戏。你正在使用刚学的技能做一些很酷的事情。给自己惊喜，把成果展示给你的朋友。 带着游戏的思维模式你将学得更快，将记忆的更牢，同时你将体会到更多乐趣。 4、使用Facebook技巧为编程腾时间 人们遇到的一个普遍问题是，他们通常找不到时间去敲代码。通常，这些人会花好几个小时浏览例如Facebook、YouTube、Wikipedia或者Reddit这样的网站。无论你是否符合上述描述，我们都能从中学到一些东西。 我当然有时间只浏览Facebook一会儿，但通常我会在上面待好几个小时浏览往返。这是如何发生的？我认为原因在于，刚开始我并没打算花在这上面花费那么多时间。开始行动是做一件事情最困难的部分，所以将目标设定的足够小能够帮助我们进入状态。如果有人问我是不是打算花几个小时浏览Facebook，我会回答不，因为我没有时间。然而，对于仅仅尝试一下我是能够接受的，这也是我能够沉浸其中的方法。 好消息是，你能够对敲代码运用同样的心理技巧。 不要计划花几个小时敲代码，因为你会发现自己没有时间。 相反的，告诉自己只敲三分钟代码。这样你就不需要为寻找敲代码的时间烦心。 5、思考的更慢你将学得更快 这一条听起来违反直觉，所以下面我将用一个故事来解释。 我的一个朋友又一次对JavaScript的一个特性感到困惑。我让他将他知道的解释给我听，然后告诉我哪儿让他困惑。当它向我解释代码，我发现他在跳步。 “等会儿！”我说道。“慢慢来，然后将这些一步步解释给我听。” 我的朋友直接将整个代码的功能总结给我听。 我再次让他暂停。“你还是在跳步。再解释一次，这次我需要你一步步将每一行代码发生了什么解释给我听。” 这一次，我的朋友能够更好的解释代码是如何运行的。关键在于他花时间去理解每一行代码而不是试图一下理解所有。 在上述这种案例中，思考的更慢实际上让你学得更快。 6、在写复杂代码前先用简单语言写下 如果你要写的代码是复杂并且不常见的，先用简单语言将代码写下。这样，你能够你能够在真正写之前知道自己要做什么。下面是使用这个方法的两个好处： 你将更容易更快速的写代码，因为你不需要时刻停下来思考自己将要怎么做。 由于你知道代码要干什么，能够更好的排除错误。 总结 我们已经讲了好几个更快速学习JavaScript的方法，但是你也能将上述方法运用于学习其他东西。下面是上述方法的概括： 1234567（1）、不要再想将要学什么，沉浸于现在；（2）、通过把新技能当做玩具使得练习更有趣；（3）、就像浏览Facebook、YouTube之类的网站一样，在敲代码前告诉自己只敲几分钟，这样你就拥有了敲代码的时间；（4）、慢下来，小步向前，你将学得更快。 本文转载自：众成翻译 译者：Ryan 链接：http://www.zcfy.cc/article/436","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/tags/JavaScript/"}]},{"title":"从零制作edm邮件，需要了解的一些规则","slug":"edm-01","date":"2018-09-19T02:12:00.000Z","updated":"2019-12-03T10:15:30.082Z","comments":true,"path":"2018/09/19/edm-01/","link":"","permalink":"https://www.yangtao.site/2018/09/19/edm-01/","excerpt":"因为电子邮件客户端预览窗口通常只是一小部分屏幕宽度，你最好上你的电子邮件的宽度设计在大约600px。没有人喜欢水平滚动条","text":"因为电子邮件客户端预览窗口通常只是一小部分屏幕宽度，你最好上你的电子邮件的宽度设计在大约600px。没有人喜欢水平滚动条 一、初见table &lt;table&gt; 标签定义 HTML 表格 简单的 HTML 表格由 table 元素以及一个或多个 tr、th 或 td 元素组成 tr(table row) 元素定义表格行，th(table head) 元素定义表头，td(table data) 元素定义表格单元 更复杂的 HTML 表格也可能包括 caption、col、colgroup、thead、tfoot 以及 tbody 元素 HTML table 标签 table属性 border — 规定表格边框的宽度 align — 规定表格相对周围元素的对齐方式 (left,center,right) valign — 垂直，默认是valign=&quot;middle&quot;，但是会修改为valign=&quot;top&quot; cellspacing — 规定单元格之间的空间 cellpadding — 规定单元边沿与其内容之间的空白 width — 规定表格的宽度 height — 规定表格的高度 background — 背景图像 bgcolor — 背景颜色 1234567&lt;table border=\"1\" width=\"600\" align=\"center\" bgcolor=\"#cccccc\" cellspacing=\"10\" cellpadding=\"20\"&gt;&lt;tr&gt; &lt;td&gt;语文&lt;/td&gt; &lt;td&gt;数学&lt;/td&gt; &lt;td&gt;英语&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; style width、height font-family font-size font-weight color line-height border background-color background-image vertical-align 标签行内元素 &lt;a href=&quot;http://www.eefocus.com&quot; target=&quot;_blank&quot;&gt; &lt;img src=&quot;http://baidu.com/hao123.png&quot; alt=&quot;hao123图片&quot;&gt; &lt;span&gt;我也可以是一段话，只是没法自主设置宽度而已&lt;/span&gt; 块级元素 &lt;p&gt;我是一段话...&lt;/p&gt; 二、了解基本格式Area-1 HTML 编码格式：utf-8 页面尽量保持宽（600px~800px）、高（1024px），整体邮件不要太大，比如15k（各个邮箱不同）左右，不然很容易走垃圾邮箱 样式使用行间样式，如：&lt;td style=&quot;font-family:Arial, Helvetica, sans-serif;font-size:12px;color:#000000;&quot; &gt;文字&lt;/td&gt;其他的方式会被无视 Area-2 font-family 属性不能为空 使用&lt;table&gt;布局，居中显示使用align=&quot;center 不使用 table 以外的 body、meta和html之类的标签，部分邮箱系统会把这些过滤掉 不使用 flash、java、javascript、frames、iframe、activeX 以及 dhtml 不要出现onmouseover、onmouseout，即使设定了，也会被过滤掉 Area-3 区域与区域之间的上下、左右之间的空白间隙，使用标准的&lt;td width=15&gt;&amp;nbsp;&lt;/td&gt;或&lt;td height=&quot;15&quot;&gt;&amp;nbsp;&lt;/td&gt;，不要使用padding=&quot;15px&quot; — 防止各个邮箱的解析不同 图片 图片的每个属性都要定义完整，如：&lt;img src=&quot;http://www.eefocus.com/logo.png&quot; style=&quot;vertical-align:top;display:block;&quot; width=&quot;210&quot; height=&quot;100&quot; alt=&quot;logo&quot;/&gt; 定义style=&quot;vertical-align:top;&quot; — 防止图片之间会有缝隙、变形等显示异常的情况 定义display:block — 解决Outlook电子邮件客户中图片底部增加空白间距的问题 限制每张图片的大小width=&quot;200 height=&quot;200&quot;或者style=&quot;width:200px;height:200px;&quot; 添加每张图片alt属性，如：alt=&quot;我是干啥的&quot; — 防止图片无法加载，也可以知晓这是做什么的 图片格式使用jpg、png，尽量不要使用gif 地址使用绝对路径（以http/https开头的） 尽量不使用背景图片background-image（Outlook不显示，但是可以显示背景色：bgColor=&quot;f3f3f3&quot;），直接使用图片&lt;img src=&quot;&quot;&gt; 为了保持各个邮箱的一致性，尽量使用图片，大图可拆分成几张小图拼接，每张图片不要太大（15K以内） 链接 地址绝对路径：&lt;a href=&quot;http://www.eefocus.com&quot;&gt;Logo Plus&lt;/a&gt; 地址不可过长（超过255个字符），尽量简短 数量尽量不超过10个 地址不要使用特殊符号，避免解析错误 文字中出现链接地址，被屏蔽的风险比较高，一般是文字+链接、图片+链接 不要使用地图功能链接，很容易被划分为垃圾邮箱 为避免用户收到的邮件图片无法浏览，请制作一份和邮件内容一样的web 页面，然后在邮件顶部写一句话：“如果您无法查看邮件内容，请点击这里”， 链接到放有同样内容的web页面 Outlook邮箱规则 内敛元素的padding无效、vertical-align不能被识别，可定义在td 别想着继承的事儿，某一块的样式都单独设置，比如链接样式，文字样式等 p标签的width不起作用，可定义在td p标签的字体颜色会被覆盖，可单独使用诸如span等重新设置字体颜色，或者使用style定义在td 当设置 &lt;img align=&quot;left&quot; /&gt; 或 &lt;img align=&quot;right&quot; /&gt;时，图片会脱离文档流，在其父元素设置了 margin 或 padding 的话，都无法使其下移，左移或右移 line-height默认为1.6 #FFFFFF关于颜色值，使用六位并且大写，使用简写在outlook下被忽略（很神奇） 关于链接，可以单独设置：123456789101112131415161718&lt;style&gt; a:link, a:visited &#123; color: white; text-decoration: none; &#125; a:hover, a:active &#123; text-decoration: none; color: white; &#125; a:focus &#123; text-decoration: none; color: white; &#125; &lt;/style&gt; Tips 避免使用margin padding等属性，定义宽高的属性放在td，定义样式放在p或者span等标签内 一般而言，指定表格单元格宽度要比指定表格自身宽度要好 使用bgcolor来替找style=”background:”,在电子邮件客户端中HTML属性要比CSS样式更好，但是优先等级依旧是：css样式&gt;html属性 新浪邮箱会忽略掉cellpadding，一般设置为0三、悟道邮件设计 电子邮件的设计过程是非常纠结的，为了美还得考虑制作过程的煎熬保持简单 当设计一个HTML电子邮件时，请记住保持简单，编码的时候考虑坚持两列布局，这样能为您省去很多麻烦的事情减少图像的使用甚至避免使用 记住你的设计不能太花哨，因为Outlook不支持背景图像窄屏最好 因为电子邮件客户端预览窗口通常只是一小部分屏幕宽度，你最好上你的电子邮件的宽度设计在大约600px。没有人喜欢水平滚动条保持一致 记住，我们使用固定的元素属性cellpadding和cellspacing设置单元格的边距和单元格的间距。这样保持元素之间的间距一致性是正确的与谨慎的 节选自：开始制作HTML Email 之邮件设计 邮件制作 电子邮件的制作过程是非常煎熬的，一不小心就乱了、乱了。邮件测试 电子邮件的测试过程是非常痛苦的，也是最让人奔溃的，因为你很有可能拆了西墙补东墙 最后我们看一下测试邮件：效果图","categories":[{"name":"Html","slug":"Html","permalink":"https://www.yangtao.site/categories/Html/"}],"tags":[{"name":"EDM","slug":"EDM","permalink":"https://www.yangtao.site/tags/EDM/"}]},{"title":"Mac 终端简易学习总结","slug":"macos-bash","date":"2018-08-13T01:07:38.000Z","updated":"2019-11-11T07:05:39.901Z","comments":true,"path":"2018/08/13/macos-bash/","link":"","permalink":"https://www.yangtao.site/2018/08/13/macos-bash/","excerpt":"一、目录基本操作1. pwd — 获取当前所在路径123yangtaodeMacBook-Pro:test yangtao$ pwd/Users/yangtao/Desktop/文件创建/test","text":"一、目录基本操作1. pwd — 获取当前所在路径123yangtaodeMacBook-Pro:test yangtao$ pwd/Users/yangtao/Desktop/文件创建/test 2. ls — 列出当前目录下的所有文件 ls -l — 用长格式列出来 ls -a — 列出文件（包括隐藏的文件） ls -al — 以长格式列出文件（包括隐藏的文件） 3. cd — 目录间的切换可以使用tab键补全目录名称，将文件拖入终端，可以显示该文件的目录 cd — (无参数)返回 home 目录 cd ~ — 返回 home 目录，可以使用cd ~/Music快速到达该目录，使用cd ~Guest/进入 Guest 用户的 home 目录 cd - — 返回上一次操作的目录，可与当前目录进行切换 cd .. — 返回上一层目录，..表示上一层目录，而.表示当前目录，如./Music，表示当前目录下的 Music 文件 4. mkdir 文件名 — （make dir）新建文件夹5. rmdir 文件名 — （remove dir）删除文件夹如果文件夹内不为空，则无法用 rmdir 删除文件夹 6. rm 文件名 — （remove dir）删除文件注意：用rm删除掉的文件是无法从回收站中找回的！而且不能使用 rm 来删除文件夹 7. mv 原文件 目标目录/新文件名 — 移动把文件从一个地方移到另一个地方，但是当没有给出另外一个目录时，移动的现象就是为其更改了名字 8. cp 带目录文件 目标目录 — 复制粘贴9. man 命令 — 查看使用手册10. touch — 创建文件11. cat — 查看文件内容二、历史操作1. 向上（向下）箭头查看上一个（下一个）命令，可以一直向前查看之前执行过的命令 2. !l — 找出与你最近一次的 l 开头的命令，并执行3. history — 查看之前执行过命令的历史记录三、进程管理操作1. ps — 查看当前终端运行的程序1234yangtaodeMacBook-Pro:test yangtao$ ps PID TTY TIME CMD19083 ttys000 0:00.40 -bash 2. ps ax —列出这台电脑正在运行的所有程序12345620008 ?? S 0:00.12 /System/Library/Frameworks/QuickLook.framework/Resources/quicklookd.app/Contents/MacOS/quicklookd19082 s000 Ss 0:00.02 login -pf yangtao19083 s000 S 0:00.40 -bash20079 s000 R+ 0:00.00 ps axyangtaodeMacBook-Pro:test yangtao$ 3. top — 显示这台计算机上有哪些进程，显示内存、CPU、负载等1234PID COMMAND %CPU TIME #TH #WQ #PORT MEM PURG CMPRS PGRP PPID STATE BOOSTS %CPU_ME %CPU_OTHRS UID FAULTS COW20088 top 4.1 00:00.99 1/1 0 23 6724K 0B 0B 20088 19083 running *0[1] 0.00000 0.00000 0 7185+ 10520087 AGSService 0.0 00:00.03 2 1 36 1716K 0B 0B 20087 1 sleeping *0[1] 0.00000 0.00000 0 3076 4. kill [PID] — 结束指定进程 ID 的进程具体做法： 先使用 top 命令查看想要结束进程的 PID，然后使用命令kill [PID] Tips： 如果遇到无法杀掉的进程，输入命令sudo kill -9 [PID] (伪装超级管理员，强迫杀掉该进程)，接着输入自己用户的密码（前提是自己这个用户具有 sudo 的资格） 四、万能的 grep 操作1. grep 800 log.txt — 从 log.txt 中找出 800 位置的数据2. grep -n 800 log.txt — 从 log.txt 中找出 800 位置的数据,并在前面加上行号3. grep (-n) Hello * (是否加上行号) — 从当前目录下的所有文件中找出出现过 Hello 的文件4. ls /usr/bin | grep ls — 查看/usr/bin 目录下面带 ls 的目录5. ls /usr/bin | grep ls | wc — 计算出单词的数量1234yangtaodeMacBook-Pro:test yangtao$ ls /usr/bin | grep ls | wc 16 16 124# 16行 16个单词 124个字符 五、环境变量操作1. set | grep PATH — 查看环境变量123yangtaodeMacBook-Pro:~ yangtao$ set | grep PATHPATH=/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin 2. set | grep PATH — 将其他文件夹路径（本机用户下面的 bin 目录）添加到 PATH这样做只是一次性的，也就是说在当前终端，是可以直接生效的，但是当你关闭后，重新打开终端，这个操作是不被保存的。 在/etc/profile这个文件是任何人打开终端都会执行的，是系统级的 profile。 如果我们想自定义自己的 profile，可以在自己的家目录下新建文件命名为：.profile，这个文件会在你打开终端时自动执行。 我们将刚刚的命令 2 输入其中，然后保存退出（vim 下使用:wq）这样的话，在我们刚刚已经登录的终端里面它还是不起作用的，假如你希望它可以立刻生效，你可以使用source命令。 3. source — 例如：source .profile使 Shell 读入指定的 Shell 程序文件并依次执行文件中的所有语句，通常用于重新执行刚修改的初始化文件，使之立即生效，而不必注销并重新登录 六、网络配置操作1. ifconfig — 列出本机所有的网络设备以及其上面的配置，主要指的是 ip 地址和 mac 地址我的连的是 en5，它的状态时 active（最后一行），原文是 en4 1234567en5: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500 ether ac:de:48:00:11:22 inet6 fe80::aede:48ff:fe00:1122%en5 prefixlen 64 scopeid 0x7 nd6 options=201&lt;PERFORMNUD,DAD&gt; media: autoselect status: active 其他用法： ifconfig en4 down/up — 关闭（或打开）某个网络接口，比如 en4,一般需要管理员权限，所以需要在前面加 sudo 命令 sudo ifconfig en4 add 10.10.10.12 netmask 255.255.255.0 — 给 en4 加入别的网段 sudo ifconfig en4 delete 10.10.10.12 — 给 en4 删除指定网段 12345678# 临时修改MAC地址ifconfig en0 down // 关闭网卡设备（这里假设是en0）ifconfig en0 hw ether [MAC地址] // 修改MAC地址ifconfig en0 up // 重启网卡# 临时修改内网ip地址ifconfig en0 downifconfig en0 192.168.169.245 netmask 255.255.255.0 2. ping — 检测网络是否是连通状态3. netstat — 显示各种网络相关信息其他用法： netstat -l — 列出本机进行监听的端口 netstat -lt — 只列出 tcp 的连接，同理在 l 后面跟上 u 的话，将会列出各种 udp 的监听端口 netstat -s — 查看统计数据 netstat -p — 列出进程信息，你可以了解是哪一个程序在哪一个端口上做些什么事情 netstat -pc — 会显示出实时更新的进程信息 netstat -r — 查看路由表 netstat -i — 查看接口信息 详情参考Mac 终端学习系列","categories":[{"name":"系统","slug":"系统","permalink":"https://www.yangtao.site/categories/系统/"}],"tags":[{"name":"MacOS","slug":"MacOS","permalink":"https://www.yangtao.site/tags/MacOS/"},{"name":"终端","slug":"终端","permalink":"https://www.yangtao.site/tags/终端/"}]},{"title":"Git之本地拉取Github代码、修改远程URL","slug":"git-revert","date":"2018-08-09T12:11:45.000Z","updated":"2019-11-11T07:45:44.419Z","comments":true,"path":"2018/08/09/git-revert/","link":"","permalink":"https://www.yangtao.site/2018/08/09/git-revert/","excerpt":"","text":"12345Workspace：工作区Index / Stage：暂存区Repository：仓库区（或本地仓库）Remote：远程仓库 详细介绍如何使用git 博客推荐： 如何使用Git上传项目代码到github Git远程操作详解—阮一峰 常用 Git 命令清单—阮一峰 本地拉取仓库代码 — clone1git clone https://github.com/yangtao2o/yangtao2o.github.io.git 修改远程URL — remote123456git remote -v # 查看远程服务器地址和仓库名称git remote show origin # 查看远程服务器仓库状态git remote add origin https://github.com/yangtao2o/yangtao2o.github.io.git # 添加远程仓库地址git remote set-url origin https://github.com/..io.git # 设置远程仓库地址(用于修改远程仓库地址)git remote rename &lt;old name&gt; &lt;new name&gt; # 修改远程主机的名称git remote rm &lt;repository&gt; # 删除远程仓库 代码回滚 如果是在workspace，未git push，使用以下命令会清空工作目录中所有未提交的内容 12git reset --hard HEAD # 全部撤销git checkout -- hello.html # 只恢复hello.html文件 如果已提交，使用git revert，使用一次新的commit，来回滚要你要回滚的位置 1git revert HEAD 参考：Git的撤消操作 - 重置, 签出 和 撤消 使用过程中，遇到的一些问题 git pull时fatal:refusing to merge unrelated histories git pull --allow-unrelated-histories origin一般是我们自己创建的代码库，所以可以做任何的git pull or git push，但是如果我们引入了他人的代码库，就成了upstream，只能git fetch，通过fork到自己的仓库里，如同origin 关于fork、origin、upstream、clone之间的关系博文推荐： GitHub关于fork、origin、upstream、clone的藕断丝连 git submodule使用以及注意事项","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://www.yangtao.site/categories/开发工具/"}],"tags":[{"name":"git","slug":"git","permalink":"https://www.yangtao.site/tags/git/"}]},{"title":"macOS安装homebrew报错 LibreSSL SSL_read SSL_ERROR_SYSCALL errno 54","slug":"macos-brew","date":"2018-08-05T08:55:14.000Z","updated":"2019-03-13T14:05:04.601Z","comments":true,"path":"2018/08/05/macos-brew/","link":"","permalink":"https://www.yangtao.site/2018/08/05/macos-brew/","excerpt":"LibreSSL SSL_read: SSL_ERROR_SYSCALL, errno 54","text":"LibreSSL SSL_read: SSL_ERROR_SYSCALL, errno 54 # 安装12curl \"https://nodejs.org/dist/latest/node-$&#123;VERSION:-$(wget -qO- https://nodejs.org/dist/latest/ | sed -nE 's|.*&gt;node-(.*)\\.pkg&lt;/a&gt;.*|\\1|p')&#125;.pkg\" &gt; \"$HOME/Downloads/node-latest.pkg\" &amp;&amp; sudo installer -store -pkg \"$HOME/Downloads/node-latest.pkg\" -target \"/\" # 报错123456==&gt; Tapping homebrew/coreCloning into '/usr/local/Homebrew/Library/Taps/homebrew/homebrew-core'...fatal: unable to access 'https://github.com/Homebrew/homebrew-core/': LibreSSL SSL_read: SSL_ERROR_SYSCALL, errno 54Error: Failure while executing; `git clone https://github.com/Homebrew/homebrew-core /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core --depth=1` exited with 128.Error: Failure while executing; `/usr/local/bin/brew tap homebrew/core` exited with 1. # 解决： 执行下面这句命令，更换为中科院的镜像： 12git clone git://mirrors.ustc.edu.cn/homebrew-core.git/ /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core --depth=1 把homebrew-core的镜像地址也设为中科院的国内镜像 12345678cd \"$(brew --repo)\" git remote set-url origin https://mirrors.ustc.edu.cn/brew.gitcd \"$(brew --repo)/Library/Taps/homebrew/homebrew-core\" git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git 更新 1brew update 使用 1brew install node 参考 报错解决：macOS High Sierra10.13.3安装homebrew报错LibreSSL SSL_read: SSL_ERROR_SYSCALL, errno 54解决方法 Mac安装，简单实用，卸载homebrew详细教程","categories":[{"name":"系统","slug":"系统","permalink":"https://www.yangtao.site/categories/系统/"}],"tags":[{"name":"MacOS","slug":"MacOS","permalink":"https://www.yangtao.site/tags/MacOS/"},{"name":"Homebrew","slug":"Homebrew","permalink":"https://www.yangtao.site/tags/Homebrew/"}]},{"title":"macOS下node版本管理下载新版本时中断返回Segmentation fault 11","slug":"macos-node","date":"2018-08-05T08:52:58.000Z","updated":"2019-11-11T07:03:42.714Z","comments":true,"path":"2018/08/05/macos-node/","link":"","permalink":"https://www.yangtao.site/2018/08/05/macos-node/","excerpt":"前记：安装 node 的时候安装了最新版本，但是我需要指定某一个版本，所以安装了 n 模块，来进行版本切换，但是途中发生了报错：Segmentation fault：11，导致 npm 命令无法使用，由于使用的 macOS，大家都推荐 HomeBrew，于是连滚带爬地从一个坑跳到另一个坑，好疼啊…","text":"前记：安装 node 的时候安装了最新版本，但是我需要指定某一个版本，所以安装了 n 模块，来进行版本切换，但是途中发生了报错：Segmentation fault：11，导致 npm 命令无法使用，由于使用的 macOS，大家都推荐 HomeBrew，于是连滚带爬地从一个坑跳到另一个坑，好疼啊… n 模块 首先 n 模块不支持 Windows！！！ 安装：sudo npm install -g n 参考：node 版本更新的简便方法——神奇的 n 模块 版本切换：n，然后上下切换，圆点在哪儿就是哪个，但是问题两个或者多个都是灰色，即没有圆点，怎么办？ 这时，切回去使用node -v就会报错：Segmentation fault: 11 ，当然，npm 直接npm: command not found 解决：sudo n 8.1.3 参考：n 模块管理 node 版本遇到的问题 但是切换到 8.11.3，问题依旧存在，所以删除：sudo n rm 8.11.3 卸载 npm：sudo npm uninstall npm -g，然后去 node 官网重新下载8.11.3LTS，安装成功，但是使用n list，并未查看到此版本 于是，重新再走一遍：sudo n 8.11.3，成功。","categories":[{"name":"系统","slug":"系统","permalink":"https://www.yangtao.site/categories/系统/"}],"tags":[{"name":"MacOS","slug":"MacOS","permalink":"https://www.yangtao.site/tags/MacOS/"},{"name":"Nodejs","slug":"Nodejs","permalink":"https://www.yangtao.site/tags/Nodejs/"}]},{"title":"JavaScript算法初级练习","slug":"js-algo-1","date":"2018-08-01T07:43:10.000Z","updated":"2019-11-13T05:44:15.640Z","comments":true,"path":"2018/08/01/js-algo-1/","link":"","permalink":"https://www.yangtao.site/2018/08/01/js-algo-1/","excerpt":"# 需要定义一个最小值和一个最大值之间的随机数12345function ourFunction(ourMin, ourMax) &#123; return Math.floor(Math.random() * (ourMax - ourMin + 1)) + ourMin;&#125;ourFunction(1, 9);","text":"# 需要定义一个最小值和一个最大值之间的随机数12345function ourFunction(ourMin, ourMax) &#123; return Math.floor(Math.random() * (ourMax - ourMin + 1)) + ourMin;&#125;ourFunction(1, 9); # 计算一个整数的阶乘12345678910function factorialize(num) &#123; // 请把你的代码写在这里 if(num &lt;= 1) &#123; return 1; &#125; else &#123; return num *= factorialize(num - 1); &#125;&#125;factorialize(5); # 来一段回文 JavaScript算法练习： JavaScript中回文(Palindromes)处理 123456789101112131415161718192021222324252627//方法一function palindrome(str) &#123; // 请把你的代码写在这里 var re = /[\\W_]/g; var lowRegStr = str.toLowerCase().replace(re, ''); var reveRegStr = lowRegStr.split('').reverse().join(''); return lowRegStr == reveRegStr;&#125;palindrome(\"eye\");//方法二function palindrome(str) &#123; // 请把你的代码写在这里 var re = /[\\W_]/g; var lowRegStr = str.toLowerCase().replace(re, ''); for(var i=0, l=lowRegStr.length; i&lt;l/2; i++) &#123; if(lowRegStr[i] != lowRegStr[l - 1 -i]) &#123; return false; &#125; &#125; return true;&#125;palindrome(\"eye\"); # 在句子中找出最长的单词，并返回它的长度。 js 数组排序和算法排序 12345678910111213function findLongestWord(str) &#123; var strArr = str = str.split(' '); var newArr = []; for(var i=0;i&lt;strArr.length; i++) &#123; newArr.push(strArr[i].length); &#125; newArr.sort(function(a, b) &#123; return b - a; &#125;); return newArr[0];&#125;findLongestWord(\"What if we try a super-long word such as otorhinolaryngology\"); # 确保字符串的每个单词首字母都大写，其余部分小写。12345678910111213141516function titleCase(str) &#123; var strArr = str.split(' '); var newStrArr = []; var newStr = ''; for(var i=0; i&lt;strArr.length; i++) &#123; newStr = strArr[i][0].toUpperCase(); newStr += strArr[i].substr(1).toLowerCase(); newStrArr.push(newStr); &#125; newStrArr = newStrArr.join(' '); return newStrArr;&#125;titleCase(\"I'm a little tea pot\"); # 找出多个数组中的最大数12345678910111213function largestOfFour(arr) &#123; var newArr = []; var num = []; for(var i=0; i&lt;arr.length; i++) &#123; num = arr[i].sort(function(a, b) &#123; return b - a; &#125;); newArr.push(num[0]); &#125; return newArr;&#125;largestOfFour([[4, 5, 1, 3], [13, 27, 18, 26], [32, 35, 37, 39], [1000, 1001, 857, 1]]); # 判断一个字符串(str)是否以指定的字符串(target)结尾。123456789101112function confirmEnding(str, target) &#123; var len = target.length; if(str.substr(-len) == target) &#123; return true; &#125; else &#123; return false; &#125; &#125;confirmEnding(\"He has to give me a new name\", \"name\");confirmEnding(\"Bastian\", \"n\"); # 重复一个指定的字符串 num次，如果num是一个负数则返回一个空字符串。12345678910111213141516function repeat(str, num) &#123; // 请把你的代码写在这里 var newArr = []; var newStr = ''; if(num &lt; 0) &#123; newStr = ''; &#125; else &#123; for(var i=0; i&lt;num; i++) &#123; newArr.push(str); &#125; newStr = newArr.join(''); &#125; return newStr;&#125;repeat(\"abc\", 4); # 如果字符串的长度比指定的参数num长… 如果字符串的长度比指定的参数num长，则把多余的部分用…来表示。切记，插入到字符串尾部的三个点号也会计入字符串的长度。但是，如果指定的参数num小于或等于3，则添加的三个点号不会计入字符串的长度。 12345678910111213function truncate(str, num) &#123; var newStr=''; if(num &gt;= str.length) &#123; newStr = str.slice(0); &#125; else if(num &gt; 3) &#123; newStr = str.slice(0, num-3) + '...'; &#125; else &#123; newStr = str.slice(0, num) + '...'; &#125; return newStr;&#125;truncate(\"A-tisket a-tasket A green and yellow basket\", 11); # 把一个数组arr按照指定的数组大小size分割成若干个数组块。 js将一位数组分割成每三个一组 123456789function chunk(arr, size) &#123; var newArr = []; for(var i=0; i&lt;arr.length; i+=size) &#123; newArr.push(arr.slice(i, i+size)); &#125; return newArr;&#125;chunk([\"a\", \"b\", \"c\", \"d\"], 2); # 返回一个数组被截断n个元素后还剩余的元素，截断从索引0开始。123456function slasher(arr, howMany) &#123; arr.splice(0, howMany); return arr;&#125;slasher([1, 2, 3], 2); # 如果数组第一个字符串元素包含了第二个字符串元素的所有字符，函数返回true。123456789101112function mutation(arr) &#123; var str1 = arr[0].toLowerCase(); var str2 = arr[1].toLowerCase(); for(var i=0; i&lt;str2.length; i++) &#123; if(str1.indexOf(str2[i]) == -1) &#123; return false; &#125; &#125; return true;&#125;mutation([\"hello\", \"hey\"]); # 删除数组中的所有假值。1234567891011function bouncer(arr) &#123; var newArr = []; newArr = arr.filter(function(val) &#123; if(val !== (undefined &amp;&amp; null &amp;&amp; \"\" &amp;&amp; NaN &amp;&amp; false &amp;&amp; 0)) &#123; return val; &#125; &#125;); return newArr;&#125;bouncer([7, \"ate\", \"\", false, 9]); # 数组排序并找出元素索引，先给数组排序，然后找到指定的值在数组的位置，最后返回位置对应的索引。123456789function where(arr, num) &#123; arr.push(num); arr.sort(function(a, b) &#123; return a-b; &#125;); return arr.indexOf(num);&#125;where([40, 60], 50); # 实现一个摧毁(destroyer)函数，第一个参数是待摧毁的数组，其余的参数是待摧毁的值。 FCC–Seek and Destroy（摧毁数组） Seek and Destroy(算法) 12345678910111213function destroyer(arr) &#123; var newArr = []; var arg = arguments; for(var i=1; i&lt;arg.length; i++) &#123; newArr.push(arg[i]); &#125; arr = arr.filter(function(val) &#123; return newArr.indexOf(val) &lt; 0; &#125;); return arr;&#125;destroyer([1, 2, 3, 1, 2, 3], 2, 3); 发表于慕课网手记 题目来自： FreeCodeCamp BasicAlgorithmScripting参考资料： JavaScript标准库","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/tags/JavaScript/"},{"name":"JavaScript算法","slug":"JavaScript算法","permalink":"https://www.yangtao.site/tags/JavaScript算法/"}]},{"title":"Github报错fatal unable to access No such file or directory","slug":"github-01","date":"2018-07-30T11:21:43.000Z","updated":"2019-03-13T14:01:42.357Z","comments":true,"path":"2018/07/30/github-01/","link":"","permalink":"https://www.yangtao.site/2018/07/30/github-01/","excerpt":"之前有安装过github旧版，一直正常，后来更新了新版，但是git pull的时候如有如下报错：","text":"之前有安装过github旧版，一直正常，后来更新了新版，但是git pull的时候如有如下报错： 1fatal: unable to access 'https://github.com/eefocus/deploy.git/': schannel: failed to open CA file 'C:/Users/Administrator/AppData/Local/GitHubDesktop/app-1.2.3/resources/app/git/mingw64/bin/curl-ca-bundle.crt': No such file or directory 找到C:\\ProgramData\\Git\\config，打开，修改sslCAinfo（路径得看自己文件相对应的位置）如下： 123456789101112131415161718192021[core] symlinks = true autocrlf = true fscache = true[color] diff = auto status = auto branch = auto interactive = true[pack][help] format = html[https] sslCAinfo = C:/Users/Administrator/AppData/Local/GitHubDesktop/app-1.2.6/resources/app/git/mingw64/ssl/certs/curl-ca-bundle.crt[sendemail] smtpserver = /bin/msmtp.exe[diff &quot;astextplain&quot;] textconv = astextplain[rebase] autosquash = true 重点提示：默认的是[http]，如果有必要你需要改成[https] 如果找不到C:\\ProgramData文件（我的是win10），在查看下将隐藏的项目打个勾 参考：GitHub Desktop报错fatal: unable to access ‘https://github.com……: schannel: failed to open CA file ‘C:/Users……bundle.crt’: No such file or directory的解决办法","categories":[{"name":"开发工具","slug":"开发工具","permalink":"https://www.yangtao.site/categories/开发工具/"}],"tags":[{"name":"开发工具","slug":"开发工具","permalink":"https://www.yangtao.site/tags/开发工具/"},{"name":"github","slug":"github","permalink":"https://www.yangtao.site/tags/github/"}]},{"title":"前端学习资料峡谷","slug":"dev-data","date":"2018-07-06T07:12:00.000Z","updated":"2019-12-03T10:24:08.258Z","comments":true,"path":"2018/07/06/dev-data/","link":"","permalink":"https://www.yangtao.site/2018/07/06/dev-data/","excerpt":"整理 2017-2018 的前端学习资料","text":"整理 2017-2018 的前端学习资料 学习资料站网站 (2017)个人分享–web 前端学习资源分享 学习 Web 开发 Web 开发者指南 教程 W3school W3C WebGL 中文网 JavaScript ECMAScript 6 入门 JavaScript 怎么学 JavaScript？ 10 个最佳的 JavaScript 风格指南 框架、库 前端框架、资料汇集 Lodash— 是一个一致性、模块化、高性能的 JavaScript 实用工具库。 Headroom.js— 为页面顶部多留些空间。在不需要页头时将其隐藏。 iCheck—增强复选框和单选按钮 Three.js— 是 JavaScript 编写的 WebGL 第三方库。提供了非常多的 3D 显示功能。 开发工具 高质量的 Git 中文教程—该 Wiki 的编者非常认真细致地总结和翻译了许多 Github 知识和技巧 如何高效利用 GitHub Git - 简易指南 全面理解 Git Grunt—项目构建工具 Gulp—用自动化构建工具增强你的工作流程！ Webpack—前端资源模块化管理和打包工具 入门 Webpack，看这篇就够了 博客 张鑫旭 廖雪峰的官方网站 阮一峰的网络日志之 JavaScript 网络 HTTPS 工作原理和 TCP 握手机制 快速查找区 正则表达式特殊字符 学习书籍 JavaScript 经典实例 慕课网手记归纳《JavaScript 经典实例》之 JS 不只是简单的构件块 FreeCodeCamp 慕课网发布手记 JavaScript 算法初级练习 个人手记集锦 慕课网手记 前端网笔记","categories":[{"name":"Web","slug":"Web","permalink":"https://www.yangtao.site/categories/Web/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://www.yangtao.site/tags/前端/"},{"name":"前端学习资料","slug":"前端学习资料","permalink":"https://www.yangtao.site/tags/前端学习资料/"}]},{"title":"Hexo常用命令集合","slug":"hexo-order","date":"2018-07-06T06:59:59.000Z","updated":"2019-03-13T14:02:49.550Z","comments":true,"path":"2018/07/06/hexo-order/","link":"","permalink":"https://www.yangtao.site/2018/07/06/hexo-order/","excerpt":"简写 hexo n “我的博客” hexo new “我的博客” #新建文章 hexo p hexo publish hexo g hexo generate #生成 hexo s hexo server #启动服务预览 hexo d hexo deploy #部署","text":"简写 hexo n “我的博客” hexo new “我的博客” #新建文章 hexo p hexo publish hexo g hexo generate #生成 hexo s hexo server #启动服务预览 hexo d hexo deploy #部署 服务器 hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。 hexo server -s #静态模式 hexo server -p 5000 #更改端口 hexo server -i 192.168.1.1 #自定义 IP hexo clean #清除缓存 网页正常情况下可以忽略此条命令 hexo g #生成静态网页 hexo d #开始部署 监视文件变动 hexo generate #使用 Hexo 生成静态文件快速而且简单 hexo generate –watch #监视文件变动 完成后部署（两个命令的作用是相同的） 草稿 hexo generate –deploy hexo publish [layout] hexo deploy –generate … hexo deploy -g … hexo server -g … 模版 hexo new “postName” #新建文章 hexo new page “pageName” #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server） hexo deploy #将.deploy目录部署到GitHub hexo new [layout] .. hexo new photo “My Gallery” .. hexo new “Hello World” –lang tw .. 参考 :Hexo常用命令笔记","categories":[{"name":"博客","slug":"博客","permalink":"https://www.yangtao.site/categories/博客/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.yangtao.site/tags/Hexo/"}]},{"title":"关于使用Hexo主题Yilia中碰到的问题一二","slug":"hexo-yilia","date":"2018-04-08T14:11:24.000Z","updated":"2019-11-13T05:48:01.946Z","comments":true,"path":"2018/04/08/hexo-yilia/","link":"","permalink":"https://www.yangtao.site/2018/04/08/hexo-yilia/","excerpt":"关于使用主题 Yilia的一些问题的集合地：Issues 首推：从零开始制作 Hexo 主题","text":"关于使用主题 Yilia的一些问题的集合地：Issues 首推：从零开始制作 Hexo 主题 Q1：主页如何截取文本长度？ 在需要截断的位置使用 &lt;!-- More --&gt; 即可 Q2：如何设置多个标签？ tags: [Hexo,Theme]，参考此处 Q3：更换主题的时候报错 一般是由于主题配置文件中的 key: value前后出现了空格，或者之间没有空格导致的 Q4：如何创建 about 等页面？如何创建自定义页面？ hexo new page &quot;about&quot; 参考_ hexo 的 Next 创建 tags _ Hexo 自定义页面的方法 其他 选择 favicon：easyicon","categories":[{"name":"博客","slug":"博客","permalink":"https://www.yangtao.site/categories/博客/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.yangtao.site/tags/Hexo/"}]},{"title":"使用Hexo+Github搭建自己的个人网站","slug":"hexo","date":"2018-04-08T14:03:05.000Z","updated":"2019-03-13T14:03:00.821Z","comments":true,"path":"2018/04/08/hexo/","link":"","permalink":"https://www.yangtao.site/2018/04/08/hexo/","excerpt":"Hexo 官方文档","text":"Hexo 官方文档 将纯文本转化为静态网站和博客框架：jekyll 参考网站 快速低成本的搭建一个马马虎虎的博客 Hux Blog一生想做浪漫极客 教你定制Hexo的landscape打造自己的主题 【实用技能】使用github+Hexo人人都能拥有一个博客 GitHub+Hexo 搭建个人网站详细教程 使用github page + hexo3.0 搭建个人博客，加绑定域名。 【很详细】hexo从零开始到搭建完整 主题推荐 合集：Themes|Hexo Hexo博客主题推荐 hexo-theme-yilia Yelee —— 简而不减 Hexo 双栏博客主题 Material Theme Haojen ‘s Blog Anisina 中文使用教程 DaraW Hacker laughing http://www.ccblog.win/ Hacker 加载速度快列表页：A simple &amp; beautiful &amp; fast theme for Hexo 偏向Vue：Vexo 设计类：Mic_Theme 酷炫类： hexo-theme-ochuunn Archer 扁平化类：A simple &amp; beautiful &amp; fast theme for Hexo hexo-theme-skapp 简洁、明了 hexo-theme-huxblog A plain theme for Hexo — 比较个性化 DARAW hexo-theme-gandalfr Even 卡片式：Material X博客 MOxFIVE 问题 hexo+Github Page搭建的博客无法加载样式表？ hexo githubpage 初始化 并解决同步静态页面问题 Changing a remote’s URL","categories":[{"name":"博客","slug":"博客","permalink":"https://www.yangtao.site/categories/博客/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://www.yangtao.site/tags/Hexo/"}]},{"title":"学习《JavaScript经典实例》之第3章","slug":"js-chapter-3","date":"2018-04-08T13:47:57.000Z","updated":"2018-09-22T10:37:49.126Z","comments":true,"path":"2018/04/08/js-chapter-3/","link":"","permalink":"https://www.yangtao.site/2018/04/08/js-chapter-3/","excerpt":"第3章 JavaScript的构建块","text":"第3章 JavaScript的构建块 3种基本的创建函数方式： 声明式函数 匿名函数或函数构造函数 函数字面值或函数表达式 3.1 放置函数并提升 声明式函数，可以放置在代码中的任何位置；函数表达式，必须将其放置在使用函数的位置之前 12345678910111213141516171819// 在声明一个变量之前打印aconsole.log('a', a); //undefinedvar a;// 在声明一个变量并赋值console.log('aa', aa); //undefinedvar aa = 1;// 声明变量发生了提升，但是赋值并没有，赋值是在相应的位置发生的// 声明式函数，在访问该函数之前，提升将确保把函数声明移动到当前作用域的顶部console.log(mytest()); //successfunction mytest() &#123; return 'success';&#125;// 使用函数表达式就会报错，变量可能声明了，但没有实例化，但是你的代码试图将这个变量当做一个函数对待console.log(mytest2()); //TypeError: mytest2 is not a functionvar mytest2 = function() &#123; return 'success2';&#125; 3.2 把一个函数当做参数传递给另一个函数123456function otherFunction(x, y, z) &#123; x(y, z);&#125;// 可以像传递一个命名的变量一样，将一个函数作为参数传递给另一个函数var param = function func(a1, a2) &#123; alert(a1 + \" \" + a2); &#125;;otherFunction(param, \"Hello\", \"World\"); 函数式编程和JavaScript 高阶函数： 一个函数接受另一个函数作为参数，或者返回一个函数，或者两者都具备 函数式编程： 对应用程序复杂性进行抽象的一种方式，使用整齐、干净的函数调用替代了复杂的循环和条件语句（代码可读性高） 比如：将数组中的所有数字相加 12345678910111213// for循环相加var nums = [1, 34, 3, 15, 4, 18];var sum = 0;for(var i = 0; i &lt; nums.length; i++) &#123; sum += nums[i];&#125;console.log('sum', sum); //75var nums2 = [1, 34, 3, 15, 4, 18];var sum2 = nums2.reduce(function(n1, n2) &#123; return n1 + n2;&#125;);console.log('sum2', sum2); //75 arr.reduce([callback, initialValue]) 方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始缩减，最终为一个值。 3.3 实现递归算法 想要实现一个函数，它递归地遍历一个数组并返回一个反向的数组字符串 缺点：递归很消耗内存 1234567891011121314151617181920212223242526272829// 阶乘function factorial(n) &#123; return n == 1 ? n : n * factorial(n - 1);&#125;console.log('阶乘', factorial(4)); // 24// 斐波那契var fibonacci = function(n) &#123; return n &lt; 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);&#125;console.log('斐波那契', fibonacci(10)); //55// 使用一个递归函数字面值来反转数组元素，从最大长度开始，每次迭代都将这个值自减// 当为 0 时，返回字符串var reverseArrary = function(x, index, str) &#123; return index == 0 ? str : reverseArrary(x, --index, (str += \" \" + x[index]));&#125;var arr = ['apple', 'orange', 'peach', 'lime'];var str = reverseArrary(arr, arr.length, \"\");console.log('str', str); //lime peach orange apple// 如果要反过来，按照顺序把数组连接为一个字符串var orderArray = function(x, i, str) &#123; return i == x.length - 1 ? str : orderArray(x, ++i, (str += x[i] + \" \"));&#125;var numArr = [1, 2, 3, 4];var numStr = orderArray(numArr, -1, \"\");console.log('numStr', numStr); //1 2 3 4 3.4 使用一个定时器和回调防止代码阻塞 在程序的输出中，3个外围的 console.log() 立即被处理了 队列中下一个事件是第一个 noBlock() 函数调用，其中又调用了 factorial() ，记录了其运行时候的活动，最后跟着回调函数的调用 第二次同样地调用了 callBack() 第三次调用 callBack() 的时候，回调函数中的调用针对第一次 callBack() ，并使用了第一次函数调用的最终结果：6 12345678910111213141516171819202122232425262728293031&lt;script type=\"text/javascript\"&gt;function factorial(n) &#123; console.log('n', n); return n == 1 ? 1 : n * factorial(n - 1);&#125;function noBlock(n, callback) &#123; setTimeout(function() &#123; var val = factorial(n); if(callback &amp;&amp; typeof callback == 'function') &#123; callback(val); &#125; &#125;, 0);&#125;console.log('Top of the morning to you');noBlock(3, function(n) &#123; console.log('first call ends width ' + n); noBlock(n, function(m) &#123; console.log('final result is ' + m); &#125;);&#125;);var tst = 0;for(var i = 0; i &lt; 10; i++) &#123; tst += i;&#125;console.log('value of tst is ' + tst);noBlock(4, function(n) &#123; console.log('end result is ' + n);&#125;);console.log('not doing too much');&lt;/script&gt; 待续~","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/tags/JavaScript/"},{"name":"JavaScript经典实例","slug":"JavaScript经典实例","permalink":"https://www.yangtao.site/tags/JavaScript经典实例/"}]},{"title":"学习《JavaScript经典实例》之第2章","slug":"js-chapter-2","date":"2018-04-08T13:46:50.000Z","updated":"2018-09-22T10:38:21.062Z","comments":true,"path":"2018/04/08/js-chapter-2/","link":"","permalink":"https://www.yangtao.site/2018/04/08/js-chapter-2/","excerpt":"第2章 JavaScript数组","text":"第2章 JavaScript数组 2.1 在数组中搜索 indexOf()、lastIndexOf() 12345var animals = new Array('dog', 'cat', 'seal', 'elephant', 'walrus', 'lion');var index = animals.indexOf('cat');var index2 = animals.lastIndexOf('lion');console.log('i',index); //1console.log('i2',index2); //5 findIndex() 方法返回传入一个测试条件（函数）符合条件的数组第一个元素位置。 12345var nums = [2, 4, 199, 80, 400, 30, 90];var over = nums.findIndex(function(ele) &#123; return (ele &gt;= 100);&#125;);console.log('nums',nums[over]); //199 2.2 用concat()和apply()将一个二维数组扁平化 concat() 方法用于连接两个或多个数组。该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本。 arrayObject.concat(arrayX,arrayX,......,arrayX) 1234567var fruitarray = [];fruitarray[0] = ['stranwberry', 'orange'];fruitarray[1] = ['lime', 'peach', 'banana'];fruitarray[2] = ['tangerine', 'apricot'];console.log('array',fruitarray.concat());var newArray = fruitarray.concat.apply([], fruitarray);console.log(newArray); apply()与call()的区别 如何理解和熟练运用js中的call及apply？ obj.call(thisObj, arg1, arg2, ...); obj.apply(thisObj, [arg1, arg2, ...]); call() &amp; apply()，动态改变this 1234567891011function add(a, b) &#123; console.log('add', this);&#125;function sum(a, b) &#123; console.log('sum', this);&#125;add(1, 2); //Windowsum(1, 2); //Windowadd.call(sum, 1, 2); //sum(a, b)sum.call(add, 1, 2); //add(a ,b) arguments装换为数组, 返回的是数组，但是arguments本身保持不变 12var arg = [].slice.call(arguments);// [].slice.call(document.getElementsByTagName('li')); 借用别人的方法 1234567891011var foo = &#123; name: 'jack', showName: function() &#123; console.log('this name:',this.name); &#125;&#125;var bar = &#123; name: 'rose'&#125;foo.showName(); //jackfoo.showName.call(bar); //rose 实现继承 1234var Student = function(name, age, high) &#123; Person.call(this, name, age); this.high = high;&#125; 封装对象保证this的指向 1234var _this = this;_this.$box.on('mousedown', function()) &#123; return _this.fndown.apply(_this);&#125; 2.3 删除或替换数组元素 splice() 方法与 slice() 方法的作用是不同的，splice() 方法会直接对数组进行修改。 123456789101112131415161718var animals = new Array('dog', 'cat', 'rabbit', 'pig', 'apple');// 从数组删除元素animals.splice(animals.indexOf('apple'), 1);console.log(animals); // [\"dog\", \"cat\", \"rabbit\", \"pig\"]// 替换animals.splice(animals.indexOf('pig'), 1, 'monkey');console.log(animals); //[\"dog\", \"cat\", \"rabbit\", \"monkey\"]// 使用循环和分割来替换和删除元素var charSets = [\"ab\", \"bb\", \"cd\", \"ab\", \"cc\", \"ab\", \"dd\", \"ab\"];while(charSets.indexOf('ab') != -1) &#123; charSets.splice(charSets.indexOf('ab'), 1, '**');&#125;console.log(charSets); //[\"**\", \"bb\", \"cd\", \"**\", \"cc\", \"**\", \"dd\", \"**\"]while(charSets.indexOf('**') != -1) &#123; charSets.splice(charSets.indexOf('**'), 1);&#125;console.log(charSets); //[\"bb\", \"cd\", \"cc\", \"dd\"] 2.4 提取一个数组中的一部分 不更改原数组，使用slice() 1234var animals = new Array('dog', 'cat', 'rabbit', 'pig', 'apple');var newAnimals = animals.slice(1, 2);console.log(animals); //[\"dog\", \"cat\", \"rabbit\", \"pig\", \"apple\"]console.log(newAnimals); //[\"cat\"] 2.5 对每一个数组元素应用一个函数 Array.prototype.forEach() 12345var charSets = [\"ab\", \"bb\", \"cd\", \"ab\", \"cc\", \"ab\", \"dd\", \"ab\"];charSets.forEach(function(element, index, array) &#123; if(element == 'ab') array[index] = '**';&#125;);console.log(charSets); //[\"**\", \"bb\", \"cd\", \"**\", \"cc\", \"**\", \"dd\", \"**\"] 2.6 使用forEach()和call()遍历querySelectorAll()的结果 querySelectorAll() 可以将forEach()强制和一个NodeList一起使用 1234var cells = document.querySelectorAll('td + td');[].forEach.call(cells, function(cell) &#123; sum += parseFloat(cell.firstChild.data);&#125;); 2.7 对数组中的每个元素执行一个函数并返回一个新数组 将一个十进制的数组转化为新的等价的十六进制数组 map()方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。 与forEach()不同，不会修改原数组，但是必须返回一个值 123456var decArray = [23, 3, 24, 45, 500, 9, 70];var hexArray = decArray.map(function(ele) &#123; return ele.toString(16);&#125;);console.log(decArray); //[23, 3, 24, 45, 500, 9, 70]console.log(hexArray); //[\"17\", \"3\", \"18\", \"2d\", \"1f4\", \"9\", \"46\"] 2.8 创建一个过滤后的数组 filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。 12345var charSet = ['**', 'bb', 'cc', '**', 'cd'];var newArray = charSet.filter(function(element, index, array) &#123; return element != \"**\";&#125;);console.log(newArray); //[\"bb\", \"cc\", \"cd\"] 2.9 验证数组内容 使用Array every()方法来检查每个元素是否符合给定的条件 some() 方法确保至少某些元素符合该条件 区别：every()方法只要函数返回一个false值，处理就会结束，而some()方法会继续测试每个元素，直至返回true，此时，不再验证其他元素，即可返回ture 123456789101112131415function testValue(element, index, array) &#123; var testExp = /^[a-zA-Z]+$/; return testExp.test(element);&#125;var elemSet = ['**', 123, 'adv', '-', 45, 'AAA'];var result = elemSet.every(testValue);var result2 = elemSet.some(testValue);console.log(result); //falseconsole.log(result2); //truevar elemSet2 = ['aaa', 'animals', 'vvv'];result = elemSet2.every(testValue);result2 = elemSet2.some(testValue);console.log(result); //trueconsole.log(result2); //true 2.10 使用一个关联数组来存储表单元素名和值 keys() 方法返回一个新的Array迭代器，它包含数组中每个索引的键。 12345678var elemArray = &#123;&#125;;var elem = document.forms[0].elements[0];elemArray[elem.id] = elem.value;var elemArray = &#123;name: 'yt', age:25&#125;;Object.keys(elemArray).forEach(function(key) &#123; var value = elemArray[key]; console.log(value);&#125;); 待续~","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/tags/JavaScript/"},{"name":"JavaScript经典实例","slug":"JavaScript经典实例","permalink":"https://www.yangtao.site/tags/JavaScript经典实例/"}]},{"title":"学习《JavaScript经典实例》之第1章","slug":"js-chapter-1","date":"2018-04-08T12:47:23.000Z","updated":"2018-09-22T10:38:16.147Z","comments":true,"path":"2018/04/08/js-chapter-1/","link":"","permalink":"https://www.yangtao.site/2018/04/08/js-chapter-1/","excerpt":"《JavaScript经典实例》各节中的完整代码解决了常见的编程问题，并且给出了在任何浏览器中构建Web应用程序的技术。只需要将这些代码示例复制并粘贴到你自己的项目中就行了，可以快速完成工作，并且在此过程中学习JavaScript的很多知识。 第1章 JavaScript不只是简单的构件块1.1 JavaScript对象、基本类型和字面值之间的区别 5种基本类型：字符串、数值、布尔值、null、undefined，有3个有对应的构造方法对象:string、Number、Boolean 基本类型变量严格等于字面值，而对象实例则不会，因为基本类型是按值来比较的，而值是字面值 1234var num1 = 123;var num2 = new Number(123);console.log(typeof num1); //number console.log(typeof num2); //object","text":"《JavaScript经典实例》各节中的完整代码解决了常见的编程问题，并且给出了在任何浏览器中构建Web应用程序的技术。只需要将这些代码示例复制并粘贴到你自己的项目中就行了，可以快速完成工作，并且在此过程中学习JavaScript的很多知识。 第1章 JavaScript不只是简单的构件块1.1 JavaScript对象、基本类型和字面值之间的区别 5种基本类型：字符串、数值、布尔值、null、undefined，有3个有对应的构造方法对象:string、Number、Boolean 基本类型变量严格等于字面值，而对象实例则不会，因为基本类型是按值来比较的，而值是字面值 1234var num1 = 123;var num2 = new Number(123);console.log(typeof num1); //number console.log(typeof num2); //object 1.2 从字符串提取一个列表 提取之前：This is a list of items: cherries, limes, oranges, apples. 提取之后：[&#39;cherries&#39;,&#39;limes&#39;,&#39;oranges&#39;,&#39;apples&#39;] indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。 substring() 方法用于提取字符串中介于两个指定下标之间的字符。 split() 方法用于把一个字符串分割成字符串数组。 123456789101112var sentence = 'This is one sentence. This is a sentence with a list of items: cherries, oranges, apples, bananas. That was the list of items.';var start = sentence.indexOf(':');var end = sentence.indexOf('.', start+1);var listStr = sentence.substring(start+1, end);var fruits = listStr.split(',');console.log(fruits); //[\" cherries\", \" oranges\", \" apples\", \" bananas\"]//取出空格等fruits.forEach(function(elmnt,indx,arry) &#123; arry[indx] = elmnt.trim();&#125;);console.log(fruits); //[\"cherries\", \"oranges\", \"apples\", \"bananas\"] 1.3 检查一个存在的、非空的字符串 想要验证一个变量已经定义了，是一个字符串，并且它不为空 1if(typeof unknowVariable === 'string' &amp;&amp; unknowVariable.length &gt; 0) &#123;...&#125; 1.4 插入特殊字符 想要向字符串中插入一个特殊字符，例如一个换行 转义序列都以一个反斜杠 开始（\\） 1.5 使用新字符串替换模式 使用String对象的replace方法和一个 正则表达式 replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。 正则表达式特殊字符 字符 匹配 例子 ^ 匹配输入的开头 /^This/ 匹配This is… $ 匹配输入的结束 /end$/ 匹配This is the end * 匹配0次或多次 /se*/ 匹配s seeee或se ? 匹配0次或1次 /ap?/ 匹配apple and and + 匹配1次或多次 /ap+/ 匹配apple 但是不匹配and {n} 严格匹配n次 /ap{2}/ 严格匹配apple 但是不匹配apie {n,} 匹配n次或多次 /ap{2,}/ 匹配apple中的p，但是不匹配apie中的p {n,m} 至少匹配n次，之多匹配m除换行以外的任何字符 /ap{2,4}/ 匹配apppppple中的4个p/a.e/ 匹配ape和axe […] 方括号中的任何字符 /a[px]e/ 匹配ape axe 但是不匹配apxe [^…] 除了方括号以外的任何字符 /a[^px]/ 匹配ale 但是不匹配ape axe \\b 匹配单词边界 /\\bno/ 匹配nono中的第一个no \\B 匹配非单词边界 /\\Bno/ 匹配nono中的第二个no \\d 数字0到9 /\\d{3}/ 匹配Now in 123 中的123 \\D 匹配任何非数字字符 /\\D{2,4}/ 匹配Now in 123 中的Now in \\w 匹配任何单词字符（字母、数组和下划线 /\\w/ 匹配javaScript中的j \\W 匹配任何非单词字符（非字母、数组和下划线） /\\W/ 匹配100%中的% \\n 匹配一个换行 \\s 一个单个的空白字符 \\S 一个单个的非空白字符 \\t 一个制表符 (x) 捕获括号 记住匹配的字符 1234var searchString = \"Now is the time, this is the tame\";var re = /t\\w&#123;2&#125;e/g;var replacement = searchString.replace(re, 'place');console.log(replacement); //Now is the place, this is the place 1.6 找到并突出显示一个模式的所有实例 RegExp exec() 方法用于检索字符串中的正则表达式的匹配 RegExpObject.exec(string) 返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null 1234567891011121314151617var searchString2 = \"Now is the time and this is the time and that is the time\";var parttern = /t\\w*e/g; //\\w 匹配任何单词字符var matchArray;var str = \"\";//用regexp exec检查模式，如果不为空，处理它while((matchArray = parttern.exec(searchString2)) != null) &#123; str += \"at \" + matchArray.index + \" we found \" + matchArray[0] + \"\\n\";&#125;console.log(str);// at 7 we found the// at 11 we found time// at 28 we found the// at 32 we found time// at 49 we found the// at 53 we found time 12345678910111213141516171819202122232425262728293031323334//实例1-1document.getElementById(\"searchSubmit\").onclick = function() &#123; //获取模式 var pattern = document.getElementById(\"pattern\").value; var re = new RegExp(pattern, \"g\"); //获取字符串 var searchString = document.getElementById(\"inComing\").value; var matchArray; var resultString = \"&lt;pre&gt;\"; var first = 0; var last = 0; //找到每一个匹配 while((matchArray = re.exec(searchString)) != null) &#123; last = matchArray.index; //获取所有匹配的字符串，将其连接起来 resultString += searchString.substring(first, last); //使用class，添加匹配的字符串 resultString += '&lt;span class=\"found\"&gt;' + matchArray[0] + '&lt;/span&gt;'; first = re.lastIndex; &#125; //完成字符串 resultString += searchString.substring(first, searchString.length); resultString += \"&lt;/pre&gt;\"; //插入页面 document.getElementById(\"searchResult\").innerHTML = resultString;&#125; 1.7 使用捕获圆括号交换一个字符串中的单词 交换名称，让姓氏先出现 解决：使用捕获圆括号和一个正则表达式在字符串中找到并记住他们的名字，然后互换他们 replace() 方法用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。 字符 替换文本 $1、$2、…、$99 与 regexp 中的第 1 到第 99 个子表达式相匹配的文本。 $&amp; 与 regexp 相匹配的子串。 $` 位于匹配子串左侧的文本。 $’ 位于匹配子串右侧的文本。 $$ 允许替换中有一个字面值美元符号($) $n 插入使用RegExp的第n次捕获圆括号的值 1234var myName = \"Tao Yang\";var nameRe = /^(\\w+)\\s(\\w+)$/;var myNewName = myName.replace(nameRe, \"$2 $1\");console.log(myNewName); //Yang Tao 1.8 使用命名实体来替代HTML标签 使用正则表达式把尖括号(&lt;&gt;)转换为命名的实体：&lt;和&gt; 1234var pieceOfHtml = \"&lt;p&gt;This is a &lt;span&gt;paragraph&lt;/span&gt;&lt;/p&gt;\";pieceOfHtml = pieceOfHtml.replace(/&lt;/g, \"&amp;lt;\");pieceOfHtml = pieceOfHtml.replace(/&gt;/g, \"&amp;gt;\");console.log(pieceOfHtml); //&amp;lt;p&amp;gt;This is a &amp;lt;span&amp;gt;paragraph&amp;lt;/span&amp;gt;&amp;lt;/p&amp;gt; 1.9 ISO 8610格式的日期转换为Date对象可接受的一种形式123456789var dtstr = \"2014-3-04T19:35:32Z\";dtstr = dtstr.replace(/\\D/g, \" \");console.log(dtstr); //2014 3 04 19 35 32var dtcomps = dtstr.split(\" \");//在基于1的ISO 8610月份和基于0的日期格式之间转换dtcomps[1]--;var convdt = new Date(Date.UTC.apply(null, dtcomps));console.log(convdt.toString()); //Wed Mar 05 2014 03:35:32 GMT+0800 (中国标准时间) 1.10 使用带有定时器的函数闭包 使用一个匿名函数作为setInterval()或setTimeout()方法调用的第一个参数 123456789101112131415var intervalId = null;document.getElementById(\"redbox\").addEventListener('click', startBox, false);function startBox() &#123; if(intervalId == null) &#123; var x = 100; intervalId = setInterval(function() &#123; x += 5; var left = x + \"px\"; document.getElementById(\"redbox\").style.left = left; &#125;, 500); &#125; else &#123; clearInterval(intervalId); intervalId = null; &#125;&#125; 1.11 记录两个事件之间消耗的时间 在第一个事件发生的时候，创建一个Date对象，当第二个时间发生的时候，创建一个新的Date对象，并且从第二个对象中减去第一个对象。两者之间的差以毫秒表示的，要转换为秒，就除以1000 两个日期可以相减，但是相加就成了拼接字符串 12345678910var firstDate = new Date();setTimeout(function() &#123; doEvent(firstDate);&#125;, 25000);function doEvent() &#123; var secondDate = new Date(); var diff = secondDate - firstDate; console.log(diff); //25001&#125; 1.12 十进制数转化为十六进制值 使用Number对象的 toString() 方法 12var num = 255;console.log(num.toString(16)); //ff 1.13 想要将表中一列的所有数字加和 遍历表中包含了数字值的列，将其转换为数字，并加和 querySelector() 方法返回文档中匹配指定 CSS 选择器的一个元素 如果你需要返回所有的元素，请使用 querySelectorAll() 方法替代 全局函数 parseInt() 和 parseFloat() 都把字符串转化为数字 123456var sum = 0;//使用querySelectorAll找到第二列的所有单元格var cells = document.querySelectorAll(\"td:nth-of-type(2)\");for(var i=0, l=cells.length; i&lt;l; i++) &#123; sum += parseFloat(cells[i].firstChild.data);&#125; 1.14 在角度和弧度之间转换 将角度转换为弧度 1var radians = degrees * (Math.PI / 180); 将弧度转化为角度 1var degrees = radians * (180 / Math.PI); 1.15 找到页面元素可容纳的一个圆的半径和圆心 Math.min(x,y)方法可返回指定的数字中带有最低值的数字。 求出宽度和高度中较小的一个，用其除以2得到半径 1var circleRadius = Math.min(elemengWidth, elemengHeight) / 2; 给指定页面元素的宽度、高度，通过将二者都除以2来找到其中心点 12var x = elemengWidth / 2;var y = elemengHeight / 2; Window.getComputedStyle()方法给出应用活动样式表后的元素的所有CSS属性的值，并解析这些值可能包含的任何基本计算。 getComputedStyle() 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;将一个SVG圆放入到一个div元素中&lt;/title&gt; &lt;style type=\"text/css\"&gt; #elem &#123; width: 100%; height: 500px; border: 1px solid #ddd; background-color: #ddd; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"elem\"&gt; &lt;svg width=\"100%\" height=\"100%\"&gt; &lt;circle id=\"circ\" width=\"10\" height=\"10\" r=\"10\" fill=\"#f90\"&gt; &lt;/svg&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; window.onload = window.onresize = function() &#123; var box = document.getElementById(\"elem\"); var style = window.getComputedStyle(box, null); var width = parseInt(style.getPropertyValue(\"width\")); var height = parseInt(style.getPropertyValue(\"height\")); console.log('w', width, 'h', height); var x = width / 2; var y = height / 2; var circleRadius = Math.min(width, height) / 2; var circ = document.getElementById(\"circ\"); circ.setAttribute(\"r\", circleRadius); circ.setAttribute(\"cx\", x); circ.setAttribute(\"cy\", y); console.log('r', circleRadius, ' cx', x, ' cy', y); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1.16 计算圆弧的长度 给定了一个圆的半径及圆弧角的角度值，求该圆弧的长度 使用Math.PI把角度转换为弧度，并在公式中使用该结果来求得圆弧的长度 12var radians = degrees * (Math.PI / 180);var arclength = radians * radians; 待续~","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/tags/JavaScript/"},{"name":"JavaScript经典实例","slug":"JavaScript经典实例","permalink":"https://www.yangtao.site/tags/JavaScript经典实例/"}]},{"title":"jQuery工具函数操作DOM","slug":"practice-jquery-dom","date":"2017-05-21T12:57:24.000Z","updated":"2020-03-18T07:28:39.944Z","comments":true,"path":"2017/05/21/practice-jquery-dom/","link":"","permalink":"https://www.yangtao.site/2017/05/21/practice-jquery-dom/","excerpt":"jQuery 实战》（第三版）第九章学习总结","text":"jQuery 实战》（第三版）第九章学习总结 过滤数组$.grep(array,callback[,invert]) invert 为 true,则回调函数的值是 false，导致值被收集； invert 为 false,则回调函数的值是 true，导致值数据收集； 初始元素不变； 123456789101112131415161718192021var originalArray = [0, 34, 32, 1, 1, 23, 3214, 342, 1, 43, 56, 5, 8, 9, 0, 75];var bigNum1 = $.grep( originalArray, function(value) &#123; return value &gt; 10; &#125;, false);var bigNum2 = $.grep( originalArray, function(value) &#123; return value &gt; 10; &#125;, true);console.log(\"bigNum1\", bigNum1);console.log(\"bigNum2\", bigNum2);console.log(\"originalArray\", originalArray); 转换数组$.map(collection, callback) collection[Array | Object] callback(Function) 接受两个参数：当前值和初始数组值的索引；如果传递的是对象，则第二个参数是属性的当前值； 12345678910111213141516171819202122232425var oneBased = $.map([1, 2, 3, 0, 4], function(value) &#123; return value + 1;&#125;);console.log(\"oneBased\", oneBased);//将收集到的保存字符串的数组提取里面的数值，如若是，则提取，如若不是，则忽略；var strings = [\"1\", \"2\", \"3\", \"a\", \"b\", \"4\"];var values1 = $.map(strings, function(value) &#123; var result = new Number(value); return isNaN(result) ? null : result;&#125;);var values2 = $.map(strings, function(value) &#123; return isNaN(value) ? null : value;&#125;);console.log(\"values1\", values1);console.log(\"values2\", values2);//处理从转换函数里返回的数组，并存入结果数组中var characters = $.map([\"hello\", \"world\"], function(value) &#123; return value.split(\"\");&#125;);console.log(\"characters\", characters); $.inArray $.inArray(value, array[, fromIndex])确定一个数组是否包含某个特定的值，或者位置 fromIndex(Number) 数组中开始查询的位置；默认 0 返回数组中第一个出现值得位置索引，没有返回-1 12345var index1 = $.inArray(2, [1, 2, 3, 4]);var index2 = $.inArray(3, [1, 2, 3, 4], 3);console.log(\"index1\", index1); //index 1console.log(\"index2\", index2); //index -1(未找到) $.makeArray(object) – 把类数组对象转换为 JavaScript 数组 $.merge(array1, array2) – 合并两个数组，并将第一个数组被修改后作为结果返回 扩展对象$.extend([deep,] target, [source1, source2,...,sourceN]) 通过传递的对象属性来扩展 target 对象；扩展后的对象可作为返回值 deep(Boolean) 忽略或者为 false，使用浅拷贝扩展；true，则使用深拷贝扩展 target(Object) 使用源元素属性来扩展目标对象 source1...(Object) 一个或者多个对象,属性会添加到 target 目标对象中 123456789101112131415161718192021//$.extend()函数合并了多个源对象的属性不包含重复值，而且按照顺序排序var target = &#123; a: 1, b: 2, c: 3 &#125;;var source1 = &#123; c: 4, d: 5, e: 6 &#125;;var source2 = &#123; c: 8, e: 10, f: 9 &#125;;$.extend(target, source1, source2);console.log(\"target(after)\", target);//传递空对象作为目标var newObject = $.extend(&#123;&#125;, source1, source2);console.log(\"newObject\", newObject);//深拷贝var target1 = &#123; a: 1, b: 2 &#125;;var source11 = &#123; b: &#123; foo: \"bar\" &#125;, c: 3 &#125;;var source22 = &#123; b: &#123; oof: \"rab\" &#125;, d: 4 &#125;;$.extend(true, target1, source11, source22);console.log(\"target1\", target1); 序列化参数$.param(params[, traditional]) 序列化为适当的字符串传递信息，便于为查询字符串提交请求 params(Array|jQuery|Object) traditional(Boolean) 是否执行传统的影子序列化 12345678&lt;form action=\"\"&gt; &lt;lable for=\"name\"&gt;Name:&lt;/lable&gt; &lt;input id=\"name\" name=\"name\" value=\"YangTao\" /&gt; &lt;lable for=\"surname\"&gt;Surname:&lt;/lable&gt; &lt;input id=\"surname\" name=\"surname\" value=\"Bluth\" /&gt; &lt;lable for=\"address\"&gt;Address:&lt;/lable&gt; &lt;input id=\"address\" name=\"address\" value=\"Fake street 1, Beijing, China\" /&gt;&lt;/form&gt; 12var formResult = $.param($(\"input\"));console.log(\"formResult\", formResult); 测试对象 $.isArray(param) param 是 JavaScript 数组，返回 true,否则返回 false $.isFunction(param) param 是函数，返回 true，否则返回 false $.isNumeric(param) param 是数值，返回 true，否则返回 false $.isWindow(param) param 表示 window 对象，返回 true，否则返回 false $.isEmptyObject(param) param 是 JavaScript 对象，不包含属性，返回 true，否则返回 false $.isPlainObject(param) param 表示用 via{} 或者 new Object()创建的 JavaScript 对象，返回 true，否则返回 false $.isXMLDoc(param) param 表示 XML 文档或 XML 节点，返回 true，否则返回 false 查看值的类型 $.type(param) 解析函数 $.paramJSON(json) $.paramXML(xml) $.paramHTML(html[,context][,keepScripts]) 测试包含 $.contains(container, contained) 测试元素是否包含在 DOM 层的另一个元素中","categories":[{"name":"工具库","slug":"工具库","permalink":"https://www.yangtao.site/categories/工具库/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://www.yangtao.site/tags/jQuery/"}]},{"title":"embed嵌入多个优酷视频并自动播放","slug":"practice-video-embed","date":"2017-01-22T05:41:48.000Z","updated":"2020-03-18T07:14:26.239Z","comments":true,"path":"2017/01/22/practice-video-embed/","link":"","permalink":"https://www.yangtao.site/2017/01/22/practice-video-embed/","excerpt":"整理入坑学习记录","text":"整理入坑学习记录 关于 embed 标签特点： 多个视频选择； 弹出模态框，不能上下滑动； 视频自带可全屏； 视频自动播放； 兼容 IE，IE 会有播放残留，所以让其刷新页面； 其他浏览器：火狐，谷歌，edge，safari 等； 首先，先看一下嵌入网页中优酷视频的完整代码（直接从优酷分享得到的 HTML 代码）： 12345678910&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;title&gt;embed&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;embed src='http://player.youku.com/player.php/sid/XMjQ4MDg2MTc2MA==/v.swf' allowFullScreen='true' quality='high' width='480' height='400' align='middle' allowScriptAccess='always' type='application/x-shockwave-flash'&gt;&lt;/embed&gt;&lt;/body&gt;&lt;/html&gt; 代码中，&lt;embed&gt;的相关属性： src — 指向资源； quality=&#39;high&#39; — 视频的默认清晰度，一般为 high; width,height — 视频的宽、高度； align=&#39;middle&#39; — 视频的位置； allowFullScreen=&#39;true&#39; — 是否运行全屏观看，默认 true; type=&#39;application/x-shockwave-flash&#39; — 各个浏览器支持情况； allowScriptAccess=&#39;always&#39; — 特殊属性，用于确保 Flash 影片可能特定于某个版本的 Flash； 常用的基本属性就这些了，不过，这个嵌入的视频，默认是不自动播放，下面来看看自动播放的设置代码： 1234567891011&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\"&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\"&gt;&lt;head&gt;&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt;&lt;title&gt;embed&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;embed src='http://player.youku.com/player.php/sid/XMjQ4MDg2MTc2MA==/v.swf?VideoIDS=XMjQ4MDg2MTc2MA==&amp;isAutoPlay=true&amp;isShowRelatedVideo=false&amp;showAd=0' allowFullScreen='true' quality='high' width='480' height='400' align='middle' allowScriptAccess='always' type='application/x-shockwave-flash'&gt;&lt;/embed&gt;&lt;/body&gt;&lt;/html&gt; 这些属性一看就明白： isAutoPlay=true — 是否自动播放； isShowRelatedVideo=false — 是否展示相关视频； 好了，embed 的常用属性介绍完毕，接下来咱们一起看看如何跟换视频的链接： 第一步由于是多个视频展示，所以复制多个 data-item 值： 12345678910111213141516171819202122&lt;ul id=\"videoList\"&gt; &lt;li data-item=\"1\"&gt; &lt;button type=\"button\" name=\"video01\"&gt;视频01&lt;/button&gt; &lt;p&gt;视频简介&lt;/p&gt; &lt;p&gt;视频描述视频描述视频描述&lt;/p&gt; &lt;/li&gt; &lt;li data-item=\"2\"&gt; &lt;button type=\"button\" name=\"video02\"&gt;视频02&lt;/button&gt; &lt;p&gt;视频简介&lt;/p&gt; &lt;p&gt;视频描述视频描述视频描述&lt;/p&gt; &lt;/li&gt; &lt;li data-item=\"3\"&gt; &lt;button type=\"button\" name=\"video03\"&gt;视频03&lt;/button&gt; &lt;p&gt;视频简介&lt;/p&gt; &lt;p&gt;视频描述视频描述视频描述&lt;/p&gt; &lt;/li&gt; &lt;li data-item=\"4\"&gt; &lt;button type=\"button\" name=\"video04\"&gt;视频04&lt;/button&gt; &lt;p&gt;视频简介&lt;/p&gt; &lt;p&gt;视频描述视频描述视频描述&lt;/p&gt; &lt;/li&gt;&lt;/ul&gt; 第二步模态框设置，并且设置视频关闭按钮，（这里没有直接将 embed 的内容写入在页面上，防止有些浏览器直接跳过 js 代码） 123456&lt;!--遮罩层--&gt;&lt;div id=\"mask\"&gt;&lt;/div&gt;&lt;!--视频区--&gt;&lt;div id=\"videoModal\"&gt; &lt;div id=\"closeBtn\"&gt;&lt;a&gt;x&lt;/a&gt;&lt;/div&gt;&lt;/div&gt; 第三步使用 jquery 获取到点击事件，并判断是否是需要点击的对象： 123456789101112131415161718var embedEle;var videoID = \"\";var videoSrc;var videoModal = $(\"#videoModal\");var $targetEle = $(\"#videoList\").find(\"li\");//点击视频，判断是否是button，排除其他内容$targetEle.click(function(e) &#123; var dataItem = $(this).attr(\"data-item\"); var $para1 = $(this).find(\"p\")[0]; var $para2 = $(this).find(\"p\")[1]; if (e.target == $para1 || e.target == $para2) &#123; return; &#125; else &#123; videoID = isWhichSrc(dataItem); videoFunc(videoID); return false; &#125;&#125;); 根据data-item的值，获取点击的data-item，并执行isWhichSrc(num)函数,并将获取到的视频链接赋值给videoID = isWhichSrc(dataItem);： 12345678910111213141516//根据得到的data-item值判断相对应的视频IDvar isWhichSrc = function(num) &#123; if (num == 1) &#123; videoID = \"XMjQ4MDg2MTc2MA\"; &#125; if (num == 2) &#123; videoID = \"XMTY0OTYzNTU0NA\"; &#125; if (num == 3) &#123; videoID = \"XMTQyMDExNjA4NA\"; &#125; if (num == 4) &#123; videoID = \"XMTc2MDAxOTIwOA\"; &#125; return videoID;&#125;; 然后将此值传入给videoFunc(videoid)；该函数中，创建embed并添加到页面上： 123456789101112131415161718//根据视频ID赋值视频链接function videoFunc(videoid) &#123; videoSrc = \"http://player.youku.com/player.php/sid/\" + videoid + \"==/v.swf?VideoIDS=\" + videoid + \"==&amp;isAutoPlay=true&amp;isShowRelatedVideo=false&amp;showAd=0\"; embedEle = \"&lt;embed src='\" + videoSrc + \"' allowFullScreen='true' quality='high' width='610' height='460' align='middle' allowScriptAccess='always' type='application/x-shockwave-flash'&gt;&lt;/embed&gt;\"; //将获得的embed标签添加进去 videoModal.append(embedEle); $(\"#videoModal\").slideDown(600); showMask();&#125; 最后就是关于遮罩层的函数： 1234567891011121314function showMask() &#123; $(\"body\").css(\"overflow\", \"hidden\"); $(\"#mask\") .css(&#123; height: $(document).height(), width: $(document).width() &#125;) .slideDown(600);&#125;function hideMask() &#123; $(\"#mask\").slideUp(600); bodyShow();&#125;function bodyShow() &#123; $(\"body\").css(\"overflow\", \"auto\");&#125; 完整栗子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;youku-video-embed&lt;/title&gt; &lt;/head&gt; &lt;script type=\"text/javascript\" src=\"http://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js\" &gt;&lt;/script&gt; &lt;style type=\"text/css\"&gt; * &#123; margin: 0; padding: 0; &#125; /*遮罩层*/ #mask &#123; position: fixed; top: 0; left: 0; opacity: 0.8; filter: alpha(opacity=80); background-color: #000; z-index: 99; &#125; /*视频*/ #closeBtn &#123; float: right; padding-right: 5px; width: 14px; height: 20px; line-height: 20px; &#125; #closeBtn a &#123; font-size: 18px; font-weight: bold; cursor: pointer; color: #666; &#125; #closeBtn a:hover &#123; color: #fff; text-decoration: none; &#125; #videoModal &#123; display: none; position: fixed; top: 10%; left: 50%; margin-left: -305px; width: 610px; height: 480px; background-color: #000; z-index: 100; &#125; /*按钮*/ .wrapper &#123; margin: 0 auto; width: 100%; max-width: 1140px; text-align: center; &#125; h3 &#123; margin-top: 20px; color: #b403b7; &#125; ul &#123; overflow: hidden; &#125; ul li &#123; float: left; list-style-type: none; margin: 10px 20px; &#125; p &#123; font-size: 14px; font-family: \"微软雅黑\"; color: #999; &#125; .wrapper button &#123; margin-top: 50px; width: 200px; height: 200px; cursor: pointer; border-radius: 8px; color: #666; &#125; .wrapper button:hover &#123; opacity: 0.8; filter: alpha(opacity=80); &#125; &lt;/style&gt; &lt;body&gt; &lt;!--遮罩层--&gt; &lt;div id=\"mask\"&gt;&lt;/div&gt; &lt;!--视频区--&gt; &lt;div id=\"videoModal\"&gt; &lt;div id=\"closeBtn\"&gt;&lt;a&gt;x&lt;/a&gt;&lt;/div&gt; &lt;/div&gt; &lt;!--按钮--&gt; &lt;div class=\"wrapper\"&gt; &lt;h3&gt;embed链接优酷视频自动播放&lt;/h3&gt; &lt;ul id=\"videoList\"&gt; &lt;li data-item=\"1\"&gt; &lt;button type=\"button\" name=\"video01\"&gt;视频01&lt;/button&gt; &lt;p&gt;视频简介&lt;/p&gt; &lt;p&gt;视频描述视频描述视频描述&lt;/p&gt; &lt;/li&gt; &lt;li data-item=\"2\"&gt; &lt;button type=\"button\" name=\"video02\"&gt;视频02&lt;/button&gt; &lt;p&gt;视频简介&lt;/p&gt; &lt;p&gt;视频描述视频描述视频描述&lt;/p&gt; &lt;/li&gt; &lt;li data-item=\"3\"&gt; &lt;button type=\"button\" name=\"video03\"&gt;视频03&lt;/button&gt; &lt;p&gt;视频简介&lt;/p&gt; &lt;p&gt;视频描述视频描述视频描述&lt;/p&gt; &lt;/li&gt; &lt;li data-item=\"4\"&gt; &lt;button type=\"button\" name=\"video04\"&gt;视频04&lt;/button&gt; &lt;p&gt;视频简介&lt;/p&gt; &lt;p&gt;视频描述视频描述视频描述&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;!--js--&gt; &lt;script&gt; var embedEle; var videoID = \"\"; var videoSrc; var videoModal = $(\"#videoModal\"); var $targetEle = $(\"#videoList\").find(\"li\"); //点击视频，判断是否是button，排除其他内容 $targetEle.click(function(e) &#123; var dataItem = $(this).attr(\"data-item\"); var $para1 = $(this).find(\"p\")[0]; var $para2 = $(this).find(\"p\")[1]; if (e.target == $para1 || e.target == $para2) &#123; return; &#125; else &#123; videoID = isWhichSrc(dataItem); videoFunc(videoID); return false; &#125; &#125;); //关闭 $(\"#closeBtn\").click(function() &#123; videoModal .slideUp(600) .find(\"embed\") .remove(); //兼容IE，让其刷新页面，对其他浏览器无效 document.execCommand(\"Refresh\"); hideMask(); return false; &#125;); //根据得到的data-item值判断相对应的视频ID var isWhichSrc = function(num) &#123; if (num == 1) &#123; videoID = \"XMjQ4MDg2MTc2MA\"; &#125; if (num == 2) &#123; videoID = \"XMTY0OTYzNTU0NA\"; &#125; if (num == 3) &#123; videoID = \"XMTQyMDExNjA4NA\"; &#125; if (num == 4) &#123; videoID = \"XMTc2MDAxOTIwOA\"; &#125; return videoID; &#125;; //根据视频ID赋值视频链接 function videoFunc(videoid) &#123; videoSrc = \"http://player.youku.com/player.php/sid/\" + videoid + \"==/v.swf?VideoIDS=\" + videoid + \"==&amp;isAutoPlay=true&amp;isShowRelatedVideo=false&amp;showAd=0\"; embedEle = \"&lt;embed src='\" + videoSrc + \"' allowFullScreen='true' quality='high' width='610' height='460' align='middle' allowScriptAccess='always' type='application/x-shockwave-flash'&gt;&lt;/embed&gt;\"; //将获得的embed标签添加进去 videoModal.append(embedEle); $(\"#videoModal\").slideDown(600); showMask(); &#125; //遮罩层部分 function showMask() &#123; $(\"body\").css(\"overflow\", \"hidden\"); $(\"#mask\") .css(&#123; height: $(document).height(), width: $(document).width() &#125;) .slideDown(600); &#125; function hideMask() &#123; $(\"#mask\").slideUp(600); bodyShow(); &#125; function bodyShow() &#123; $(\"body\").css(\"overflow\", \"auto\"); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Html","slug":"Html","permalink":"https://www.yangtao.site/categories/Html/"}],"tags":[{"name":"Html","slug":"Html","permalink":"https://www.yangtao.site/tags/Html/"}]},{"title":"初识JavaScript的解析与执行过程","slug":"practice-compiler","date":"2016-09-16T14:56:30.000Z","updated":"2020-03-18T07:04:21.652Z","comments":true,"path":"2016/09/16/practice-compiler/","link":"","permalink":"https://www.yangtao.site/2016/09/16/practice-compiler/","excerpt":"整理入坑学习记录","text":"整理入坑学习记录 全局预处理先扫描函数声明，再扫描变量声明： 函数：用声明的方式创建的函数； 变量：用 var 定义的变量；初始化为 undefined； 如果出现命名冲突 时： 函数声明：覆盖； 变量声明：忽略； 12345678f(); //fffg(); //TypeError: g is not a functionfunction f() &#123; console.log(\"fff\");&#125;var g = function() &#123; console.log(\"ggg\");&#125;; f()函数是声明方式创建的函数，g()是函数表达式，全局预处理时词法环境中，只能是用声明的方式创建的函数。 因此，全局预处理时 g()从语义上看，应该是函数，但是由于 g()是函数表达式，不会在词法环境中，所以调用时会报错。 1234console.log(a); // undefinedconsole.log(b); //ReferenceError: b is not definedvar a = 1;b = 2; 同理，词法环境中只有用 var 定义的变量。 123456789101112alert(f); //function f()&#123;alert('567');&#125;var f = 1;function f() &#123; alert(\"123\");&#125;var f = 2;function f() &#123; alert(\"567\");&#125;var f = function() &#123; alert(\"890\");&#125;; 命名冲突时，函数具有“优先权”，变量会直接被忽略，而函数会被覆盖。 全局执行过程1234567891011121314alert(a); //undefinedalert(b); //ReferenceError: b is not definedalert(f); //function f() &#123;console.log('f');&#125;alert(g); //undefinedvar a = 1;b = 2;alert(b); //2function f() &#123; console.log(\"f\");&#125;var g = function() &#123; console.log(\"g\");&#125;;alert(g); //function () &#123;console.log('g');&#125; 为了分析方便我们可以使用词法环境： 1LexicalEnvironment &#123;&#125; === window； 全局预处理时： 1234567window &#123; //先扫描函数声明： f: 指向函数, //再扫面变量声明： a: undefined, g: undefined&#125; 全局执行时： 123456window &#123; f: 指向函数, a: 1, b: 2, g: 指向函数&#125; 函数预处理阶段 每调用一次，产生一个词法环境（或执行上下文Execution Context）； 先传入函数的参数，若参数值为空，初始化undefined； 然后是内部函数声明，若发生命名冲突，会覆盖； 接着就是内部var变量声明，若发生命名冲突，会忽略； 函数执行阶段 给预处理阶段的成员赋值； 无 var 声明的变量，会成为全局成员； 1234567function f(a, b) &#123; alert(a); //1 alert(b); //funciton b()&#123;&#125; var a = 100; function b() &#123;&#125;&#125;f(1, 2); VO（Variable Object）——&gt; 变量对象 函数中的激活对象：VO（functionContext）=== AO; 1234AO(f) &#123; a: 1, //变量命名冲突，忽略 b: 指向函数, //函数命名冲突，覆盖&#125; 例如： 1234567891011121314151617function test(a, b) &#123; alert(a); //10 alert(b); //undefined alert(c); //undefined alert(d); //function d()&#123;&#125; alert(e); //undefined //alert(x); //ReferenceError: x is not defined var c = 10; alert(c); //10 function d() &#123;&#125; var e = function _e() &#123;&#125;; alert(e); //function _e()&#123;&#125; (function x() &#123;&#125;); b = 20; alert(b); //20&#125;test(10); 函数预处理时： 12345678910111213AO（test） &#123; //参数： a: 10, b: undefined, //函数声明： d: 指向函数， //变量声明： c: undefined, e: undefined&#125; 函数执行时： 1234567AO（test） &#123; a: 10, b: 20, d: 指向函数， c: 10, e: 指向函数&#125;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/tags/JavaScript/"}]},{"title":"初识JavaScript的对象属性类型","slug":"practice-object-attribute","date":"2016-09-14T15:22:22.000Z","updated":"2020-03-18T04:07:25.178Z","comments":true,"path":"2016/09/14/practice-object-attribute/","link":"","permalink":"https://www.yangtao.site/2016/09/14/practice-object-attribute/","excerpt":"整理入坑学习记录","text":"整理入坑学习记录 何为对象简单点说，对象包含属性或方法，而对象的每个属性或方法都有一个名字，这个名字又都映射到一个值。 所以，对象就是一组名值对（键值对），其中值可以是数据或函数。 每个对象都是基于一个引用类型创建的，这个引用类型可以是原生类型，也可以是自定义类型。 创建自定义对象创建一个 Object 的实例： 12345678varperson = new Object();person.name = \"Bob\";person.age = 24;person.job = \"Teacher\";person.sayName = function() &#123; alert(this.name);&#125;; 用对象字面量重新创建对象： 123456789var person = &#123; name: \"Bob\", age: 24, job: \"Teacher\", sayName: function() &#123; alert(this.name); &#125;&#125;; 用两种方式创建的 person 对象都有相同的属性和方法。 属性类型属性类型分为数据属性和访问器属性。 数据属性有 4 个特性： [[Configurable]] [[Enumerable]] [[Writable]] [[Value]] 访问器属性也有 4 个特性，不包含数据值，包含一对儿 getter 和 setter 函数： [[Configurable]] [[Enumerable]] [[Get]] [[Set]] 修改属性默认的特性Object.defineProperty()方法，接受三个参数： 属性所在的对象； 属性的名字； 一个描述符对象； 数据属性例子： 12345678910var person = &#123;&#125;；Object.defineProperty(person, \"name\", &#123; writeable: false, configurable: false, value: \"Bob\"&#125;);alert(person.name); //\"Bob\"person.name = \"Mike\";alert(person.name); //\"Bob\" 例子中创建了一个名为 name 的属性，由于 writable 设置为 false,name 的值是“只读”的，不可修改； 把 configurable 设置为 false，表示不能从对象中删除（delete）属性，而且，一旦把属性定义为不可配置的，再次调用 Object.defineProperty()方法修改 writable 之外的特性，会导致错误。 在调用Object.defineProperty()方法时，如果不指定，configurable、 enumerable、 writable特性的默认值都是false; 如果不调用Object.defineProperty()方法时，即直接在对象上定义的属性，他们的configurable enumerable writable特性的默认值都是true，value特性为指定的值（默认值为undefined）； getter setter 方法： 123456789101112131415var person = &#123; name: \"Bob\", job: \"Teacher\", get age() &#123; return new Date().getFullYear() - 1992; &#125;, set age(val) &#123; alert(\"Age can't be set to \" + val); &#125;&#125;;alert(person.age); //24person.age = 100; //Age can't be set to 100alert(person.age); //still 24 以上代码创建了一个 person 对象，并定义了两个默认的属性：name 和 job,而且包含有一个 getter 函数和一个 setter 函数。 getter 函数返回 age 的值； setter 函数返回设置 age 的值 val； 定义多个属性：Object.defineProperties()方法，接受两个对象参数： 第一个对象是要添加和修改其属性的对象； 第二个对象的属性与第一个对象中药添加或修改的属性一一对应。 12345678910111213141516171819202122232425262728var book = &#123;&#125;;Object.defineProperties(book, &#123; _year: &#123; writable: true, value: 2016 &#125;, edition: &#123; writable: true, value: 1 &#125;, year: &#123; get: function() &#123; return this._year; &#125;, set: function(val) &#123; if (val &gt; 2016) &#123; this._year = val; this.edition += val - 2016; &#125; &#125; &#125;&#125;);console.log(book.year); //2016console.log(book.edition); //1book.year = 2018;console.log(book.edition); //3 以上代码在 book 对象上定义了两个数据属性（_year 和 edition）和一个访问器属性（year）。 读取属性的特性Object.getOwnPropertyDescriptor()方法，接受两个参数： 属性所在的对象； 要读取其描述符的属性名称。 返回值是一个对象： 数据属性，对象的属性有configurable 、enumerable、 writable、value； 访问器属性，对象的属性有configurable 、enumerable、 get、set。 1234567891011121314151617181920212223242526272829303132var book = &#123;&#125;;Object.defineProperties(book, &#123; _year: &#123; value: 2016 &#125;, edition: &#123; value: 1 &#125;, year: &#123; get: function() &#123; return this._year; &#125;, set: function(val) &#123; if (val &gt; 2016) &#123; this._year = val; this.edition += val - 2016; &#125; &#125; &#125;&#125;);var descriptor = Object.getOwnPropertyDescriptor(book, \"_year\");console.log(descriptor.value); //2016console.log(descriptor.configurable); //falseconsole.log(typeof descriptor.get); //undefinedvar descriptor = Object.getOwnPropertyDescriptor(book, \"year\");console.log(descriptor.value); //undefinedconsole.log(descriptor.enumerable); //falseconsole.log(typeof descriptor.get); //function 数据属性_year，value 等于最初的值，configurable 是 false，而 get 等于 undefined； 访问器属性 year，value 等于 undefined，enumerable 是 false，而 get 是一个指向 getter 函数的指针。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/tags/JavaScript/"}]},{"title":"初识JavaScript的面向对象","slug":"practice-object","date":"2016-08-21T09:23:22.000Z","updated":"2020-03-18T03:59:34.204Z","comments":true,"path":"2016/08/21/practice-object/","link":"","permalink":"https://www.yangtao.site/2016/08/21/practice-object/","excerpt":"整理入坑学习记录","text":"整理入坑学习记录 首先，面向对象是什么 浅显地说，面向对象就是只关注对象提供的功能，不在乎其内部的具体细节； 比如，电视机，我们知道怎么打开、关闭、调台，但一般我们是不知道它到底是如何打开、关闭、调台的。 再比如，黑匣子； 面向对象是一种通用思想，并非只有编程中才使用，任何事情都可以找到它的影子。 OOP 的特点 面向对象编程的三大特点： 1. 抽象—抓住核心问题； 2. 封装—只考虑功能使用，不考虑内部实现； 3. 继承—从已有的对象上，继承出新的对象； 原型 定义就不粘贴了，通俗滴说，prototype 类似于我们 css 中的 class； 比如，我们给多个 div 添加相同的属性时，就会使用 class；同样的，使用 prototype 就是需要添加多个方法： 123456CreatePerson.prototype.showName = function() &#123; console.log(\"我是\" + this.name);&#125;;CreatePerson.prototype.showQQ = function() &#123; console.log(\"我的qq号是：\" + this.qq);&#125;; 代码中，一个人的名字和 QQ 号，可以使用一般的函数来解决，若两个，十个的就麻烦了，因此使用原型prototype可以很好地解决函数重复导致的资源浪费。 类和对象的关系 对象，由方法和属性组成； 类，比如数组 Array； 1var arr = new Array(1, 2, 3, 4); 其中 arr 是对象，Array 是类； 我们可以把类看做是制作产品的磨具，而对象就是由模具制作出来的产品。 类 — 模具； 对象 — 产品； 代码：面向过程1234567891011121314151617181920212223function createPerson(name, qq) &#123; // 加new之后，系统偷偷给加了var this=new Object(); // var person1 = new Object(); this.name = name; this.qq = qq; this.showName = function() &#123; console.log(\"我是\" + this.name); &#125;; this.showQQ = function() &#123; console.log(\"我的QQ号是\" + this.qq); &#125;; // 加new后这里又偷偷地执行return this; // return person1;&#125;var person1 = new createPerson(\"杨子龙\", \"33441524\");var person2 = new createPerson(\"王德彪\", \"66111314\");person1.showName();person1.showQQ();person2.showName();person2.showQQ();console.log(person1.showName == person2.showName); 以上代码是由工厂方式创建; 用构造函数function createPerson(name, qq) {}创建一个类； 调用函数使用关键字 new：var person1 = new createPerson();这时系统就是替你创建了一个空白对象var this=new Object();并且还替你返回了这个对象return this; 工厂方式的问题：函数重复使用导致资源浪费； 1console.log(person1.showName == person2.showName); //false 代码：面向对象1234567891011121314151617181920function CreatePerson(name, qq) &#123; this.name = name; this.qq = qq;&#125;CreatePerson.prototype.showName = function() &#123; console.log(\"我是\" + this.name);&#125;CreatePerson.prototype.showQQ = function() &#123; console.log(\"我的qq号是：\" + this.qq);&#125;var person1 =new CreatePerson(\"王德彪\", 330441338);var person2 =new CreatePerson(\"杨子龙\", 369898363);person1.showName();person1.showQQ();person2.showName();person2.showQQ();console.log(person1.showName == person2.showName)； 面向对象 使用构造函数加属性； 使用原型加方法；这时console.log(person1.showName == person2.showName)；，会是true，因为 person1 和 person2 都来自同个原型:CreatePerson.prototype.showName()。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.yangtao.site/tags/JavaScript/"}]},{"title":"实践|JS匀速运动和缓冲运动","slug":"practice-speed-move","date":"2016-08-09T07:24:22.000Z","updated":"2020-03-18T03:41:04.462Z","comments":true,"path":"2016/08/09/practice-speed-move/","link":"","permalink":"https://www.yangtao.site/2016/08/09/practice-speed-move/","excerpt":"整理入坑学习记录：有代码有总结的 JS 匀速运动和缓冲运动学习报告","text":"整理入坑学习记录：有代码有总结的 JS 匀速运动和缓冲运动学习报告 JS 匀速运动的学习总结匀速运动要点 点击“开始”，物体向右匀速运动 600 个像素；点击“返回”，物体匀速回到初始位置； css 样式表中，设置绝对定位； JS 代码中： 初始化定时器：timer=null; 开始运动时，关闭已有的定时器:clearInterval(timer);；否则你连续点击按钮时，物体会因为定时器的每次开启但没有清除每次的开启，会导致一卡一卡的运动； 设置 speed，根据目标值和 offsetLeft 之差来判断正负； 使用 if()判断，把运动和停止隔开； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;匀速运动&lt;/title&gt; &lt;style type=\"text/css\"&gt; #div1 &#123; width: 300px; height: 100px; border: 5px inset #890; background-color: #588; text-align: center; position: absolute; /*设置绝对定位*/ left: 0; box-shadow: 10px 9px 12px #599; &#125; #div1 p &#123; font-family: \"新宋体\"; font-size: 30px; color: white; margin-top: 14px; &#125; &lt;/style&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function() &#123; var oBtn1 = document.getElementById(\"btn1\"); var oBtn2 = document.getElementById(\"btn2\"); var oDiv = document.getElementById(\"div1\"); var oPar = document.getElementById(\"par1\"); oBtn1.onclick = function() &#123; startMove(600); oPar.innerHTML = \"点击返回，我会回到起点\"; &#125;; oBtn2.onclick = function() &#123; startMove(0); oPar.innerHTML = \"点击开始,我将匀速运动\"; &#125;; &#125;; var timer = null; function startMove(iTarget) &#123; var oDiv = document.getElementById(\"div1\"); //开始运动前，清除定时器 clearInterval(timer); timer = setInterval(function() &#123; //设置speed的初始值为0,并且根据目标值判断正负 var speed = 0; if (oDiv.offsetLeft &gt; iTarget) &#123; speed = -10; &#125; else &#123; speed = 10; &#125; //用if和else隔开运动和停止 if (oDiv.offsetLeft == iTarget) &#123; //满足条件时，清除定时器 clearInterval(timer); &#125; else &#123; oDiv.style.left = oDiv.offsetLeft + speed + \"px\"; &#125; &#125;, 30); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input id=\"btn1\" type=\"button\" value=\"开始\" /&gt; &lt;input id=\"btn2\" type=\"button\" value=\"返回\" /&gt;&lt;br /&gt; &lt;div id=\"div1\"&gt; &lt;p id=\"par1\"&gt;点击开始,我将匀速运动&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 关于 speed 的 Bug 一般情况下，我们设置 speed 为偶数，如上所示代码，会如期到达目标点； 若 speed 为奇数呢？ 设 speed=7，目标点为 100，从 0 开始匀速运动，经过 14 次的递加，到达 98 处，这时，问题出现了：若再递加 7，就会超过目标点 100，若不递加，就会达不到目标点；所以，开始前后卡顿。 如何解决呢？ 使用 Math.abs(); speed 有可能为正，也有可能为负，我们使用绝对值，让目标和物体之间的距离&lt;=7,即：Math.abs(iTarget-ele.offsetLeft) &lt;= 7 这时不管怎么样，都是不足 7 个，我们就可以讨巧地认为它已经 到达目标点了，所以就可以清除定时器；你再试试看，就不会晃动了，不过还没达到目标点。 为了精准地达到目标点，我们就认为 left 直接到达目标点，即：ele.style.left = iTarget + &quot;px&quot;; 最后：只有匀速运动才会有这个问题；缓冲运动没有，因为它的 speed 是一直随之变化，越来越小，直到到达目标点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;匀速运动之speed&lt;/title&gt; &lt;style type=\"text/css\"&gt; #div1 &#123; width: 150px; height: 200px; background-color: #880; margin-top: 35px; position: absolute; left: 0; &#125; #div1 p &#123; font-size: 24px; color: #fff; text-align: center; line-height: 200px; margin-top: 0; &#125; #div2, #div3 &#123; width: 0; height: 300px; border: 1px solid #000; position: absolute; left: 300px; &#125; #div3 &#123; left: 600px; &#125; &lt;/style&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function() &#123; var btn_1 = document.getElementById(\"btn1\"); var btn_2 = document.getElementById(\"btn2\"); var btn_3 = document.getElementById(\"btn3\"); btn_1.onclick = function() &#123; startMove(600); &#125;; btn_2.onclick = function() &#123; startMove(300); &#125;; btn_3.onclick = function() &#123; startMove(0); &#125;; &#125;; var timer = null; function startMove(iTarget) &#123; var ele = document.getElementById(\"div1\"); clearInterval(timer); timer = setInterval(function() &#123; var speed = 0; if (iTarget &gt; ele.offsetLeft) &#123; speed = 7; &#125; else &#123; speed = -7; &#125; if (Math.abs(iTarget - ele.offsetLeft) &lt;= 7) &#123; clearInterval(timer); ele.style.left = iTarget + \"px\"; &#125; else &#123; ele.style.left = ele.offsetLeft + speed + \"px\"; &#125; &#125;, 30); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=\"button\" id=\"btn1\" value=\"600px\" /&gt; &lt;input type=\"button\" id=\"btn2\" value=\"300px\" /&gt; &lt;input type=\"button\" id=\"btn3\" value=\"0px\" /&gt; &lt;div id=\"div1\"&gt; &lt;p&gt;我是匀速运动&lt;/p&gt; &lt;/div&gt; &lt;div id=\"div2\"&gt;&lt;/div&gt; &lt;div id=\"div3\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 匀速运动之分享栏 当鼠标经过“分享”时，会弹出整个分享栏；鼠标离开时，又会恢复到初始状态； css 样式表中：设置绝对定位，并设置 left 之为-150px，隐藏分享栏； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE html&gt;&lt;body&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;分享栏&lt;/title&gt; &lt;style type=\"text/css\"&gt; * &#123; margin: 0px; padding: 0px; background-color: #ccc; &#125; #div1 &#123; width: 150px; height: 300px; background-color: #f60; position: absolute; top: 100px; left: -150px; &#125; #div1 span &#123; width: 30px; height: 54px; padding-top: 6px; background-color: #c38; color: white; text-align: center; position: absolute; right: -30px; top: 120px; &#125; &lt;/style&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function() &#123; var oDiv = document.getElementById(\"div1\"); oDiv.onmouseover = function() &#123; startMove(0); &#125;; oDiv.onmouseout = function() &#123; startMove(-150); &#125;; &#125;; var timer = null; function startMove(iTarget) &#123; var oDiv = document.getElementById(\"div1\"); clearInterval(timer); timer = setInterval(function() &#123; //offsetLeft:根据定位的左边距，所以要设置div的绝对定位 var speed = 0; if (oDiv.offsetLeft &gt; iTarget) &#123; speed = -10; &#125; else &#123; speed = 10; &#125; if (oDiv.offsetLeft == iTarget) &#123; clearInterval(timer); &#125; else &#123; oDiv.style.left = oDiv.offsetLeft + speed + \"px\"; &#125; &#125;, 30); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"div1\"&gt; &lt;span&gt;分享&lt;/span&gt; &lt;/div&gt; &lt;/body&gt;&lt;/body&gt; 匀速运动之淡入淡出 所谓淡入淡出，就是当鼠标移到目标时，目标的透明度会匀速恢复到 100%，反之，透明度会返回到初始值； css 样式表中，透明度的设置考虑浏览器兼容： IE：filter: alpha(opacity:30); 其它：opacity: 0.3; 这里可不关 offset 什么事，那怎么办呢? 其实，我们可以设置一个变量，并赋值给它，比如：var alpha=30； 然后，将 speed 的值递加给它：alpha = alpha + speed; 这样，只是将每次的 speed 值赋给变量 alpha，我们就可以通过定时器来匀速改变透明度。 由于兼容问题，我们分开处理： oDiv.style.filter = &quot;alpha(opacity:&#39; + alpha + &#39;)&quot;; oDiv.style.opacity = alpha/100;(因为初始值是 30) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;淡入淡出&lt;/title&gt; &lt;style type=\"text/css\"&gt; #div1 &#123; width: 300px; height: 150px; background-color: #880; filter: alpha(opacity: 30); opacity: 0.3; &#125; &lt;/style&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function() &#123; var oDiv = document.getElementById(\"div1\"); oDiv.onmouseover = function() &#123; getChange(100); &#125;; oDiv.onmouseout = function() &#123; getChange(30); &#125;; &#125;; var alpha = 30; var timer = null; function getChange(iTarget) &#123; var oDiv = document.getElementById(\"div1\"); clearInterval(timer); timer = setInterval(function() &#123; var speed = 0; if (alpha &lt; iTarget) &#123; speed = 10; &#125; else &#123; speed = -10; &#125; if (alpha == iTarget) &#123; clearInterval(timer); &#125; else &#123; alpha += speed; oDiv.style.filter = \"alpha(opacity:' + alpha + ')\"; oDiv.style.opacity = alpha / 100; &#125; &#125;, 30); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"div1\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; JS 缓冲运动的学习总结缓冲运动的要点 顾名思义，所谓缓冲，就是说速度不同；在一定条件下，距离越大，速度越大；距离越小，速度也就越小。 所以，我们只要改变 speed，就基本上 OK。 首先，通过得到位移量，再除以一个数值，就可以改变速度：var speed = (iTarget - ele.offsetLeft)/10; 然后，因为是变速，所以有可能出现小数，不足以达到目标值；这时，通过 Math 对象，可以使 speed 取整，解决不足 1 个像素的问题： 当 speed&gt;0 时，物体从左往右运动，离目标值还差不足 1px，所以我们将 speed 向上取整，Math.ceil(speed); 当 speed&lt;0 时，反之，离目标值还差不足-1px,由于是负数，我们向下取整，比如-0.9，通过 Math.floor(-0.9)，得出-1； 所以，我们用一个三元运算符来进行判断，并赋值给 speed：speed = speed&gt;0 ? Math.ceil(speed) : Math.floor(speed); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;缓冲运动&lt;/title&gt; &lt;style type=\"text/css\"&gt; #div1 &#123; width: 150px; height: 200px; background-color: #880; margin-top: 35px; position: absolute; left: 0; &#125; #div1 p &#123; font-size: 24px; color: #fff; text-align: center; line-height: 200px; margin-top: 0; &#125; #div2, #div3 &#123; width: 0; height: 300px; border: 1px solid #000; position: absolute; left: 300px; &#125; #div3 &#123; left: 600px; &#125; &lt;/style&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function() &#123; var btn_1 = document.getElementById(\"btn1\"); var btn_2 = document.getElementById(\"btn2\"); var btn_3 = document.getElementById(\"btn3\"); btn_1.onclick = function() &#123; startMove(600); &#125;; btn_2.onclick = function() &#123; startMove(300); &#125;; btn_3.onclick = function() &#123; startMove(0); &#125;; &#125;; var timer = null; function startMove(iTarget) &#123; var ele = document.getElementById(\"div1\"); clearInterval(timer); timer = setInterval(function() &#123; //通过位移量除以10，使speed变速，以致实现减速、停止。 var speed = (iTarget - ele.offsetLeft) / 10; //取整，解决最后不足1px的位移量被忽略的问题。 speed = speed &gt; 0 ? Math.ceil(speed) : Math.floor(speed); if (ele.offsetLeft == iTarget) &#123; clearInterval(timer); &#125; else &#123; ele.style.left = ele.offsetLeft + speed + \"px\"; &#125; &#125;, 30); &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=\"button\" id=\"btn1\" value=\"600px\" /&gt; &lt;input type=\"button\" id=\"btn2\" value=\"300px\" /&gt; &lt;input type=\"button\" id=\"btn3\" value=\"0px\" /&gt; &lt;div id=\"div1\"&gt; &lt;p&gt;我是缓冲运动&lt;/p&gt; &lt;/div&gt; &lt;div id=\"div2\"&gt;&lt;/div&gt; &lt;div id=\"div3\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Html","slug":"Html","permalink":"https://www.yangtao.site/categories/Html/"}],"tags":[{"name":"Html","slug":"Html","permalink":"https://www.yangtao.site/tags/Html/"}]},{"title":"实践|制作一个简易数码时钟","slug":"practice-easy-clock","date":"2016-08-04T14:51:12.000Z","updated":"2020-03-18T03:25:19.661Z","comments":true,"path":"2016/08/04/practice-easy-clock/","link":"","permalink":"https://www.yangtao.site/2016/08/04/practice-easy-clock/","excerpt":"整理入坑学习记录","text":"整理入坑学习记录 前言正常显示时间的时分秒，当鼠标移上去的时候，切换成年月日 线上演示【戳我】 主要特色 简洁 金属色彩 setInterval()–&gt;定时器 运用事件 onmouseover()和 onmouseout()，使时间与日期之间自如切换 个人能力有限，还望大家一起修改，使之更加完善 一些问题各个浏览器的显示不是很理想，我已经想尽各种办法，使之平稳展现； 火狐–&gt;进行事件切换时，浮度比较大； 谷歌–&gt;完美运行(去掉某些样式）； IE–&gt;除了最新的，其他的不敢多想； 时分秒12345678910111213141516171819window.onload = function() &#123; var imgs = document.getElementsByTagName(\"img\"); function checkTime(x) &#123; if (x &lt; 10) return \"0\" + x; else return \"\" + x; &#125; function oShowTime() &#123; var oDate = new Date(); var oHou = oDate.getHours(); var oMin = oDate.getMinutes(); var oSec = oDate.getSeconds(); var str = checkTime(oHou) + checkTime(oMin) + checkTime(oSec); for (var i = 0; i &lt; imgs.length; i++) &#123; imgs[i].src = \"images/\" + str[i] + \".JPG\"; &#125; &#125; setInterval(oShowTime, 1000); oShowTime();&#125;; 时间与日期事件切换1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162window.onload = function() &#123; var oDiv = document.getElementById(\"div1\"); var imgs = document.getElementsByTagName(\"img\"); var timer = null; /*判断获取到的数字是否小于10*/ function checkTime(x) &#123; if (x &lt; 10) return \"0\" + x; else return \"\" + x; &#125; /*鼠标点击事件*/ oDiv.onmouseover = function() &#123; clearInterval(timer); fnDate(); &#125;; oDiv.onmouseout = function() &#123; clearInterval(timer); fnTime(); &#125;; /*获取的日期函数*/ function fnDate() &#123; function oShowDate() &#123; var oDate = new Date(); var oYea = oDate.getFullYear(); oYea = oYea.toString(); var oMon = oDate.getMonth() + 1; var oDay = oDate.getDay(); var str = oYea.substr(2, 2) + checkTime(oMon) + checkTime(oDay); var aPar = document.getElementsByTagName(\"p\"); for (var i = 0; i &lt; imgs.length; i++) &#123; imgs[i].src = \"images/\" + str[i] + \".JPG\"; &#125; for (var j = 0; j &lt; aPar.length; j++) &#123; aPar[j].innerHTML = \"-\"; &#125; &#125; timer = setInterval(oShowDate, 1000); oShowDate(); &#125; /*获取的时间函数*/ function fnTime() &#123; function oShowTime() &#123; var oDate = new Date(); var oHou = oDate.getHours(); var oMin = oDate.getMinutes(); var oSec = oDate.getSeconds(); var str = checkTime(oHou) + checkTime(oMin) + checkTime(oSec); var aPar = document.getElementsByTagName(\"p\"); for (var i = 0; i &lt; imgs.length; i++) &#123; imgs[i].src = \"images/\" + str[i] + \".JPG\"; &#125; for (var j = 0; j &lt; aPar.length; j++) &#123; aPar[j].innerHTML = \":\"; &#125; &#125; timer = setInterval(oShowTime, 1000); oShowTime(); &#125; fnTime();&#125;; 样式设置1234567891011121314151617181920212223242526272829303132body &#123; background-color: #333; font-size: 80px;&#125;#div1 &#123; width: 600px; height: 180px; border: 40px solid #999; border-radius: 60px; box-shadow: 10px 14px 12px #777; margin: 150px auto; background-color: #fff;&#125;.div2 &#123; width: 580px; height: 160px; margin: 15px 5px; padding-left: 9px; /*谷歌浏览器不用设置*/&#125;img &#123; width: 60px; height: 110px; float: left; margin: 20px 10px;&#125;p &#123; float: left; color: #555; height: 110px; line-height: 110px; margin: 12px 5px;&#125; 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;数码钟表&lt;/title&gt; &lt;style type=\"text/css\"&gt; body &#123; background-color: #333; font-size: 80px; &#125; #div1 &#123; width: 600px; height: 180px; border: 40px solid #999; border-radius: 60px; box-shadow: 10px 14px 12px #777; margin: 150px auto; background-color: #fff; &#125; .div2 &#123; width: 580px; height: 160px; margin: 15px 5px; padding-left: 9px; /*谷歌浏览器不用设置*/ &#125; img &#123; width: 60px; height: 110px; float: left; margin: 20px 10px; &#125; p &#123; float: left; color: #555; height: 110px; line-height: 110px; margin: 12px 5px; &#125; &lt;/style&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function() &#123; var oDiv = document.getElementById(\"div1\"); var imgs = document.getElementsByTagName(\"img\"); var timer = null; /*判断获取到的数字是否小于10*/ function checkTime(x) &#123; if (x &lt; 10) return \"0\" + x; else return \"\" + x; &#125; /*鼠标点击事件*/ oDiv.onmouseover = function() &#123; clearInterval(timer); fnDate(); &#125;; oDiv.onmouseout = function() &#123; clearInterval(timer); fnTime(); &#125;; /*获取的日期函数*/ function fnDate() &#123; function oShowDate() &#123; var oDate = new Date(); var oYea = oDate.getFullYear(); oYea = oYea.toString(); var oMon = oDate.getMonth() + 1; var oDay = oDate.getDay(); var str = oYea.substr(2, 2) + checkTime(oMon) + checkTime(oDay); var aPar = document.getElementsByTagName(\"p\"); for (var i = 0; i &lt; imgs.length; i++) &#123; imgs[i].src = \"images/\" + str[i] + \".JPG\"; &#125; for (var j = 0; j &lt; aPar.length; j++) &#123; aPar[j].innerHTML = \"-\"; &#125; &#125; timer = setInterval(oShowDate, 1000); oShowDate(); &#125; /*获取的时间函数*/ function fnTime() &#123; function oShowTime() &#123; var oDate = new Date(); var oHou = oDate.getHours(); var oMin = oDate.getMinutes(); var oSec = oDate.getSeconds(); var str = checkTime(oHou) + checkTime(oMin) + checkTime(oSec); var aPar = document.getElementsByTagName(\"p\"); for (var i = 0; i &lt; imgs.length; i++) &#123; imgs[i].src = \"images/\" + str[i] + \".JPG\"; &#125; for (var j = 0; j &lt; aPar.length; j++) &#123; aPar[j].innerHTML = \":\"; &#125; &#125; timer = setInterval(oShowTime, 1000); oShowTime(); &#125; fnTime(); &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"div1\"&gt; &lt;div class=\"div2\"&gt; &lt;img src=\"images/0.JPG\" /&gt; &lt;img src=\"images/0.JPG\" /&gt; &lt;p&gt;:&lt;/p&gt; &lt;img src=\"images/0.JPG\" /&gt; &lt;img src=\"images/0.JPG\" /&gt; &lt;p&gt;:&lt;/p&gt; &lt;img src=\"images/0.JPG\" /&gt; &lt;img src=\"images/0.JPG\" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Html","slug":"Html","permalink":"https://www.yangtao.site/categories/Html/"}],"tags":[{"name":"Html","slug":"Html","permalink":"https://www.yangtao.site/tags/Html/"}]},{"title":"实践|教你制作简易延时提示框","slug":"practice-easy-tooltip","date":"2016-08-04T04:49:10.000Z","updated":"2020-03-18T03:18:41.516Z","comments":true,"path":"2016/08/04/practice-easy-tooltip/","link":"","permalink":"https://www.yangtao.site/2016/08/04/practice-easy-tooltip/","excerpt":"整理入坑学习记录","text":"整理入坑学习记录 动态效果图 第一步分别使用点击事件 onmouseover 和 onmouseout,来设置 oDiv2 的属性，使之显示或隐藏； 12345678var oDiv1 = document.getElementById(\"div1\");var oDiv2 = document.getElementById(\"div2\");oDiv1.onmouseover = function() &#123; oDiv2.style.display = \"block\";&#125;;oDiv1.onmouseout = function() &#123; oDiv2.style.display = \"none\";&#125;; 第二步设置 oDiv2 延时 1 秒后再消失，并且设置一个变量 timer 把它存起来; 123456var timer = null;oDiv1.onmouseout = function() &#123; timer = setTimeout(function() &#123; oDiv2.style.display = \"none\"; &#125;, 1000);&#125;; 第三步当鼠标移到 oDiv2 的时候，由于延时一秒后会消失，所以这时要清除定时器； 123oDiv2.onmouseover = function() &#123; clearTimeout(timer);&#125;; 第四步当鼠标离开 oDiv2 的时候，我们在 oDiv1 和 oDiv2 之间来来回回徘徊时，会有一瞬间的频闪，所以，这里也要设置当鼠标离开 oDiv2 时来个定时器； 12345oDiv2.onmouseout = function() &#123; timer = setTimeout(function() &#123; oDiv2.style.display = \"none\"; &#125;, 1000);&#125;; 第五步当鼠标从 oDiv2 移动到 oDiv1 的时候，由于 oDiv2 的 onmouseout 定时器没有清除，所以过一秒后，oDiv2 还是会消失；这里，我们就清除定时器（当 oDiv2 移动到 oDiv1 时，使 oDiv2 上的定时器解除）： 1234oDiv1.onmouseover = function() &#123; clearTimeout(timer); oDiv2.style.display = \"block\";&#125;; 最后当代码相似的情况下，我们要想办法使之简化，这样就不会显得冗余； 在 JS 中，允许我们这样做：a=b=c=1;所以，观察上面代码我们可以得出以下代码： 123456789oDiv1.onmouseover = oDiv2.onmouseover = function() &#123; clearTimeout(timer); oDiv2.style.display = \"block\";&#125;;oDiv1.onmouseout = oDiv2.onmouseout = function() &#123; timer = setTimeout(function() &#123; oDiv2.style.display = \"none\"; &#125;, 1000);&#125;; 其实，想通制作的步骤，写代码才会行云流水。 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;延时提示&lt;/title&gt; &lt;style type=\"text/css\"&gt; body &#123; background-color: #fc9; &#125; #div1, #div2 &#123; margin: 10px; float: left; color: #fff; text-align: center; border: 3px solid #eee; &#125; #div1 &#123; width: 100px; height: 100px; background-color: #f60; font-size: 20px; padding-top: 10px; &#125; #div2 &#123; width: 300px; height: 250px; background-color: #599; font-size: large; line-height: 48px; padding-top: 10px; display: none; &#125; &lt;/style&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function() &#123; var oDiv1 = document.getElementById(\"div1\"); var oDiv2 = document.getElementById(\"div2\"); var timer = null; oDiv1.onmouseover = oDiv2.onmouseover = function() &#123; clearTimeout(timer); oDiv2.style.display = \"block\"; &#125;; oDiv1.onmouseout = oDiv2.onmouseout = function() &#123; timer = setTimeout(function() &#123; oDiv2.style.display = \"none\"; &#125;, 1000); &#125;; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"div1\"&gt; 登岳阳楼 &lt;p&gt;杜甫&lt;/p&gt; &lt;/div&gt; &lt;div id=\"div2\"&gt; 昔闻洞庭水，今上岳阳楼。&lt;br /&gt; 吴楚东南坼，乾坤日夜浮。&lt;br /&gt; 亲朋无一字，老病有孤舟。&lt;br /&gt; 戎马关山北，凭轩涕泗流。 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 效果图","categories":[{"name":"Html","slug":"Html","permalink":"https://www.yangtao.site/categories/Html/"}],"tags":[{"name":"Html","slug":"Html","permalink":"https://www.yangtao.site/tags/Html/"}]},{"title":"实践|学习制作一个简易日历","slug":"practice-easy-calendar","date":"2016-08-03T10:16:21.000Z","updated":"2020-03-18T03:05:55.725Z","comments":true,"path":"2016/08/03/practice-easy-calendar/","link":"","permalink":"https://www.yangtao.site/2016/08/03/practice-easy-calendar/","excerpt":"整理入坑学习记录","text":"整理入坑学习记录 动态效果图 GIF 图片 先写 html 的 body 部分代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;div id=\"tabs\" class=\"calender\"&gt; &lt;ul&gt; &lt;li class=\"active\"&gt; &lt;h2&gt;1&lt;/h2&gt; &lt;p&gt;JAN&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;h2&gt;2&lt;/h2&gt; &lt;p&gt;FER&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;h2&gt;3&lt;/h2&gt; &lt;p&gt;MAR&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;h2&gt;4&lt;/h2&gt; &lt;p&gt;APR&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;h2&gt;5&lt;/h2&gt; &lt;p&gt;MAY&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;h2&gt;6&lt;/h2&gt; &lt;p&gt;JUN&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;h2&gt;7&lt;/h2&gt; &lt;p&gt;JUL&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;h2&gt;8&lt;/h2&gt; &lt;p&gt;AUG&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;h2&gt;9&lt;/h2&gt; &lt;p&gt;SEP&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;h2&gt;10&lt;/h2&gt; &lt;p&gt;OCT&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;h2&gt;11&lt;/h2&gt; &lt;p&gt;NOV&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;h2&gt;12&lt;/h2&gt; &lt;p&gt;DEC&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class=\"text\"&gt; &lt;h2&gt;1月活动&lt;/h2&gt; &lt;h4&gt;一月小寒接大寒&lt;/h4&gt; &lt;/div&gt;&lt;/div&gt; 设置 css 样式12345678910111213141516171819202122232425262728293031323334353637body &#123; background-color: #890;&#125;#tabs &#123; border: 10px solid #ccc; margin: 50px auto; width: 340px; background-color: #ddd; text-align: center;&#125;#tabs ul li &#123; float: left; list-style-type: none; width: 70px; height: 65px; border: 4px solid #588; margin: 5px; background-color: #222; color: white; line-height: 8px;&#125;/*** css样式设置与.active有冲突时，** 优先级id&gt;class** 细化选择符*/#tabs .active &#123; color: #c66; background-color: #fff;&#125;.text &#123; clear: both; margin: 10px 40px; background-color: #eee; padding: 2px; line-height: 14px;&#125; javascript 代码1234567891011121314151617181920212223242526272829303132333435363738window.onload = function() &#123; var array = [ \"一月小寒接大寒\", \"二月立春雨水连\", \"惊蛰春分在三月\", \"清明谷雨四月天\", \"五月立夏和小满\", \"六月芒种夏至连\", \"七月大暑和小暑\", \"立秋处暑八月间\", \"九月白露接秋分\", \"寒露霜降十月全\", \"立冬小雪十一月\", \"大雪冬至迎新年\" ]; // 这里定义oDiv.get...是为了定义className作用对象是id为tabs下的所有div文本 var oDiv = document.getElementById(\"tabs\"); var aLi = oDiv.getElementsByTagName(\"li\"); var oTxt = oDiv.getElementsByTagName(\"div\")[0]; for (var i = 0; i &lt; aLi.length; i++) &#123; // 定义一个index属性对aLi进行编号 aLi[i].index = i; aLi[i].onmouseover = function() &#123; // 这里是相对于未被点击的部分的样式 for (var i = 0; i &lt; aLi.length; i++) &#123; aLi[i].className = \"\"; &#125; this.className = \"active\"; // 通过之前的index编号绑定指定的div文本 oTxt.innerHTML = \"&lt;h2&gt;\" + (this.index + 1) + \"月活动&lt;/h2&gt;&lt;h4&gt;\" + array[this.index] + \"&lt;/h4&gt;\"; &#125;; &#125;&#125;; 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;简易日历&lt;/title&gt; &lt;style type=\"text/css\"&gt; body &#123; background-color: #890; &#125; #tabs &#123; border: 10px solid #ccc; margin: 50px auto; width: 340px; background-color: #ddd; text-align: center; &#125; #tabs ul li &#123; float: left; list-style-type: none; width: 70px; height: 65px; border: 4px solid #588; margin: 5px; background-color: #222; color: white; line-height: 8px; &#125; #tabs .active &#123; color: #c66; background-color: #fff; &#125; .text &#123; clear: both; margin: 10px 40px; background-color: #eee; padding: 2px; line-height: 14px; &#125; &lt;/style&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function() &#123; var array = [ \"一月小寒接大寒\", \"二月立春雨水连\", \"惊蛰春分在三月\", \"清明谷雨四月天\", \"五月立夏和小满\", \"六月芒种夏至连\", \"七月大暑和小暑\", \"立秋处暑八月间\", \"九月白露接秋分\", \"寒露霜降十月全\", \"立冬小雪十一月\", \"大雪冬至迎新年\" ]; var oDiv = document.getElementById(\"tabs\"); var aLi = oDiv.getElementsByTagName(\"li\"); var oTxt = oDiv.getElementsByTagName(\"div\")[0]; for (var i = 0; i &lt; aLi.length; i++) &#123; aLi[i].index = i; aLi[i].onmouseover = function() &#123; for (var i = 0; i &lt; aLi.length; i++) &#123; aLi[i].className = \"\"; &#125; this.className = \"active\"; oTxt.innerHTML = \"&lt;h2&gt;\" + (this.index + 1) + \"月活动&lt;/h2&gt;&lt;h4&gt;\" + array[this.index] + \"&lt;/h4&gt;\"; &#125;; &#125; &#125;; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"tabs\" class=\"calender\"&gt; &lt;ul&gt; &lt;li class=\"active\"&gt; &lt;h2&gt;1&lt;/h2&gt; &lt;p&gt;JAN&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;h2&gt;2&lt;/h2&gt; &lt;p&gt;FER&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;h2&gt;3&lt;/h2&gt; &lt;p&gt;MAR&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;h2&gt;4&lt;/h2&gt; &lt;p&gt;APR&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;h2&gt;5&lt;/h2&gt; &lt;p&gt;MAY&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;h2&gt;6&lt;/h2&gt; &lt;p&gt;JUN&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;h2&gt;7&lt;/h2&gt; &lt;p&gt;JUL&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;h2&gt;8&lt;/h2&gt; &lt;p&gt;AUG&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;h2&gt;9&lt;/h2&gt; &lt;p&gt;SEP&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;h2&gt;10&lt;/h2&gt; &lt;p&gt;OCT&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;h2&gt;11&lt;/h2&gt; &lt;p&gt;NOV&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;h2&gt;12&lt;/h2&gt; &lt;p&gt;DEC&lt;/p&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class=\"text\"&gt; &lt;h2&gt;1月活动&lt;/h2&gt; &lt;h4&gt;一月小寒接大寒&lt;/h4&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Html","slug":"Html","permalink":"https://www.yangtao.site/categories/Html/"}],"tags":[{"name":"Html","slug":"Html","permalink":"https://www.yangtao.site/tags/Html/"}]}]}